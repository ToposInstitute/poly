% !TeX root = P3-copy.tex
\documentclass[Book-Poly]{subfiles}
\begin{document}

\setcounter{chapter}{7}%Just finished 2.
\Opensolutionfile{solutions}[solution-file8]

%---------------- Part ----------------%
\part{Data dynamics}\label{chapter.bimod} 

%------------ Chapter ------------%
\chapter{Copresheaves}\label{sec.copresheaves_data_ds}





\begin{proposition}\label{prop.ds_dopf}
Up to isomorphism, discrete opfibrations into $\cat{C}$ can be identified with dynamical systems on $\cat{C}$.
\end{proposition}
In case it isn't clear, this association is only functorial on the groupoid of objects and isomorphisms.
\begin{proof}
Given a discrete opfibration $\pi\colon\cat{S}\to\cat{C}$, take $S\coloneqq\Ob(\cat{S})$ and define $(\varphi_1,\varphi^\sharp)\colon S\yon^S\to\car{c}$ by $\varphi_1=\pi$ and with $\varphi^\sharp$ given by the lifting: $\varphi(g)\coloneqq \hat{g}$ as in \cref{def.dopf}. One checks using \cref{exc.dopf_cof} that this defines a cofunctor. 

Conversely, given a cofunctor $(\varphi_1,\varphi^\sharp)\colon S\yon^S\to\car{c}$, the function $\varphi_1$ induces a map of polynomials $S\yon\to\car{c}$, and we can factor it as a vertical followed by a cartesian $S\yon\to\car{s}\To{\psi}\car{c}$. We can give $\car{s}$ the structure of a category such that $\psi$ is a cofunctor; see \cref{exc.ds_dopf}.
\end{proof}

\begin{exercise}\label{exc.ds_dopf}
With notation as in \cref{prop.ds_dopf}, complete the proof as follows.
\begin{enumerate}
	\item Check that $(\varphi,\varphi^\sharp)$ defined in the first paragraph is indeed a cofunctor.
	\item Find a comonoid structure on $\car{s}$ such that $\psi$ is a cofunctor, as stated in the second paragraph. 
	\item Show that the two directions are inverse, up to isomorphism.
\qedhere
\end{enumerate}
\end{exercise}

\begin{example}
In \cref{ex.cofree_dyn_sys} we had a dynamical system with $S\coloneqq\{\bul[dgreen],\bul[dyellow],\bul[red]\}$ and $p\coloneqq\yon^\2+\1$, and  $f\colon S\yon^S\to p$ from \cref{exc.halt_dsa}, depicted here again for your convenience:
\begin{equation}\label{eqn.dyn_sys_misc573}
\begin{tikzcd}[column sep=small]
	\bul[dgreen]\ar[rr, bend left, orange]\ar[loop left, dgreen]&&
	\bul[dyellow]\ar[dl, bend left, orange]\ar[ll, dgreen, bend left]\\&
	\bul[red]
\end{tikzcd}
\end{equation}
The polynomial map $f$ induces a cofunctor $F\colon S\yon^S\cof\cofree{p}$ from the state category on $S$ to the category of $p$-trees. We can now see this as a database instance on $\cofree{p}$, considered as a database schema. 

The cofree category $\cofree{t}$ is actually the free category on a graph, as we saw in \cref{prop.cofree_free_on_graph}, and so the schema is easy. There is one table for each tree (object in $\cofree{p}$), e.g.\ we have a table associated to this tree:
\[
	\treepic
\]
The table has two columns, say left and right, corresponding to the two arrows emanating from the root node. The left column refers back to the same table, and the right column refers to another table (the one corresponding to the yellow dot).

Again, there are infinitely many tables in this schema. Only three of them have data in them; the rest are empty. We know in advance that this instance has three rows in total, since $|S|=3$.
\end{example}

Given a dynamical system $S\yon^S\to p$, we extend it to a cofunctor $\varphi\colon S\yon^S\cof\cofree{p}$. By \cref{prop.tfae_dopf,prop.ds_dopf}, we can consider it as a discrete opfibration over $\cofree{p}$. By \cref{exc.elts_free_grph} the category $\elts \varphi$ is again free on a graph. It is this graph that we usually draw when depicting the dynamical system, e.g.\ in \eqref{eqn.dyn_sys_misc573}.


\begin{exercise}
Give an example of a dynamical system on $p\coloneqq\yon^\2+\yon$ for which the corresponding database instance has a table with at least two rows.
\end{exercise}

\begin{exercise}
A dynamical system with interface $\yon$ is a map $S\yon^S\to\yon$.
\begin{enumerate}
	\item What is the corresponding database schema?
	\item Explain what the corresponding database instance looks like.
	\item In particular, how many total rows does it have?
	\item Give an example with $|S|=7$, displayed both as a dynamical system (with states and transitions) and as a database instance.	
\qedhere
\end{enumerate}
\end{exercise}

\Closesolutionfile{solutions}

%-------- Section --------%
\section{Exercise solutions}
{\footnotesize
\input{solution-file8}}

\Opensolutionfile{solutions}[solution-file9]

\Closesolutionfile{solutions}

%------------ Chapter ------------%
\chapter{Bicomodules over polynomial comonoids}\label{sec.bicomodules}

*****

It turns out that bicomodules between comonoids in $\poly$ (categories) are also important objects of study in category theory. If $\cat{C}$ and $\cat{D}$ are categories, Richard Garner showed that a bicomodule between them can be identified with what's known as a \emph{parametric right adjoint} between the associated copresheaf categories $\smset^{\cat{C}}$ and $\smset^{\cat{D}}$. Parametric right adjoints, or \emph{pra}'s come up in $\infty$-category theory, but they also have a much more practical usage: they are the so-called \emph{data migration functors}.

\begin{theorem}\label{thm.tfae_c_sets}
Given a polynomial comonoid $\cat{C}=(\car{c},\epsilon,\delta)$, the following comprise equivalent categories:
\begin{enumerate}
	\item functors $\cat{C}\to\smset$;
	\item discrete opfibrations over $\cat{C}$;
	\item cartesian cofunctors to $\com{C}$;
	\item $\com{C}$-coalgebras (sets with a coaction by $\com{C}$);
	\item constant left $\com{C}$-comodules;
	\item $(\com{C},\0)$-bicomodules;
	\item linear left $\com{C}$-comodules; and
	\item representable right $\com{C}$-comodules (opposite).
\end{enumerate}
In fact, all but the first comprise isomorphic categories; and up to isomorphism, any one of these can be identified with a cofunctor from a state category to $\cat{C}$.
\end{theorem}
\begin{proof}
\begin{description}
	\item[$1\simeq 2\cong 3$:] This was shown in \cref{prop.tfae_dopf}.
	\item[$3\cong 4$:] Given a cartesian cofunctor $(\pi_1,\pi^\sharp)\colon\cat{S}\cof\cat{C}$, let $S\coloneqq\Ob(\cat{S})$ and define a $\car{c}$-coalgebra structure $\alpha\colon S\to\car{c}\tri S$ on an object $s\in\Ob(\cat{S})$ and an emanating morphism $f\colon\pi_1(s)\to c'$ in $\cat{C}$ by
	\[
  \begin{tikzpicture}[polybox, mapstos]
  	\node[poly, dom, "$S$" left] (yX) {$\varnothing$\nodepart{two}$s$};
  	\node[poly, cod, right=1.8 of yX.south, yshift=-1ex, "$\car{c}$" right] (p) {$f$\nodepart{two}$\pi_1(s)$};
  	\node[poly, above=of p, "$S$" right] (p') {$\varnothing$\nodepart{two}$\cod\pi^\sharp_s(f)$};
  	\draw (yX_pos) to[first] node[below] {$\alpha_1$}(p_pos);
  	\draw (p_dir) to[climb] node[right] {$\alpha_2$} (p'_pos);
  	\draw (p'_dir) to[last] node[above left] {$!$} (yX_dir);
  \end{tikzpicture}
	\]
	We check that this is indeed a coalgebra using properties of cofunctors. For identities in $\com{C}$, we have
	\begin{align*}
  	\alpha_2(s,\id_{\pi_1(s)})&=
  	\cod\pi^\sharp_s(\id_{\pi_1(s)})\\&=
		\cod\id_{s}=s
	\end{align*}
	and for compositions in $\com{C}$ we have
	\begin{align*}
		\alpha_2(s, f\then g)&=
		\cod\left(\pi_s^\sharp(f\then g)\right)\\&=
		\cod\left(\pi_s^\sharp(f)\then\pi^\sharp_{\cod\pi^\sharp_s(f)}g\right)\\&=
		\cod\left(\pi^\sharp_{\cod\pi^\sharp_s(f)}g\right)\\&=
		\alpha_2(\alpha_2(s,f),g).
	\end{align*}
	Going backward, if we're given a coalgebra $\alpha\colon S\to\car{c}\tri S$, we obtain a function $\alpha_1\colon S\to\car{c}\tri\1$ and we define $\car{s}\coloneqq \alpha_1^*\car{c}$ and the cartesian map $\varphi\coloneqq(\alpha_1,\id)\colon\car{s}\to\car{c}$ to be the base change from \cref{prop.basechange}. We need to show $\car{s}$ has a comonoid structure $(\car{s},\epsilon,\delta)$ and that $\varphi$ is a cofunctor. We simply define the eraser $\epsilon\colon\car{s}\to\yon$ using $\alpha_1$ and the eraser on $\car{c}$:
	\[
	\begin{tikzpicture}[polybox, mapstos]
  	\node[poly, dom, "$\car{s}$" below] (c) {$\id_{\alpha_1(s)}$\nodepart{two}$s\vphantom{s_1}$};
  	\node[poly, cod, right=of c, "$\car{c}$" below] (c') {$\id_{\alpha_1{s}}$\nodepart{two}$\alpha_1(s)$};
  	\draw (c_pos) -- node[below] {$\alpha_1$} (c'_pos);
  	\draw[double] (c'_dir) -- (c_dir);
		\draw (c'_pos) to[climb'] node[right] {$\epsilon_\car{c}$} (c'_dir);
	\end{tikzpicture}
	\]
 We give the duplicator $\delta\colon\car{s}\to\car{s}\tri\car{s}$ using $\alpha_2$ for the codomain, and using the composite $\then$ from $\car{c}$:
	\[
  \begin{tikzpicture}[polybox, mapstos]
  	\node[poly, dom, "$\car{s}$" left] (yX) {$f\then g$\nodepart{two}$s$};
  	\node[poly, cod, right=2.5 of yX.south, yshift=-1ex, "$\car{s}$" right] (p) {$f$\nodepart{two}$s$};
  	\node[poly, cod, above=of p, "$\car{s}$" right] (p') {$g$\nodepart{two}$\alpha_2(s,f)$};
  	\draw[double] (yX_pos) to[first] (p_pos);
  	\draw (p_dir) to[climb] node[right] {$\cod$} (p'_pos);
  	\draw (p'_dir) to[last] node[above left] {$\comp$} (yX_dir);
  \end{tikzpicture}	
  \]
  In \cref{exc.tfae_c_sets} we check that $(\car{s},\epsilon,\delta)$ really is a comonoid, that $(\alpha_1,\id)\colon\car{s}\cof\car{c}$ is a cofunctor, that the roundtrips between cartesian cofunctors and coalgebras are identities, and that these assignments are functorial.
	\item[$4\cong5$:]This is straightforward and was mentioned in \cref{def.coalgebra}.
	\item[$5\cong6$:]A right $\0$-comodule is in particular a polynomial $m\in\poly$ and a map $\rho\colon m\to m\tri\0$ such that $(m\tri\epsilon)\circ\rho=\id_m$. This implies $\rho$ is monic, which itself implies by \cref{prop.monics_in_poly} that $m$ must be constant since $m\tri\0$ is constant. This makes $m\tri\epsilon$ the identity, at which point $\rho$ must also be the identity. Conversely, for any set $M$, the corresponding constant polynomial is easily seen to make the diagrams in \eqref{eqn.bimod_right} commute.
	\item[$5\cong7$:] By the adjunction in \cref{prop.adjoint_quadruple} and the fully faithful inclusion $\smset\to\poly$ of sets as constant polynmials, \cref{prop.ff_const_set_to_poly}, we have isomorphisms
	\[\poly(S\yon,\car{c}\tri S\yon)\cong\smset(S,\car{c}\tri S\yon\tri\1)=\smset(S,\car{c}\tri S)\cong\poly(S,\car{c}\tri S).\]
	One checks easily that if $S\yon\to\car{c}\tri S\yon)$ corresponds to $S\to\car{c}\tri S$ under the above isomorphism, then one is a left comodule iff the other is.
	\item[$7\cong8$:] By \eqref{eqn.flip_reps_lins} we have a natural isomorphism
	\[
		\poly(S\yon,\car{c}\tri S\yon)\cong\poly(\yon^S,\yon^S\tri\car{c}).
	\]
	In pictures,
	\[
	\begin{tikzpicture}
		\node (p1) {
		\begin{tikzpicture}[polybox, tos]
			\node[poly, linear dom] (s) {};
			\node[poly, cod, right=of s.south, yshift=-1ex] (c) {};
			\node[poly, linear cod, above=of c] (s') {};
    	\node[left=0pt of s_pos] {$S$};
    	\node[right=0pt of c_pos] {$\car{c}(\1)$};
    	\node[right=0pt of c_dir] {$\car{c}[\ ]$};
    	\node[right=0pt of s'_pos] {$S$};
			\draw (s_pos) to[first] node[below] {$f$} (c_pos);
			\draw (c_dir) to[climb] node[right] {$g$} (s'_pos);
			\draw (s'_dir) to[last] node[above] {$!$} (s_dir);
		\end{tikzpicture}
		};
		\node (p2) [right=2 of p1] {
		\begin{tikzpicture}[polybox, tos]
			\node[poly, pure dom] (s) {};
			\node[poly, pure cod, right=of s.south, yshift=-1ex] (s') {};
			\node[poly, cod, above=of s'] (c) {};
    	\node[left=0pt of s_dir] {$S$};
    	\node[right=0pt of c_pos] {$\car{c}(\1)$};
    	\node[right=0pt of c_dir] {$\car{c}[\ ]$};
    	\node[right=0pt of s'_dir] {$S$};
			\draw (s_pos) to[first] node[below] {$!$} (s'_pos);
			\draw (s'_dir) to[climb] node[right] {$f$} (c_pos);
			\draw (c_dir) to[last] node[above] {$g$} (s_dir);
		\end{tikzpicture}		
		};
	\end{tikzpicture}
	\]
\end{description}
\noindent
The last claim was proven in \cref{prop.ds_dopf}.
\end{proof}

\begin{exercise}\label{exc.tfae_c_sets}
Complete the proof of \cref{thm.tfae_c_sets} ($3\cong 4$) by proving the following.
\begin{enumerate}
	\item Show that $(\car{s},\epsilon,\delta)$ really is a comonoid.
	\item Show that $(\alpha_1,\id)\colon\car{s}\cof\car{c}$ is a cofunctor.
	\item Show that the roundtrips between cartesian cofunctors and coalgebras are identities.
	\item Show that the assignment of a $\com{C}$-coalgebra to a cartesian cofunctor over $\cat{C}$ is functorial.
	\item Show that the assignment of a cartesian cofunctor over $\cat{C}$ to a $\com{C}$-coalgebra is functorial.
\qedhere
\end{enumerate}
\end{exercise}

Let $\cat{C}$ be a category. Under the above correspondence, the terminal functor $\cat{C}\to\smset$ corresponds to the identity discrete opfibration $\cat{C}\to\cat{C}$, the identity cofunctor $\com{C}\to\com{C}$, a certain left $\com{C}$ comodule with carrier $\com{C}(\1)\yon$ which we call the \emph{canonical left $\com{C}$-comodule}, a certain constant left $\com{C}$ comodule with carrier $\com{C}(\1)$ which we call the \emph{canonical $(\com{C},\0)$-bicomodule}, and a certain representable right $\com{C}$-comodule with carrier $\yon^{\com{C}(\1)}$ which we call the \emph{canonical right $\cat{C}$-comodule}.

\begin{exercise}
For any object $c\in \cat{C}$, consider the representable functor $\cat{C}(c,-)\colon\cat{C}\to\smset$. What does it correspond to as a
\begin{enumerate}
	\item discrete opfibration over $\cat{C}$?
	\item cartesian cofunctor to $\com{C}$?
	\item linear left $\com{C}$-comodule?
	\item constant left $\com{C}$-comodule?
	\item $(\com{C},\0)$-bicomodule?
	\item representable right $\com{C}$-comodule?
	\item dynamical system with comonoid interface $\com{C}$?
\qedhere
\end{enumerate}
\end{exercise}

\begin{exercise}
We saw in \cref{thm.tfae_c_sets} that the category $\bimod{\cat{C}}{\0}$ of $(\cat{C},\0)$-bicomodule has a very nice structure: it's the topos of copresheaves on $\cat{C}$. 
\begin{enumerate}
	\item What is a $(\0,\cat{C})$-bicomodule?
	\item What is $\bimod{\0}{\cat{C}}$?
\qedhere
\end{enumerate}
\end{exercise}

%\begin{example}\label{ex.clue_as_module}
%We continue with the Clue game from \cref{ex.clue_game}. The database instance is encoded as:
%\[
%\left(
% \begin{array}{ccc}
% 	10&&10\\
%	&+\\
%	10&&3
% \end{array}
%\right)
%\too
%\left(
%	\begin{array}{ccc}
%		\left(
% 		\begin{array}{ccc}
%  		\1\0&&\1\0\\
%  		&+\\
%  		\1\0&&\3
%   	\end{array}
%		\right)^\4
%		&&
%		\left(
% 		\begin{array}{ccc}
%  		\1\0&&\1\0\\
%  		&+\\
%  		\1\0&&\3
%   	\end{array}
%		\right)^\2
%		\\
%		&+\\
%		\left(
% 		\begin{array}{ccc}
%  		\1\0&&\1\0\\
%  		&+\\
%  		\1\0&&\3
%   	\end{array}
%		\right)^\2
%		&&
%		\left(
% 		\begin{array}{ccc}
%  		\1\0&&\1\0\\
%  		&+\\
%  		\1\0&&\3
%   	\end{array}
%		\right)^\1
%  \end{array}
%\right)
%\]
%Or if you prefer, $\3\3\to\3\3^\4+\3\3^\2+\3\3^\2+\3\3$.
%\end{example}




\begin{definition}[Polynomial functors of many variables]
GK definition.
\end{definition}

\begin{proposition}
The bicategory of polynomial functors in the sense of \cite{GK} is precisely that of bicomodules between discrete categories.
\end{proposition}
\begin{proof}
**
\end{proof}

\begin{example}[Cellular automata]\label{ex.cellular_bimod}
In \cref{ex.graph_interaction,exc.conway} we briefly discussed cellular automata; here we will discuss another way that cellular automata show up, this time in terms of bicomodules.

Suppose that $\src,\tgt\colon A\tto V$ is a graph, and consider the polynomial
\[
  g\coloneqq\sum_{v\in V}\yon^{\src\inv(v)}
\]
so that positions are vertices and directions are emanating arrows. It carries a natural bicomodule structure
\[
V\yon\bimodfrom[g]V\yon
\]
where the right structure map uses $\tgt$; see \cref{exc.cellular_bimod} for details. A bicomodule
\[
V\yon\bimodfrom[T]\0
\]
can be identified with a functor $T\colon V\to\smset$, i.e.\ it assigns to each vertex $v\in V$ a set. Let's call $T(v)$ the color set at $v$; for many cellular automata we will put $T(v)\cong\2$ for each $v$.

Then a cellular automata on $g$ with color sets $T$ is given by a map
\[
\begin{tikzcd}
	V\yon\ar[r, bimr-biml, "g"]\ar[rr, bend right=40pt, bimr-biml, "T"', "" name=T]&
	V\yon\ar[r, bimr-biml, "T"]\ar[to=T, Rightarrow, "\alpha"]&
	\0
\end{tikzcd}
\]
Indeed, for every vertex $v\in V$ the map $\alpha$ gives a function
\[
\prod_{\src(a)=v}T(\tgt(a))\Too{\alpha_v} T(v),
\]
which we call the \emph{update} function. In other words, given the current color at the target of each arrow emanating from $v$, the function $\alpha_v$ returns a new color at $v$.

Note that if $V\in\bimod{V\yon}{\0}$ is the terminal object, then the composite $V\yon\bimodfrom[g]V\yon\bimodfrom[V]\0$ is again $V$.
\end{example}

\begin{exercise}\label{exc.cellular_bimod}
Let $\src,\tgt\colon A\tto V$ and $g$ and $T$ be as in \cref{ex.cellular_bimod}.
\begin{enumerate}
	\item Give the structure map $\lambda\colon g\to V\yon\tri g$
	\item Give the structure map $\rho\colon g\to g\tri V\yon$.
	\item Give the set $T$ and the structure map $T\to V\yon\tri T$ corresponding to the functor $V\to\smset$ that assigns $\2$ to each vertex.
\qedhere
\end{enumerate}
\end{exercise}

\begin{example}[Running a cellular automaton]
Let $g$ be a graph on vertex set $V$, let $T$ assign a color set to each $v\in V$, and let $\alpha$ be the update function for a cellular automaton. As in \cref{ex.cellular_bimod}, this is all given by a diagram
\[
\begin{tikzcd}
	V\yon\ar[r, bimr-biml, "g"]\ar[rr, bend right=40pt, bimr-biml, "T"', "" name=T]&
	V\yon\ar[r, bimr-biml, "T"]\ar[to=T, Rightarrow, "\alpha"]&
	\0
\end{tikzcd}
\]
To run the cellular automaton, one simply chooses a starting color in each vertex. We call this an initialization; it is given by a map of bicomodules
\begin{equation}\label{eqn.starting_color_v}
\begin{tikzcd}
	V\yon
		\ar[r, bimr-biml, bend left, "V\yon"]
		\ar[r, bimr-biml, bend right, "T"']\ar[r, phantom, "\hphantom{\scriptstyle\sigma}\Downarrow\scriptstyle\sigma"]&
	V\yon
\end{tikzcd}
\end{equation}

Now to run the cellular automaton on that initialization for $k\in\nn$ steps is given by the composite
\[
\begin{tikzcd}
	V\yon\ar[d, equal]\ar[r, bimr-biml, "g"]\ar[rrrr, bend left, "V"]&
	\cdots\ar[r, bimr-biml, "g"]&
	V\yon\ar[d, equal]\ar[r, bimr-biml, "g"]&
	V\yon\ar[d, equal]\ar[r, bimr-biml, "g"]&
	\0\ar[d, equal]\ar[dl, phantom, "\Downarrow\scriptstyle\sigma"]\\
	V\yon\ar[d, equal]\ar[r, bimr-biml, "g"]&	
	\cdots\ar[r, bimr-biml, "g"]&
	V\yon\ar[d, equal]\ar[r, bimr-biml, "g"]&
	V\yon\ar[r, bimr-biml, "T"]&
	\0\ar[d, equal]\ar[dll, phantom, "\Downarrow\scriptstyle\alpha"]\\
	V\yon\ar[d, equal]\ar[r, bimr-biml, "g"]&
	\cdots\ar[r, bimr-biml, "g"]&|[alias=V]|
	V\yon\ar[rr, bimr-biml, "T"]&&
	\0\ar[d, equal]\\
	V\yon\ar[rrrr, bimr-biml, "T"', "" name=T]&&&&
	\0
	\ar[from=V, to=V|-T, Rightarrow, "\alpha\circ\cdots\circ\alpha"]
\end{tikzcd}
\]
\end{example}

\begin{exercise}
Explain why \eqref{eqn.starting_color_v} models an initialization, i.e.\ a way to choose a starting color in each vertex.
\end{exercise}

\begin{proposition}\label{prop.all_free_modules}
Let $\com{C}=(\car{c},\epsilon,\delta)$ be a comonoid in $\poly$. For any set $G$, the polynomial $\yon^G\tri\car{c}$ has a natural right $\com{C}$-comodule structure.
\end{proposition}
\begin{proof}
We use the map $(\yon^G\tri\delta)\colon(\yon^G\tri\car{c})\to(\yon^G\tri\car{c}\tri\car{c})$. It satisfies the unitality and associativity laws because $\car{c}$ does.
\end{proof}

We can think of elements of $G$ as ``generators''. Then if $i'\colon G\to\car{c}\tri\1$ assigns to every generator an object of a category $\cat{C}$, then we should be able to find the free $\cat{C}$-set that $i'$ generates.

\begin{proposition}
Functions $i'\colon G\to\car{c}\tri\1$ are in bijection with positions $i\in\yon^G\tri\car{c}\tri\1$. Let $m\coloneqq i^*(\yon^G\tri\car{c})$ and let $\rho_i$ be the induced right $\com{C}$-comodule structure from \cref{prop.right_modules_as_sums}. Then $\rho_i$ corresponds to the free $\cat{C}$-set generated by $i'$. 
\end{proposition}
\begin{proof}
The polynomial $m$ has the following form:
\[
m\cong\yon^{\sum_{g\in G}\car{c}[i'(g)]}
\]
In particular $\rho_i$ is a representable right $\com{C}$-comodule, and we can identify it with a $\cat{C}$-set by \cref{thm.tfae_c_sets}. The elements of this $\cat{C}$-set are pairs $(g, f)$, where $g\in G$ is a generator and $f\colon i'(g)\to\cod(f)$ is a morphism in $\cat{C}$ emanating from $i'(g)$. It is easy to see that the comodule structure induced by \cref{prop.all_free_modules} is indeed the free one.
\end{proof}

\begin{exercise}
Let $\cat{C}$ be a category and $i \in \cat{C}$ an object.
\begin{enumerate}
    \item Consider $i$ as a map $\yon \to \car{c}$.
    Show that the vertical-cartesian factorization of this map is $\yon \to \yon^{\car{c}[i]} \To{\varphi} \car{c}$.
    \item Use \cref{prop.comp_pres_cart} to show that $\yon^{\car{c}[i]} \tri \car{c} \to \car{c} \tri \car{c}$ is cartesian.
    \item Show that there is a commutative square
    \[
    \begin{tikzcd}
        \yon^{\car{c}[i]} \ar[r, "\delta^i"] \ar[d, "\varphi"'] & \yon^{\car{c}[i]} \tri \car{c} \ar[d, "\text{cart}"] \\
        \car{c} \ar[r, "\delta"'] & \car{c} \tri \car{c} \ar[ul, phantom, very near end, "\lrcorner"]
    \end{tikzcd}
    \]
    \item Show that this square is a pullback, as indicated.
    \item Show that $\delta^i$ makes $\yon^{\car{c}[i]}$ a right $\com{C}$-comodule.
    \qedhere
\end{enumerate}
\end{exercise}

The map $\delta^i$ can be seen as the restriction of $\delta \colon \car{c} \to \car{c} \tri \car{c}$ to a single starting position.

We can extend this to a functor $\cat{C} \to \bimod{\yon}{\cat{C}}$ that sends the object $i$ to $\yon^{\car{c}[i]}$. Given a morphism $f \colon i \to i'$ in $\cat{C}$, we get a function $\car{c}[i'] \to \car{c}[i]$ given by composition with $f$, and hence a map of polynomials $\yon^{\car{c}[f]} \colon \yon^{\car{c}[i]} \to \yon^{\car{c}[i']}$.

\begin{exercise}
\begin{enumerate}
    \item Show that $\yon^{\car{c}[f]}$ is a map of right $\com{C}$-comodules.
    \item Show that the construction $\yon^{\car{c}[f]}$ is functorial in $f$. \qedhere
\end{enumerate}
\end{exercise}

\begin{definition}[Yoneda] \label{def.yoneda_functor}
Let $\cat{C}$ be a category.
We refer to the above functor $\yon^{\car{c}[-]} \colon \cat{C} \to \bimod{\yon}{\cat{C}}$ as the \emph{Yoneda} functor.
\end{definition}

\begin{proposition}
The Yoneda functor $\yon^{\car{c}[-]} \colon \cat{C} \to \bimod{\yon}{\cat{C}}$ is fully faithful.
\end{proposition}
\begin{proof}
**
\end{proof}

\begin{proposition}
For any functor $F\colon\cat{C}\to\poly$, the limit polynomial $\lim_{c\in\cat{C}}F(c)$ is obtained by composing with the canonical right bicomodule $\yon^{\Ob(\cat{C})}$
\[
\begin{tikzcd}
  \yon\ar[r,biml-bimr, "F"]\ar[rr, biml-bimr, bend right=20pt, "\lim F"']&
  \com{C}\ar[r,biml-bimr, "\yon^{\Ob(\cat{C})}"]&[5pt]
  \yon
\end{tikzcd}
\]
\end{proposition}

\begin{proposition}\label{prop.break_up_right_mods}
Let $\com{C}$ be a comonoid. For any set $I$ and right $\com{C}$-comodules $(m_i)_{i\in I}$, the coproduct $m\coloneqq \sum_{i\in I}m_i$ has a natural right-comodule structure. Moreover, each representable summand in the carrier $m$ of a right $\com{C}$-comodule is itself a right-$\com{C}$ comodule and $m$ is their sum.
\end{proposition}
\begin{proof}
**
\end{proof}
%
%Let $\sum_{I\in\smset}\prod_{i\in I}\bimod{}{\com{C}}$ denote the category whose objects are pairs $(I,(m_i)_{i\in I})$ where $I$ is a set and $m_i$ is a right $\com{C}$-comodule for each $i\in I$. A morphism $(I,(m_i)_{i\in I})\to(J,(n_j)_{j\in J})$ is a function $f\colon I\to J$ and, for each $i\in I$ a morphism $m_i\to n_{f(i)}$ of right-$\com{C}$ comodules.
%
%\begin{proposition}
%For any comonoid $\com{C}$ there is an adjunction
%\[
%\adj[40pt]{\bimod{}{\com{C}}}{\sum_{i\in I}m_i}{{(n(\1),n[-])}}{\sum_{I\in\smset}\prod_{i\in I}\bimod{}{\com{C}}}
%\]
%with functors labeled by where they send $n\in\bimod{}{\com{C}}$ and $(I,(m_i)_{i\in I})\in\sum_{I\in\smset}\prod_{i\in I}\bimod{}{\com{C}}$. 
%
%Moreover, the left adjoint is fully faithful.
%\end{proposition}

\begin{proposition}
If $m\in\poly$ is equipped with both a right $\com{C}$-comodule and a right $\com{D}$-comodule structure, we can naturally equip $m$ with a $(\com{C}\times\com{D})$-comodule structure.
\end{proposition}
\begin{proof}
It suffices by \cref{prop.break_up_right_mods} to assume that $m=\yon^M$ is representable. But a right $\com{C}$-comodule with carrier $\yon^M$ can be identified with a cofunctor $M\yon^M\to\com{C}$.

Thus if $\yon^M$ is both a right-$\com{C}$ comodule and a right-$\com{D}$ comodule, then we have comonoid morphisms $\com{C}\from M\yon^M\to\com{D}$. This induces a unique comonoid morphism $M\yon^M\to(\com{C}\times\com{D})$ to the product, and we identify it with a right-$(\com{C}\times\com{D})$ comodule on $\yon^M$.
\end{proof}

%-------- Section --------%
\section{Bicomodules as data migration functors}

\begin{proposition}\label{prop.prafunctor}
Let $\cat{C}$ and $\cat{D}$ be categories; the following conditions on a functor $F\colon\smset^{\cat{C}}\to\smset^{\cat{D}}$ are equivalent.
\begin{enumerate}
	\item $F$ is composition with a $(\cat{D},\cat{C})$-bicomodule.
	\item $F$ is a parametric right adjoint in the sense of \cite{}.
	\item $F$ profunctor + discrete opfibration
	\item $F$ preserves connected limits.
\end{enumerate}
\end{proposition}

\begin{definition}[Prafunctor]
Let $\cat{C}$ and $\cat{D}$ be categories. A \emph{prafunctor} (also called a \emph{parametric right adjoint functor}) $\smset^{\cat{C}}\to\smset^{\cat{D}}$ is one satisfying any of the conditions of \cref{prop.prafunctor}.
\end{definition}

When a polynomial
\[
m\coloneqq\sum_{i\in m(\1)}\yon^{m[i]}
\]
is given the structure of a $(\cat{D},\cat{C})$-bicomodule, the symbols in that formula are given a hidden special meaning:
\[
  m(\1)\in\smset^{\cat{D}}
  \qqand
	m[i]\in\smset^{\cat{C}}
\]
Thus $m(1)$ is a database instance on $\cat{D}$; in particular, each position in $i\in m(\1)$ is a row in that instance. And each $m[i]$ is a database instance on $\cat{C}$; in particular, each direction $d\in m[i]$ is a row in that instance.

Before we knew about bicomodule structures, what we called positions and directions---and what we often think of as outputs and inputs of a system---were understood as each forming an ordinary set. In the presence of a bicomodule structure, the positions $m(\1)$ have been organized into a $\cat{D}$-set and the directions $m[i]$ have been organized into a $\cat{C}$-set for each position $i$. We are listening for $\cat{C}$-sets and positioning ourselves in a $\cat{D}$-set.

%-------- Section --------%
\section{Monoidal operations}

\begin{theorem} \label{thm.pra_tensored_cat}
For any categories $\cat{C}$ and $\cat{D}$, the functor 
\[
    \bimod{\cat{C}}{\cat{D}} \To{\cong} \smcat(\cat{C}, \bimod{\yon}{\cat{D}})
\]
is an equivalence.
\end{theorem}
\begin{proof}
%     Given a left $\com{C}$-comodule $m$, we begin by denoting it using polyboxes:
%     	\[
%   \begin{tikzpicture}[polybox, tos]
%   	\node[poly, dom, "$m$" left] (m) {\nodepart{two} $j$};
%   	\node[poly, cod, right=1.8 of m.south, yshift=-1ex, "$\car{c}$" right] (c)  {$f$ \nodepart{two} $i$};
%   	\node[poly, cod, above=of c, "$m$" right] (mm) {$q$};
%   	\draw (m_pos) to[first] node[below] {$\lambda_1$}(c_pos);
%   	\draw (c_dir) to[climb] node[right] {$\lambda_2$} (mm_pos);
%   	\draw (mm_dir) to[last] node[above left] {$\lambda^\sharp$} (m_dir);
%   \end{tikzpicture}
% 	\]
% 	satisfying
% 	\begin{equation} \label{eqn.resp_eraser}
%     \begin{tikzpicture}
%     	\node (1) {
%     \begin{tikzpicture}[polybox, tos]
%       	\node[poly, dom, "$m$" left] (m) {\nodepart{two} $j$};
%       	\node[poly, right=1.8 of m.south, yshift=-1ex, "$\car{c}$" below] (c) {\nodepart{two} $i$};
%       	\node[poly, above=of c, "$m$" above] (mm) {$q'$};
%       	\node[poly, cod, identity, right=of c] (y) {};
%       	\node[poly, cod, above=of y, "$m$" above] (mmm) {$q'$};
%       	\draw (c_pos) -- (y_pos);
%       	\draw (y_dir) -- node[above] {$\idy$} (c_dir);
%       	\draw[double] (mm_pos) -- (mmm_pos);
%       	\draw[double] (mmm_dir) -- (mm_dir);
%       	\draw (m_pos) to[first] node[below] {$\lambda_1$} (c_pos);
%       	\draw (c_dir) to[climb] node[right] {$\lambda_2$} (mm_pos);
%       	\draw (mm_dir) to[last] node[above left] {$\lambda^\sharp$} (m_dir);
%     \end{tikzpicture}
%     	};
%     \node[right=1.6 of 1] (2) {
%     \begin{tikzpicture}[polybox, tos]
%       \node[poly, dom, "$m$" left] (m) {$q'$ \nodepart{two} $j$};
%       \node[poly, cod, right= of m, "$m$" right] (mm) {$q'$ \nodepart{two} $j$};
%   	  \draw[double] (m_pos) -- (mm_pos);
%       \draw[double] (mm_dir) -- (m_dir);
%     \end{tikzpicture}
%     };
% 	\node at ($(1.east)!.5!(2.west)$) {=};
%     \end{tikzpicture}
% 	\end{equation}
% 	and
% 	\begin{equation} \label{eqn.resp_dupl}
%     \begin{tikzpicture}
%     	\node (1) {
%     \begin{tikzpicture}[polybox, tos]
%       	\node[poly, dom, "$m$" left] (m) {\nodepart{two} $j$};
%       	\node[poly, right= of m.south, yshift=-1ex, "$\car{c}$" below] (c) {\nodepart{two} $i$};
%       	\node[poly, above=of c, "$m$" above] (mm) {};
%       	\node[poly, cod, right= of c.south, yshift=-1ex, "$\car{c}$" right] (cc) {$f$ \nodepart{two} $i$};
%       	\node[poly, cod, above=of DD, "$\car{c}$" right] (ccc) {};
%       	\node[poly, cod, above=of ccc, "$m$" right] (mmm) {};
%     %
%     	\draw (m_pos) to[first] node[below] {$\lambda_1$} (c_pos);
%     	\draw (c_dir) to[climb] node[right] {$\lambda_2$} (mm_pos);
%     	\draw (mm_dir) to[last] node[above left] {$\lambda^\sharp$} (m_dir);
%     	\draw[double] (c_pos) to[first] (cc_pos);
%     	\draw (cc_dir) to[climb] node[right] {$\cod$} (ccc_pos);
%     	\draw (ccc_dir) to[last] node[above, sloped] {$\comp$}  (c_dir);
%     	\draw[double] (mm_pos) to[first] (mmm_pos);
%     	\draw[double] (mmm_dir) to[last] (mm_dir);
% 	\end{tikzpicture}
% 	};
%     	\node[right=1.8 of 1] (2) {
%     \begin{tikzpicture}[polybox, tos]
%       	\node[poly, dom, "$m$" left] (m) {\nodepart{two} $j$};
%       	\node[poly, right= of m.south, yshift=-1ex, "$\car{c}$" below] (c) {$f$ \nodepart{two} $i$};
%       	\node[poly, above=of c, "$m$" above] (mm) {};
%       	\node[poly, cod, right= of c.south, yshift=-1ex, "$\car{c}$" right] (cc) {$f$ \nodepart{two} $i$};
%       	\node[poly, cod, above=of DD, "$\car{c}$" right] (ccc) {};
%       	\node[poly, cod, above=of ccc, "$m$" right] (mmm) {};
%     %
%     	\draw (m_pos) to[first] node[below] {$\lambda_1$} (c_pos);
%     	\draw (c_dir) to[climb] node[right] {$\lambda_2$} (mm_pos);
%     	\draw (mm_dir) to[last] node[above left] {$\lambda^\sharp$} (m_dir);
%     	\draw[double] (c_pos) to[first] (cc_pos);
%     	\draw[double] (cc_dir) to[last] (c_dir);
%     	\draw (mm_pos) to[first] node[below] {$\lambda_1$} (ccc_pos);
%     	\draw (ccc_dir) to[climb] node[right] {$\lambda_2$} (mmm_pos);
%     	\draw (mmm_dir) to[last] node[above left] {$\lambda^\sharp$} (mm_dir);
% 	\end{tikzpicture}    	};
%     	\node at ($(1.east)!.5!(2.west)$) {=};
%     \end{tikzpicture}
%     \end{equation}
    
%     We give the functor $L_m \colon \cat{C} \to \poly$ corresponding to $m$.
%     To each object $i \in \Ob(\cat{C}) = \car{c}(\1)$, we assign
%     \[
%         L_m(i) := \sum_{\substack{j \in m(\1), \\ \lambda_1(j) = i}} \yon^{m[j]}.
%     \]
%     This is the pullback in the diagram
%     \[
%     \begin{tikzcd}
%         L_m(i) \ar[r] \ar[d, "\text{cart}"'] & \yon^{\car{c}[i]} \tri m \ar[d, "\text{cart}"] \\
%         m \ar[r] & \car{c} \tri m \ar[ul, phantom, very near end, "\lrcorner"]
%     \end{tikzcd}
%     \]
%     where the map $\yon^{\car{c}[i]} \tri m \to \car{c} \tri m$ is the cartesian map $\yon^{\car{c}[i]} \to \car{c}$ associated to the position $i$ composed with $m$; see \cref{prop.comp_pres_cart,prop.pullback_cartesian}.
    
%     Then for each outgoing morphism $f \in \car{c}[i]$, we give a map of polynomials $L_m(f) \colon L_m(i) \to L_m(\cod(f))$.
%     On positions, $L_m(f)$ sends each $j \in m(\1)$ satisfying $\lambda_1(j) = i$ to $\lambda_2(f) \in m(\1)$, which by \eqref{eqn.resp_dupl} satisfies $\lambda_1(\lambda_2(f)) = \cod(f)$ and is thus indeed a position of $L_m(\cod(f))$.
%     On directions, $L_m(f)$ sends each $q \in L_m(\cod(f))[\lambda_2(f)] = m[\lambda_2(f)]$ to $\lambda^\sharp(q) \in m[j] = L_m(i)[j]$.
    
%     It is routine to check that \eqref{eqn.resp_eraser} implies that $L_m$ preserves identities, while \eqref{eqn.resp_dupl} implies that $L_m$ preserves composition.
    
%     Conversely, it is clear that we can recover the left $\com{C}$-comodule $m_L$ equipped with $\lambda \colon m_L \to c \tri m_L$ to which a functor $L \colon \cat{C} \to \poly$ corresponds as follows.
%     We can write
%     \[
%         m_L := \sum_{i \in \cat{C}} L(i).
%     \]
%     Then $\lambda_1$ sends each $j \in m_L(\1)$ to the unique $i \in \cat{C}$ for which $j \in L(i)(\1)$.
%     Meanwhile, by our construction above, $\lambda_2$ and $\lambda^\sharp$ can be directly recovered from the behavior of $L$ on morphisms in $\cat{C}$.
%     Similarly, \eqref{eqn.resp_eraser} and \eqref{eqn.resp_dupl} follow from the functoriality of $F$.
    
%     Suppose we are given a map of left $\com{C}$-comodules $\varphi \colon m \to m'$ satisfying the commutative diagram
%     \[
%     \begin{tikzcd}
%       m \ar[r, "\lambda"] \ar[d, "\varphi"'] & \car{c} \tri m \ar[d, "\car{c} \tri \varphi"] \\
%       m' \ar[r, "\lambda'"'] & \car{c} \tri m'
%     \end{tikzcd}
%     \]
%     We will give a natural transformation $L_\varphi \colon L_m \to L_{m'}$ by giving a component morphism of polynomials $(L_\varphi)_i \colon L_m(i) \to L_{m'}(i)$ for each object $i$ in $\cat{C}$, then verifying naturality.
    
%     We construct the following diagram, where the top and bottom squares are pullbacks:
%     \[
%     \begin{tikzcd}[sep=5pt]
%         L_m(i) \ar[rr] \ar[dd, dashed, "(L_\varphi)_i"'] \ar[dr] & & \yon^{\car{c}[i]} \tri m \ar[dd] \ar[dr] \\
%         & m \ar[rr, crossing over] & & \car{c} \tri m \ar[dd] \\
%         L_{m'}(i) \ar[rr] \ar[dr] & & \yon^{\car{c}[i]} \tri m' \ar[dr] \\
%         & m' \ar[from=uu, crossing over] \ar[rr] & & \car{c} \tri m'
%     \end{tikzcd}
%     \]
%     The component $(L_\varphi)_i$ is given by the induced dashed arrow.
%     The naturality will be proven in \cref{exc.natural_poly_module}.
    
%     Conversely, given functors $L, L' \colon \cat{C} \to \poly$ and a natural transformation $\alpha \colon L \to L'$, we can use the fact that $m_L \cong \sum_{i \in \cat{C}} L(i)$ and the universal property of coproducts to extend the maps $L(i) \To{\alpha_i} L'(i) \to m_{L'}$ over all $i \in \cat{C}$ to a map $\varphi_{\alpha} \colon m_L \to m_{L'}$
\end{proof}


\begin{corollary}\label{cor.tensored}
For any categories $\cat{C}_1, \cat{C}_2$, and $\cat{D}$, the functor
\[
    \bimod{\cat{C}_1 \otimes \cat{C}_2}{\cat{D}} \to \smcat(\cat{C}_1, \bimod{\cat{C}_2}{\cat{D}})
\]
is an equivalence.
\end{corollary}
\begin{proof}
** $\cat{C}_1 \otimes \cat{C}_2$ is the usual product of categories **
\end{proof}


\begin{corollary}
Let $\com{C}$ be a comonoid. The category of left $\com{C}$ comodules is equivalent to the category of functors $\cat{C}\to\poly$.
\end{corollary}
\begin{proof}
Use \cref{thm.pra_tensored_cat} with $\cat{D} = \yon$ and the equivalence $\bimod{\yon}{\yon} \cong \poly$.
\end{proof}



\begin{proposition}
The monoidal operation $+$ is a coproduct in $\bimod{}{}$. That is, for any categories $\cat{C}, \cat{D}, \cat{E}$ there is an equivalence of categories
\[
\bimod{\cat{C} + \cat{D}}{\cat{E}} \cong \bimod{\cat{C}}{\cat{E}} \times \bimod{\cat{D}}{\cat{E}}
\]
\end{proposition}
\begin{proof}
This follows from \cref{cor.tensored}:
\begin{align*}
    \bimod{\cat{C} + \cat{D}}{\cat{E}} & \cong
    \smcat(\cat{C} + \cat{D}, \bimod{\yon}{\cat{E}}) \\ & \cong
    \smcat(\cat{C}, \bimod{\yon}{\cat{E}}) \times \smcat(\cat{D}, \bimod{\yon}{\cat{E}}) \\ & \cong
    \bimod{\cat{C}}{\cat{E}} \times \bimod{\cat{D}}{\cat{E}}
\qedhere
\end{align*}
\end{proof}

\begin{proposition}
If $\car{c}\bimodfrom[m_1]\car{d}$ and $\car{c}\bimodfrom[m_2]\car{d}$ are bicomodules, then so are
\[
\car{c}\bimodfrom[m_1+m_2]\car{d}
\qqand
\car{c}\bimodfrom[m_1\times_{\car{c}(\1)}m_2]\car{d}
\]
\end{proposition}

\begin{proposition}
If $\car{c}_1\bimodfrom[m_1]\car{d}_1$ and $\car{c}_2\bimodfrom[m_2]\car{d}_2$ are bicomodules, then so are
\[
  \car{c}_1+\car{c}_2\bimodfrom[m_1+m_2]\car{d}_1+\car{d}_2
  \qqand
  \car{c}_1\otimes\car{c}_2\bimodfrom[m_1\otimes m_2]\car{d}_1\otimes\car{d}_2
\]
\end{proposition}

%-------- Section --------%
\section{Discussion and open questions}\label{sec.discussion_open_qs}

In this section, we lay out some questions that whose answers may or may not be known, but which were not known to us at the time of writing. They vary from concrete to open-ended, they are not organized in any particular way, and are in no sense complete. Still we hope they may be useful to some readers.

\begin{enumerate}
  \item What can you say about comonoids in the category of all functors $\smset\to\smset$, e.g. ones that aren't polynomial.
  \item What can you say about the internal logic for the topos $[\cofree{p},\smset]$ of dynamical systems with interface $p$, in terms of $p$?
  \item How does the logic of the topos $\cofree{p}$ help us talk about issues that might be useful in studying dynamical systems?
  \item Morphisms $p\to q$ in $\poly$ give rise to left adjoints $\cofree{p}\to\cofree{q}$ that preserve connected limits. These are not geometric morphisms in general; in some sense they are worse and in some sense they are better. They are worse in that they do not preserve the terminal object, but they are better in that they preserve every connected limit not just finite ones. How do these left adjoints translate statements from the internal language of $p$ to that of $q$?
  \item Consider the $\times$-monoids and $\otimes$-monoids in three categories: $\poly$, $\smcat^\sharp$, and $\bimod{}{}$. Find examples of these comonoids, and perhaps characterize them or create a theory of them.
  \item Is there a functor $\poly$ has pullbacks, so one can consider the bicategory of spans in $\poly$. Is there a functor from that to $\bimod{}{}$ that sends $p\mapsto\cofree{p}$?
  \item Databases are static things, whereas dynamical systems are dynamic; yet we see them both in terms of $\poly$. How do they interact? Can a dynamical system read from or write to a database in any sense?
  \item Can we do database aggregation in a nice dynamic way?
  \item In the theory of polynomial functors, sums of representable functors $\smset\to\smset$, what happens if we replace sets with homotopy types: how much goes through? Is anything improved?
  \item Are there any functors $\smset\to\smset$ that aren't polynomial, but which admit a comonoid structure with respect to composition $(\yon,\tri)$?
  \item Characterize the monads in poly? They're generalizations of one-object operads (which are the Cartesian ones), but how can we think about them?
  \item Describe the limits that exist in $\smcat^\sharp$ combinatorially.
  \item Since the forgetful functor $U\colon\smcat^\sharp\to\poly$ is faithful, it reflects monomorphisms: if $f\colon\cat{C}\cof\cat{D}$ is a cofunctor whose underlying map on carriers is monic, then it is monic. Are all monomorphisms in $\smcat^\sharp$ of this form?
  \item Are there polynomials $p$ such that one use something like G\"odel numbers to encode logical propositions from the topos $[\tr_p,\smset]$ into a ``language'' that $p$-dynamical systems can ``work with''?
\end{enumerate}


%-------- Section --------%
\section{Exercise solutions}
\Closesolutionfile{solutions}
{\footnotesize
\input{solution-file9}}

\end{document}