% !TeX root = P2-Comonoids.tex
\documentclass[Book-Poly]{subfiles}

\begin{document}
%

\setcounter{chapter}{4}%Just finished 4.

\part{A different category of categories}\label{part.comon}

\Opensolutionfile{solutions}[solution-file5]

%------------ Chapter ------------%
\chapter{The composition product}\label{ch.comon.comp}


% In this chapter we will discuss a monoidal structure on $\poly$ that is quite easy from the mathematical point of view---it is simply composition---but which is again remarkable both in terms of its semantics and the phenomena that emerge mathematically, as we will see in later chapters. 

% In particular, we will see that the comonoids for the composition monoidal structure on $\poly$ are precisely categories. However, the morphisms are different---they are often called \emph{cofunctors}---and so we get a second category $\smcat^\sharp$ of categories and cofunctors. But the core groupoids of each---the groupoid of small categories and all functor isomorphisms between them, as well as the groupoid of small categories and all cofunctor isomorphisms between them---are isomorphic as groupoids. In other words, the following slogan is justified:
% \slogan{Polynomial comonads are precisely categories.}

% Cofunctors are not too familiar, but we will explain how to think of them in a variety of ways. We will see that whereas a functor $\cat{C}\to\cat{D}$ gives a kind of ``picture'' of $\cat{C}$ inside $\cat{D}$, a cofunctor $\cat{C}\cof\cat{D}$ gives a kind of $\cat{D}$-shaped ``crystallization'' of $\cat{C}$, one that is intuitively more geometric, more like creating neighborhoods. We will see in \cref{chapter.bimod} that there is another kind of morphism between comonoids, namely the bicomodules, that are perhaps more familiar: they are the so-called \emph{parametric right adjoints}, or in perhaps more friendly terms, \emph{data migration functors} between copresheaf categories.

% The plan for this part is to first introduce what is perhaps the most interesting monoidal structure on $\poly$, namely the composition product; we do so in this chapter. We'll give a bunch of examples and ways to think about it in terms that relate to dynamical systems and our work so far. Then in \cref{sec.comonoids_in_poly} we'll discuss comonoids in $\poly$ and explain why they are categories in down-to-earth, set-theoretic terms. We will also discuss the morphisms between them.

% Finally in \cref{sec.cofree} we will discuss the cofree comonoid construction that takes any polynomial and returns a category. We will show how it relates to decision trees, as one may see in combinatorial game theory.

%%%%% ** old preamble above




We have seen that the category $\poly$ of polynomial functors has quite a bit of well-interoperating mathematical structure. Further, it is an expressive way to talk about dynamical systems that can change their interfaces and wiring patterns based on their internal states.

But we touched upon one thing---what in some sense is the most interesting part of the story---only briefly. That thing is quite simple to state, and yet has profound consequences. Namely, polynomials can be composed:
\[
\yon^\2\circ(\yon+\1)=(\yon+\1)^\2\iso\yon^\2+\2\yon+\1.
\]
What could be simpler?

It turns out that this operation, which we'll see soon is a monoidal product, has a lot to do with time.
There is a strong sense---made precise in \cref{prop.poly_closed_comp}---in which the polynomial $p\circ q$ represents ``starting at a position $i$ in $p$, choosing a direction in $p[i]$, landing at a position $j$ in $q$, choosing a direction in $q[j]$, and then landing... somewhere.''
This is exactly what we need to run through multiple steps of a dynamical system, the very thing we didn't know how to do in \cref{ex.do_nothing}.
We'll continue that story in \cref{subsec.comon.comp.def.dyn_sys}.

The composition product has many surprises up its sleeve, as we'll see in the following chapters.
We've given you a glimpse of some of them already in \cref{sec.poly.intro.math_theory}.
We won't amass all the rest here; instead, we'll take you through the story step by step.
But as a preview, $\circ$ will get us into decision trees, databases, and more dynamics, as well as the interactions between these.

%-------- Section --------%
\section{Defining the composition product}\label{sec.comon.comp.def}
We begin with the definition of the composition product in terms of polynomials as functors.

\subsection{Composite functors}\label{subsec.comon.comp.def.functor}

\begin{definition}[Composition product] \label{def.comp}
Given polynomial functors $p, q$, we let $p \circ q$ denote their \emph{composition product}, or their composite as functors.
That is, $p \circ q \colon \smset \to \smset$ sends each set $X$ to the set $p(q(X))$.
\end{definition}

Functor composition gives a monoidal structure on the category $\smset^\smset$ of functors $\smset\to\smset$, but to check that the full subcategory $\poly$ of $\smset^\smset$ inherits this monoidal structure, we need to verify that the composite of two functors in $\poly$ is still a functor in $\poly$.

\begin{proposition}\label{prop.poly_closed_comp}
Suppose $p,q\in\poly$ are polynomial functors $p,q\colon\smset\to\smset$. Then their composite $p\circ q$ is again a polynomial functor, and we have the following isomorphism:
\begin{equation} \label{eqn.composite_formula_circ}
p\circ q\iso\sum_{i\in p(\1)}\prod_{a\in p[i]}\sum_{j\in q(\1)}\prod_{b\in q[j]}\yon.
\end{equation}
\end{proposition}
\begin{proof}
We can rewrite $p$ and $q$ as
\[
p\iso\sum_{i\in p(\1)}\yon^{p[i]}\iso\sum_{i\in p(\1)}\prod_{a\in p[i]}\yon
\qqand
q\iso\sum_{j\in q(\1)}\yon^{q[j]}\iso\sum_{j\in q(\1)}\prod_{b\in q[j]}\yon.
\]
For any set $X$ we have $(p\circ q)(X)=p(q(X))=p(\sum_j\prod_b X)=\sum_i\prod_a\sum_j\prod_bX$, so \eqref{eqn.composite_formula_circ} is indeed the formula for the composite $p \circ q$.
To see this is a polynomial, we use \eqref{eqn.push_prod_sum_set_indep}, which says we can rewrite the $\prod\sum$ in \eqref{eqn.composite_formula_circ} as a $\sum\prod$ to obtain
\begin{align}\label{eqn.composite_formula_sums_first_circ}
  p\circ q\iso
  \scalebox{1.3}{$\displaystyle
  \sum_{i\in p(\1)} \; \sum_{\ol{j}\colon p[i]\to q(\1)}\yon^{\sum_{a\in p[i]}q[\ol{j}(a)]}$}
\end{align}
(written slightly bigger for clarity), which is clearly a polynomial.
\end{proof}

\begin{corollary} \label{cor.comp_monoidal}
The category $\poly$ has a monoidal structure $(\yon,\circ)$, where $\yon$ is the identity functor and $\circ$ is given by composition.
\end{corollary}

Because we may wish to use $\circ$ to denote composition in arbitrary categories, we use a special symbol for polynomial composition, namely
\[
p\tri q\coloneqq p\circ q.
\]
The symbol $\tri$ looks a bit like the composition symbol in that it is an open shape, and when writing quickly by hand, it's okay if it morphs into a $\circ$.
But $\tri$ highlights the asymmetry of composition, in contrast with the other monoidal structures on $\poly$ we've encountered.
Moreover, we'll soon see that $\tri$ is quite evocative in terms of trees.
For each $n\in\nn$, we'll also use $p\tripow{n}$ to denote the $n$-fold composite of $p$, i.e.\ $n$ copies of $p$ all composed with each other.\footnote{When we say ``the $n$-fold composition product of $p$,'' we mean $n$ copies of $p$ all composed with each other; but when we discuss an ``$n$-fold composition product'' in general, we refer to an arbitrary composition product of $n$ polynomials that may or may not all be equal to each other. This will apply to composition products of lenses as well, once we define those.}
In particular, $p\tripow0=\yon$ and $p\tripow1=p$.

We repeat the important formulas from \cref{prop.poly_closed_comp} and its proof in the new notation:
\begin{equation}\label{eqn.composite_formula}
p\tri q\iso\sum_{i\in p(\1)}\prod_{a\in p[i]}\sum_{j\in q(\1)}\prod_{b\in q[j]}\yon.
\end{equation}

\begin{align}\label{eqn.composite_formula_sums_first}
  p\tri q\iso
  \scalebox{1.3}{$\displaystyle
  \sum_{i\in p(\1)} \; \sum_{\ol{j}\colon p[i]\to q(\1)}\yon^{\sum_{a\in p[i]}q[\ol{j}(a)]}$}
\end{align}

% \[
% \begin{tikzpicture}[polybox, baseline=(helper)]
% 	\node[poly] (p) {$a:p[i]$\at$i:p(\1)$};
% 	\node[poly, above=of p] (q) {$b:q[j]$\at$j:q(\1)$};
% 	\coordinate (helper) at ($(p.north)!.5!(q.south)$);
% \end{tikzpicture}
% \quad\cong\quad
% \begin{tikzpicture}[polybox, baseline=(p.east)]
% 	\node[poly] (p) {$(a:p[i], b:q[j(a)]$)\at$(i:p(1), j: p[i]\to q(\1))$};
% \end{tikzpicture}
% \]

\begin{exercise}
Let's consider \eqref{eqn.composite_formula_sums_first} piece by piece, with concrete polynomials $p\coloneqq\yon^\2+\yon^\1$ and $q\coloneqq \yon^\3+\1$.
\begin{enumerate}
	\item What is $\yon^\2\tri q$? 
	\item What is $\yon^\1\tri q$?
	\item What is $(\yon^\2+\yon^\1)\tri q$? This is what $p\tri q$ ``should be.''
	\item How many functions $\ol{j_1}\colon p[1]\to q(\1)$ are there?
	\item For each function $\ol{j_1}$ as above, what is $\sum_{a\in p[1]} q[\ol{j_1}(a)]$?
	\item How many functions $\ol{j_2}\colon p[2]\to q(\1)$ are there?
	\item For each function $\ol{j_2}$ as above, what is $\sum_{a\in p[2]} q[\ol{j_2}(a)]$?
	\item Write out \[\sum_{i\in p(\1)}\;\sum_{\ol{j}\colon p[i]\to q(\1)}\yon^{\sum_{a\in p[i]}q[\ol{j}(a)]}.\]
	Does the result agree with what $p\tri q$ should be?
\qedhere
\end{enumerate}
\begin{solution}
We are given $p\coloneqq\yon^\2+\yon^\1$ and $q\coloneqq \yon^\3+\1$.
\begin{enumerate}
    \item By standard polynomial multiplication, we have that $\yon^\2 \tri q \iso q \times q \iso \yon^\6 + \2\yon^\3 + \1$.
    \item We have that $\yon^\1 \tri q \iso q \iso \yon^\3 + \1$.
    \item Combining the previous parts, we have that $(\yon^\2 + \yon^\1) \tri q \iso q \times q + q \iso \yon^\6 + \3\yon^\3 + \2$.
    \item Since $p[1] \iso \2$ and $q(\1) \iso \2$, there are $2^2 = 4$ functions $p[1] \to q(\1)$.
    \item When $\ol{j_1} \colon p[1] \to q(\1)$ is one of the two possible bijections, we have that
    \[
        \sum_{a \in p[1]} q[\ol{j_1}(a)] \iso q[1] + q[2] \iso \3 + \0 \iso \3.
    \]
    When $\ol{j_1} \colon p[1] \to q(\1)$ sends everything to $1 \in q(\1)$, we have that
    \[
        \sum_{a \in p[1]} q[\ol{j_1}(a)] \iso q[1] + q[1] \iso \3 + \3 \iso \6.
    \]
    Finally, when $\ol{j_1} \colon p[1] \to q(\1)$ sends everything to $2 \in q(\1)$, we have that
    \[
        \sum_{a \in p[1]} q[\ol{j_1}(a)] \iso q[2] + q[2] \iso \0 + \0 \iso \0.
    \]
    \item Since $p[2] \iso \1$ and $q(\1) \iso \2$, there are $2^1 = 2$ functions $p[2] \to q(\1)$.
    \item When $j_2 \colon p[2] \to q(\1)$ maps to $1 \in q(\1)$, we have that $\sum_{a \in p[2]} q[\ol{j_2}(a)] \iso q[1] \iso \3$, and when $\ol{j_2} \colon p[2] \to q(\1)$ maps to $2 \in q(\1)$, we have that $\sum_{a \in p[2]} q[\ol{j_2}(a)] \iso q[2] \iso \0$.
    \item From the previous parts, we have that
    \[
        \sum_{i\in p(\1)}\;\sum_{\ol{j}\colon p[i]\to q(\1)}\yon^{\sum_{a\in p[i]}q[j_i(a)]} \iso (\2\yon^\3 + \yon^\6 + \yon^\0) + (\yon^\3 + \yon^\0) \iso \yon^\6 + \3\yon^\3 + \2,
    \]
    which agrees with what $p \tri q$ should be.
\end{enumerate}
\end{solution}
\end{exercise}

\begin{exercise}\label{exc.composites_of_specials}
\begin{enumerate}
	\item If $p$ and $q$ are representable, show that $p\tri q$ is too. Give a formula for it.
	\item If $p$ and $q$ are linear, show that $p\tri q$ is too. Give a formula for it.
	\item If $p$ and $q$ are constant, show that $p\tri q$ is too. Give a formula for it.
\qedhere
\end{enumerate}
\begin{solution}
\begin{enumerate}
	\item Given representable polynomials $p \coloneqq \yon^A$ and $q \coloneqq \yon^B$, we have that $p \tri q \iso \left(\yon^B\right)^A \iso \yon^{AB}$, which is also representable.
	\item Given linear polynomials $p \coloneqq A\yon$ and $q \coloneqq B\yon$, we have that $p \tri q \iso A(B\yon) \iso AB\yon$, which is also linear.
	\item Given constant polynomials $p \coloneqq A$ and $q \coloneqq B$, we have that $p \tri q \iso A$, which is also constant (see also \cref{exc.composing_with_constants}).
\end{enumerate}
\end{solution}
\end{exercise}

\begin{exercise}
Recall the closure operation $\ihom{-,-}\colon\poly\op\times\poly\to\poly$ for $\otimes$ from \eqref{eqn.par_hom}.
Show that for all $A\in\smset$ and $q\in\poly$, there is an isomorphism
\[
    \yon^A\tri q\iso\ihom{A\yon,q}.
\]
\begin{solution}
Given $A\in\smset$ and $q\in\poly$, we have
\begin{align*}
    \yon^A\tri q    &\iso
	\sum_{\ol{j}\colon A\to q(\1)}\yon^{\sum_{a\in A}q[\ol{j}(a)]}
	\tag*{\eqref{eqn.composite_formula_sums_first}} \\ &\iso
	\sum_{\varphi\colon A\yon\to q}\yon^{\sum_{a\in A}q[\varphi_\1(a)]}   \\&\iso
	\ihom{A\yon,q},
	\tag*{\eqref{eqn.par_hom_sum}}
\end{align*}
for a lens $\varphi\colon A\yon\to q$ has an on-positions function $A\to q(\1)$ and uniquely determined on-directions functions.
\end{solution}
\end{exercise}

We know how $\tri$ acts on the objects in $\poly$, but what does it do to the morphisms between them?
For any pair of natural transformations $f\colon p\to p'$ and $g\colon q\to q'$ between polynomial functors, their composition product $f\tri g\colon p\tri q\to p'\tri q'$ is given by \emph{horizontal composition}.

\begin{definition}[Horizontal composition of natural transformations]\label{def.horiz_comp_nat_trans}
Let $f\colon p\to p'$ and $g\colon q\to q'$ be two natural transformations between (polynomial) functors $p,p',q,q'\colon\smset\to\smset$.
Then the \emph{horizontal composite} of $f$ and $g$, denoted $f\tri g$, is the natural transformation $p\tri q\to p'\tri q'$ whose $X$-component for each $X\in\smset$ is the function
\begin{equation} \label{eqn.horiz_comp_nat_trans_comp}
    p(q(X)) \To{f_{q(X)}} p'(q(X)) \To{p'(g_X)} p'(q'(X))
\end{equation}
obtained by composing the $q(X)$-component of $f$ with the functor $p'$ applied to the $X$-component of $g$.
\end{definition}

\begin{exercise}
Show that we could have replaced the composite function \eqref{eqn.horiz_comp_nat_trans_comp} in \cref{def.horiz_comp_nat_trans} with the function
\begin{equation} \label{eqn.horiz_comp_nat_trans_comp2}
    p(q(X)) \To{p(g_X)} p(q'(X)) \To{f_{q'(X)}} p'(q'(X))
\end{equation}
obtained by composing $p$ applied to the $X$-component of $g$ with the $q'(X)$-component of $f$, without altering the definition.
\begin{solution}
We wish to show that \eqref{eqn.horiz_comp_nat_trans_comp2} could replace \eqref{eqn.horiz_comp_nat_trans_comp} in \cref{def.horiz_comp_nat_trans}.
We claim that \eqref{eqn.horiz_comp_nat_trans_comp} and \eqref{eqn.horiz_comp_nat_trans_comp2} are in fact the same function; that is, that the following square commutes:
\[
\begin{tikzcd}
    p(q(X)) \ar[r, "f_{q(X)}"]\ar[d, "p(g_X)"'] & p'(q(X)) \ar[d, "p'(g_X)"] \\
    p(q'(X)) \ar[r, "f_{q'(X)}"'] & p'(q'(X))
\end{tikzcd}
\]
Indeed it does, by the naturality of $f$.
\end{solution}
\end{exercise}

\begin{remark}
There are two very different notions of lens composition floating around, so we'll try to mitigate confusion by standardizing terminology here.
We'll reserve the term \emph{composite lens} for lenses $h\then j\colon r\to t$ obtained by composing a lens $h\colon r\to s$ with a lens $j\colon s\to t$, according to the composition rule of the category $\poly$.
This corresponds to \emph{vertical composition} of natural transformations.
This is also the kind of composition we will mean whenever we use the verb ``\emph{compose},'' if the objects of that verb are lenses.

Meanwhile, we'll use the term \emph{composition product (of lenses)} for lenses $f\tri g\colon p\tri q\to p'\tri q'$ obtained by applying the monoidal product functor $\tri\colon\poly\times\poly\to\poly$ on the lenses $f\colon p\to p'$ and $g\colon q\to q'$.
This corresponds to \emph{horizontal composition} of natural transformations.
In this case, we'll use the verb phrase ``\emph{taking the monoidal product}.''

On the other hand, we'll use the terms ``composite'' and ``composition product'' interchangeably to refer to polynomials $p\tri q$, obtained by composing $p,q\in\poly$ as functors or, equivalently, applying the monoidal product functor $\tri$ on them---as there is no risk of confusion here.%
\footnote{Some authors refer to $\tri$ as the \emph{substitution} product, rather than the composition product. We elected to use the composition product terminology because it provides a good noun form ``the composite'' for $p\tri q$, whereas ``the substitute'' is somehow strange in English.}

This is another reason we tend to avoid the symbol $\circ$, preferring to use $\then$ for vertical composition and $\tri$ for horizontal composition.
Of course, if you're ever confused, you can always check whether the codomain of the first lens matches up with the domain of the second.
If they don't, we must be taking their monoidal product.
\end{remark}

The composition product of polynomials and lenses will be extremely important in the story that follows.
However, we only sometimes think of it as the composition of functors and the horizontal composition of natural transformations; more often we think of it as certain operations on arenas or corolla forests.

\subsection{Composite arenas}\label{subsec.comon.comp.def.arena}

Let us interpret our formula \eqref{eqn.composite_formula_sums_first} for the composite of two polynomials in terms of what it says about the positions and directions of the corresponding arenas.
The position-set of $p \tri q$ is
\begin{equation} \label{eqn.comp_pos}
    (p \tri q)(\1) \iso \sum_{i \in p(\1)} \; \sum_{\ol{j} \colon p[i] \to q(1)} \1 \iso \sum_{i \in p(\1)} \smset(p[i], q(\1)).
\end{equation}
In other words, specifying a position of $p \tri q$ amounts to first specifying a $p$-position $i$, then specifying a function $\ol{j} \colon p[i] \to q(\1)$, i.e.\ a $q$-position $\ol{j}(a)$ for each $p[i]$-direction $a$.

Given such a position $(i, \ol{j})$ of $p \tri q$, the direction-set of $p \tri q$ at $(i, \ol{j})$ is
\begin{equation} \label{eqn.comp_dir}
    (p \tri q)[(i, \ol{j})] \iso \sum_{a \in p[i]} q[\ol{j}(a)].
\end{equation}
So a direction of $p \tri q$ at $(i, \ol{j})$ consists of a $p[i]$-direction $a$ and a $q[\ol{j}(a)]$-direction.

While this description completely characterizes $p \tri q$ as an arena, it may be a bit tricky to wrap your head around.
Here is an alternative perspective that can help us get a better intuition for what's going on with composite arenas.

Back in \cref{subsec.poly.func_nat.repr_sum.dep_sum_prod_set}, we saw how to write the instructions for choosing an element of a dependent sum or product of sets.
For instance, given a polynomial $p$ and a set $X$, the instructions for choosing an element of
\[
    p\tri X=p(X)\iso\sum_{i\in p(\1)}\prod_{a\in p[i]}X
\]
would be written as follows.
\begin{quote}
To choose an element of $p(X)$: 
\begin{enumerate}
    \item choose an element $i\in p(\1)$;
    \item for each element $a\in p[i]$:
    \begin{enumerate}[label*=\arabic*.]
        \item choose an element of $X$.
    \end{enumerate}
\end{enumerate}
\end{quote}
But say we hadn't picked a set $X$ yet; in fact, say we might replace $X$ with a general polynomial instead.
We'll replace ``an element of $X$'' with a placeholder---the words ``a future''---that indicates that we don't yet know what will go there.
Furthermore, to highlight that these instructions are associated with some polynomial $p$, we will use our familiar arena terminology of positions and directions.
\begin{quote}
The instructions associated with a polynomial $p$ are:
\begin{enumerate}
    \item choose a $p$-position $i$;
    \item for each $p[i]$-direction $a$:
    \begin{enumerate}[label*=\arabic*.]
        \item choose a future.
    \end{enumerate}
\end{enumerate}
\end{quote}

If we think of polynomials in terms of their instructions, then \eqref{eqn.composite_formula} tells us that the composition product simply nests one set of instructions within another, as follows.
\begin{quote}
The instructions associated with a polynomial $p\tri q$ are:
\begin{enumerate}
    \item choose a $p$-position $i$;
    \item for each $p[i]$-direction $a$:
    \begin{enumerate}[label*=\arabic*.]
        \item choose a $q$-position $j$;
        \item for each $q[j]$-direction $b$:
        \begin{enumerate}[label*=\arabic*.]
            \item choose a future.
        \end{enumerate}
    \end{enumerate}
\end{enumerate}
\end{quote}
Similarly, we could write down the instructions associated with any $n$-fold composite by nesting even further.
We might think of such instructions as specifying some sort of length-$n$ \emph{strategy}, in the sense of game theory, for picking positions given any directions---except that the opponent is somehow abstract, having no positions of its own.

When we rewrite \eqref{eqn.composite_formula} \eqref{eqn.composite_formula_sums_first}, we are collapsing the instructions down into the following, highlighting the positions and directions of $p\tri q$.
\begin{quote}
The instructions associated with a polynomial $p\tri q$ are:
\begin{enumerate}
    \item choose a $p$-position $i$ and, for each $p[i]$-direction $a$, a $q$-position $\ol{j}_i(a)$;
    \item for each $p[i]$-direction $a$ and each $q[\ol{j}_i(a)]$-direction $b$:
    \begin{enumerate}[label*=\arabic*.]
        \item choose a future.
    \end{enumerate}
\end{enumerate}
\end{quote}
We will see in \cref{subsec.comon.comp.def.corolla} that these instructions have a very natural interpretation when we translate from arenas to corolla forests.

\begin{exercise}
\begin{enumerate}
	\item Let $p$ be an arbitrary polynomial. Write out the (uncollapsed) instructions associated with $p\tripow3=p\tri p\tri p$.
	\item Write out the (uncollapsed) instructions for choosing an element of $p\tri p\tri\1$, but where you would normally write ``choose an element of $\1$,'' just write ``done.'' \qedhere
\end{enumerate}
\begin{solution}
\begin{longenum}
    \item The instructions associated with a polynomial $p\tri p\tri p$ are:
    \begin{enumerate}
        \item choose a $p$-position $i$;
        \item for each $p[i]$-direction $a$:
        \begin{enumerate}[label*=\arabic*.]
            \item choose a $p$-position $i'$;
            \item for each $p[i']$-direction $a'$:
            \begin{enumerate}[label*=\arabic*.]
                \item choose a $p$-position $i''$;
                \item for each $p[i'']$-direction $a''$:
                \begin{enumerate}[label*=\arabic*.]
                    \item choose a future.
                \end{enumerate}
            \end{enumerate}
        \end{enumerate}
    \end{enumerate}
    \item To choose an element of $p\tri p\tri\1$:
    \begin{enumerate}
        \item choose a $p$-position $i$;
        \item for each $p[i]$-direction $a$:
        \begin{enumerate}[label*=\arabic*.]
            \item choose a $p$-position $i'$;
            \item for each $p[i']$-direction $a'$:
            \begin{enumerate}[label*=\arabic*.]
                \item done.
            \end{enumerate}
        \end{enumerate}
    \end{enumerate}
\end{longenum}

\end{solution}
\end{exercise}

But how does the composition product act on lenses between arenas?
Given lenses $f\colon p\to p'$ and $g\colon q\to q'$, we can translate them to natural transformations, take their horizontal composite, then translate this back to a lens.
The following exercise guides us through this process.

\begin{exercise}[The composition product of lenses] \label{exc.comp_prod_lens}
Fix lenses $f\colon p\to p'$ and $g\colon q\to q'$.
We seek to characterize their composition product $f\tri g\colon p\tri q\to p'\tri q'$.
\begin{enumerate}
    \item\label{exc.comp_prod_lens.1} Use \cref{prop.morph_arena_to_func} to compute the $q(X)$-component of $f$ as a natural transformation.
    \item\label{exc.comp_prod_lens.2} Use \cref{prop.poly_on_functions,prop.morph_arena_to_func} to compute $p'$ applied to the $X$-component of $g$ as a natural transformation.
    \item\label{exc.comp_prod_lens.3} Combine \cref{exc.comp_prod_lens.1} and \cref{exc.comp_prod_lens.2} using \cref{def.horiz_comp_nat_trans} to compute the horizontal composite $f\tri g$ of $f$ and $g$ as natural transformations.
    \item Use \cref{cor.morph_func_to_arena} to translate the natural transformation $f\tri g$ obtained in \cref{exc.comp_prod_lens.3} to a lens between arenas $p\tri q\to p'\tri q'$.
    Verify that for each $(i,\ol{j}_i)$ in $(p\tri q)(\1)$ (see \eqref{eqn.comp_pos}), its on-positions function sends
    \begin{equation} \label{eqn.comp_lens_pos}
        (i,\ol{j}_i)\Mapsto{(f\:\tri\:g)_\1}\left(f_\1(i), f^\sharp_i\then\ol{j}_i\then g_\1\right);
    \end{equation}
    while for each $(a',b')$ in $(p'\tri q')[(f_\1(i), f^\sharp_i\then\ol{j}_i\then g_\1)]$ (see \eqref{eqn.comp_dir}), its on-directions function sends
    \begin{equation} \label{eqn.comp_lens_dir}
        (a',b')\Mapsto{(f\:\tri\:g)^\sharp_{(i,\ol{j}_i)}}\left(f^\sharp_i(a'), g^\sharp_{\ol{j}_i(f^\sharp_i(a'))}(b')\right).
    \end{equation}
    \qedhere
\end{enumerate}
\begin{solution}
We have lenses $f\colon p\to p'$ and $g\colon q\to q'$.
\begin{enumerate}
    \item By \cref{prop.morph_arena_to_func}, the $q(X)$-component of $f$ is a function $f_{q(X)}\colon p(q(X))\to p'(q(X))$ that sends every $(i,h)$ with $i\in p(\1)$ and $h\colon p[i]\to q(X)$ to $(f_\1(i),f^\sharp_i\then h)$.
    We can think of the function $h\colon p[i]\to q(X)$ equivalently as a function $\ol{j}_i\colon p[i]\to q(\1)$ and, for each $a\in p[i]$, a function $h_a\colon q[\ol{j}_i(a)]\to X$.
    So $f_{q(X)}\colon (p\tri q)(X)\to (p'\tri q)(X)$ sends \[(i,\ol{j}_i,(h_a)_{a\in p[i]})\mapsto\left(f_\1(i),f^\sharp_i\then\ol{j}_i,\left(h_{f^\sharp_i(a')}\right)_{a'\in p'[f_\1(i)]}\right).\]
    
    \item By \cref{prop.morph_arena_to_func}, the $X$-component of $g$ is a function $g_X\colon q(X)\to q'(X)$ that sends every $(j,k)$ with $j\in q(\1)$ and $k\colon q[j]\to X$ to $(g_\1(j),g^\sharp_j\then k)$ in $q'(X)$.
    Then by \cref{prop.poly_on_functions}, applying $p'$ to this $X$-component yields a function $p'(q(X))\to p'(q'(X))$ that sends every $(i',\ol{j'}_{i'},(h'_{a'})_{a'\in p'[i']})$ with $i'\in p'(\1)$ as well as $\ol{j'}_{i'}\colon p'[i']\to q(\1)$ and $h'_{a'}\colon q[\ol{j'}_{i'}(a')]\to X$ to \[\left(i',\ol{j'}_{i'}\then g_\1,\left(g^\sharp_{\ol{j'}_{i'}(a')}\then h'_{a'}\right)_{a'\in p'[i']}\right).\]
    
    \item By \cref{def.horiz_comp_nat_trans}, the horizontal composite of $f$ and $g$ is the natural transformation $f\tri g\colon p\tri p'\to q\tri q'$ whose $X$-component is the composite of the answers to \cref{exc.comp_prod_lens.1} and \cref{exc.comp_prod_lens.2}, sending
    \begin{align*}
        (i,\ol{j}_i,(h_a)_{a\in p[i]})&\mapsto\left(f_\1(i),f^\sharp_i\then\ol{j}_i,\left(h_{f^\sharp_i(a')}\right)_{a'\in p'[f_\1(i)]}\right)\\
        &\mapsto\left(f_\1(i),f^\sharp_i\then\ol{j}_i\then g_\1, \left(g^\sharp_{\ol{j}_{i}(f^\sharp_i(a'))}\then h_{f^\sharp_i(a')}\right)_{a'\in p'[f_\1(i)]}\right).
    \end{align*}
    
    \item We use \cref{cor.morph_func_to_arena} to translate the answer to \cref{exc.comp_prod_lens.3} into a lens $f\tri g\colon p\tri q\to p'\tri q'$, as follows.
    Its on-positions function is the $\1$-component $(f\tri g)_\1$, which sends every $(i,\ol{j}_i)$ with $i\in p(\1)$ and $\ol{j}_i\colon p[i]\to q(\1)$ to
    \[
        (f_\1(i),f^\sharp_i\then\ol{j}_i\then g_\1).
    \]
    Then for each such $(i,\ol{j}_i)$, if we apply the $(p\tri q)[(i,\ol{j}_i)]$-component of $f\tri g$ to the element $(i,\ol{j}_i,(\iota_d)_{a\in p[i]})$, where $\iota_d\colon q[\ol{j}_i(a)]\to(p\tri q)[(i,\ol{j}_i)]\iso\sum_{a\in p[i]}q[\ol{j}_i(a)]$ is the canonical inclusion, then take the last coordinate of the result, we obtain for each $a'\in p'[f_\1(i)]$ the function
    \[
        q'[g_\1(\ol{j}_i(f^\sharp_i(a')))] \To{g^\sharp_{\ol{j}_{i}(f^\sharp_i(a'))}} q[\ol{j}_i(f^\sharp_i(a'))] \To{\iota_{f^\sharp_i(a')}} \sum_{a\in p[i]}q[\ol{j}_i(a)] \iso (p\tri q)[(i,\ol{j}_i)].
    \]
    These can equivalently be thought of as a single function from
    \[
        \sum_{a'\in p'[f_\1(i)]} q'[g_\1(\ol{j}_i(f^\sharp_i(a')))] \iso (p'\tri q')[(f\tri g)_\1(i,\ol{j}_i)]
    \]
    which \cref{cor.morph_func_to_arena} tells us is the on-directions function of $f\tri g$ at $(i,\ol{j}_i)$, that sends every $(a',b')$ with $a'\in p'[f_\1(i)]$ and $b'\in q'[g_\1(\ol{j}_i(f^\sharp_i(a')))]$ to
    \[
        \left(f^\sharp_i(a'), g^\sharp_{\ol{j}_i(f^\sharp_i(a'))}(b')\right).
    \]
\end{enumerate}
\end{solution}
\end{exercise}

So what does \cref{exc.comp_prod_lens} tell us about the behavior of $f\tri g\colon p\tri q\to p'\tri q'$?
By \eqref{eqn.comp_lens_pos}, on positions, $f\tri g$ takes a $p$-position $i$ and sends it to the $p'$-position $f_\1(i)$; then for each direction $a'$ at this position, the associated $q'$-position is obtained by sending $a'$ back to a $p[i]$-direction via $f^\sharp_i$, checking what $q$-position is associated to that $p[i]$-direction via some $\ol{j}_i$, then sending that $q$-position forward again to a $q'$-position via $g_\1$.

Then by \eqref{eqn.comp_lens_pos}, on directions, $f\tri g$ sends a direction of $p'$ back to a direction of $p$ via an on-directions function of $f$, then sends a direction of $q'$ back to a direction of $q$ via an on-directions funtion of $g$.
We'll get a better sense of what's happening when we see this drawn out as corolla forests in \cref{ex.comp_prod_trees}.

\subsection{Composite corolla forests} \label{subsec.comon.comp.def.corolla}

It turns out that the forest of $p\tri q$ is given by gluing $q$-corollas onto the leaves of $p$-corollas in every possible way.
We will demonstrate this using an example.

Let's say $p\coloneqq\yon^\2+\yon$ and $q\coloneqq\yon^\3+\1$, whose corolla forests we draw as follows:
\begin{equation}\label{eqn.pq_misc39}
\begin{tikzpicture}[rounded corners]
	\node (p1) [draw, blue!50!black, "\color{blue!50!black} $p$" above] {
	\begin{tikzpicture}[trees, sibling distance=2.5mm]
    \node["\tiny 1" below] (1) {$\bullet$} 
      child {}
      child {};
    \node[right=.5 of 1,"\tiny 2" below] (2) {$\bullet$} 
      child {};
  \end{tikzpicture}
  };
%
	\node (p2) [draw, red!75!black, right=2 of p1, "\color{red!75!black} $q$" above] {
	\begin{tikzpicture}[trees, sibling distance=2.5mm]
    \node["\tiny 1" below] (1) {$\bullet$} 
      child {}
      child {}
      child {};
    \node[right=.5 of 1,"\tiny 2" below] (4) {$\bullet$}
    ;
  \end{tikzpicture}
  };
\end{tikzpicture}
\end{equation}
By \eqref{eqn.comp_pos}, choosing a position of $p \tri q$ amounts to first choosing a $p$-root $i$, then choosing a $q$-root for every $p[i]$-leaf.
So we may depict $(p \tri q)(\1)$ by gluing roots from the corolla forest of $q$ to leaves in the corolla forest of $p$ in every possible way, as follows:
\begin{equation}\label{eqn.comp_pos_forest}
\begin{tikzpicture}[rounded corners]
	\node (p1) [draw, "``$(${\color{blue!50!black} $p$}$\:\tri\:${\color{red!75!black}$q$}$)(\1)$''" above] {
	\begin{tikzpicture}[trees,
		level 1/.style={sibling distance=8mm},
	  blue!50!black]
    \node[blue!50!black, "\tiny 1" below] (1) {$\bullet$} 
      child[blue!50!black] {node[red!75!black, "\color{red!75!black} \tiny 1" above] {$\bullet$}}
      child[blue!50!black] {node[red!75!black, "\color{red!75!black} \tiny 1" above] {$\bullet$}};
%
    \node[blue!50!black, right=1.5 of 1, "\tiny 1" below] (2) {$\bullet$} 
      child[blue!50!black] {node[red!75!black, "\color{red!75!black} \tiny 1" above] {$\bullet$}}
      child[blue!50!black] {node[red!75!black, "\color{red!75!black} \tiny 2" above] {$\bullet$}};
%
    \node[blue!50!black, right=1.5 of 2, "\tiny 1" below] (3) {$\bullet$} 
      child[blue!50!black] {node[red!75!black, "\color{red!75!black} \tiny 2" above] {$\bullet$}}
      child[blue!50!black] {node[red!75!black, "\color{red!75!black} \tiny 1" above] {$\bullet$}};
%
    \node[blue!50!black, right=1.5 of 3, "\tiny 1" below] (4) {$\bullet$} 
      child[blue!50!black] {node[red!75!black, "\color{red!75!black} \tiny 2" above] {$\bullet$}}
      child[blue!50!black] {node[red!75!black, "\color{red!75!black} \tiny 2" above] {$\bullet$}};
%
    \node[blue!50!black, right=1.2 of 4, "\tiny 2" below] (5) {$\bullet$} 
      child[blue!50!black] {node[red!75!black, "\color{red!75!black} \tiny 1" above] {$\bullet$}};
%
    \node[blue!50!black, right=1 of 5, "\tiny 2" below] (6) {$\bullet$} 
      child[blue!50!black] {node[red!75!black, "\color{red!75!black} \tiny 2" above] {$\bullet$}};
  \end{tikzpicture}
  };
\end{tikzpicture}
\end{equation}
Now fix one of the positions of $p \tri q$ drawn above: a $p$-root $i$ and a $q$-root glued to every $p[i]$-leaf.
By \eqref{eqn.comp_dir}, a direction of $p \tri q$ at that position consists of a $p[i]$-leaf $a$ and a second leaf emanating from the $q$-root that has been glued to $a$.
In other words, in the following picture, where we have glued not just $q$-roots but entire $q$-corollas to leaves in $p$, the directions of $p \tri q$ at the position corresponding to each tree are the rooted paths\footnote{A \emph{rooted path} of a rooted tree is a path up the tree that starts from the root.} of that tree of length $2$ (we omit the labels):
\begin{equation}\label{eqn.prefered_composite}
\begin{tikzpicture}[rounded corners]
	\node (p1) [draw, "``{\color{blue!50!black} $p$}$\:\tri\:${\color{red!75!black}$q$}''" above] {
	\begin{tikzpicture}[trees,
		level 1/.style={sibling distance=8mm},
	  level 2/.style={sibling distance=2.5mm},
	  blue!50!black]
    \node[blue!50!black] (1) {$\bullet$} 
      child {node[red!75!black] {$\bullet$} 
      	child[red!75!black]
				child[red!75!black]
				child[red!75!black]
			}
      child {node[red!75!black] {$\bullet$} 
      	child[red!75!black]
				child[red!75!black]
				child[red!75!black]
			};
%
    \node[blue!50!black, right=1.7 of 1] (2) {$\bullet$} 
      child {node[red!75!black] {$\bullet$} 
      	child[red!75!black]
				child[red!75!black]
				child[red!75!black]
			}
      child {node[red!75!black] {$\bullet$} 
			};
%
    \node[blue!50!black, right=1.5 of 2] (3) {$\bullet$} 
      child {node[red!75!black] {$\bullet$} 
			}
      child {node[red!75!black] {$\bullet$} 
      	child[red!75!black]
				child[red!75!black]
				child[red!75!black]
			};
%
    \node[blue!50!black, right=1.5 of 3] (4) {$\bullet$} 
      child {node[red!75!black] {$\bullet$}
			}
      child {node[red!75!black] {$\bullet$} 
			};
%
    \node[blue!50!black, right=1.2 of 4] (5) {$\bullet$} 
      child {node[red!75!black] {$\bullet$} 
      	child[red!75!black]
				child[red!75!black]
				child[red!75!black]
			};
%
    \node[blue!50!black, right=1 of 5] (6) {$\bullet$} 
      child {node[red!75!black] {$\bullet$} 
			};
  \end{tikzpicture}
  };
\end{tikzpicture}
\end{equation}
Equivalently, we can think of the directions in the picture above as the leaves at the second level of each tree.
So $p \tri q$ has six positions; the first has six directions, the second, third, and fifth have three directions, and the fourth and sixth have no directions.
In total, we can read off that $p\tri q$ is isomorphic to $\yon^\6+\3\yon^\3+\2$.

We put the $p\tri q$ in scare quotes above \eqref{eqn.prefered_composite} because, to be pedantic, the corolla forest of $p \tri q$ has the two levels smashed together as follows:
\begin{equation}\label{eqn.actual_composite}
\begin{tikzpicture}[rounded corners]
	\node (p1) [draw, "$p\tri q$" above] {
	\begin{tikzpicture}[trees, sibling distance=2.5mm]
    \node (1) {$\bullet$} 
      child {}
      child {}
      child {}
      child {}
      child {}
      child {};
    \node[right=1 of 1] (2) {$\bullet$} 
      child {}
      child {}
      child {};
    \node[right=1 of 2] (3) {$\bullet$} 
      child {}
      child {}
      child {};
    \node[right=1 of 3] (4) {$\bullet$};
    \node[right=1 of 4] (5) {$\bullet$} 
      child {}
      child {}
      child {};
    \node[right=1 of 5] (6) {$\bullet$};
  \end{tikzpicture}
  };
\end{tikzpicture}
\end{equation}
Usually, we will prefer the style of \eqref{eqn.prefered_composite} rather than the more pedantic style of \eqref{eqn.actual_composite}.

We have now seen how to draw a single polynomial as a corolla forest, with height-$1$ leaves as directions; as well as how to draw a two-fold composite of polynomials as a forest of trees, with height-$2$ leaves as directions.
Note that drawing a corolla of $p$ or a tree of $p\tri q$ is just a graphical way of following the instructions associated with the polynomial $p$ or $p\tri q$ that we saw in \cref{subsec.comon.comp.def.arena}, where the arrows---the top-level leaves---are where the ``futures'' would go.
Similarly, we could depict any $n$-fold composite as a forest with height-$n$ leaves as directions.
You'll have an opportunity to try this in the following exercise.

\begin{exercise}
Use $p,q$ as in \eqref{eqn.pq_misc39} and $r\coloneqq \2\yon+\1$ in the following.
\begin{enumerate}
	\item Draw $q\tri p$.
	\item Draw $p\tri p$.
	\item Draw $p\tri p\tri \1$.
	\item Draw $r\tri r$.
	\item Draw $r\tri r\tri r$.
\qedhere
\end{enumerate}
\begin{solution}
We have $p \coloneqq \yon^\2 + \yon$ and $q \coloneqq \yon^\3 + \1$ as in \eqref{eqn.pq_misc39}.
\begin{enumerate}
    \item Here is a picture of $q\tri p$, where each tree is obtained by taking a $q$-corolla and gluing $p$-corollas to every leaf:
\[
\begin{tikzpicture}[rounded corners]
	\node (p1) [draw] {
	\begin{tikzpicture}[trees,
		level 1/.style={sibling distance=4mm},
	  level 2/.style={sibling distance=2.5mm},
	  red!75!black]
    \node (1) {$\bullet$} 
      child {node[blue!50!black] {$\bullet$} 
      	child[blue!50!black]
				child[blue!50!black]
			}
      child {node[blue!50!black] {$\bullet$} 
      	child[blue!50!black]
				child[blue!50!black]
			}
      child {node[blue!50!black] {$\bullet$} 
      	child[blue!50!black]
				child[blue!50!black]
			};
%
    \node[right=1.2 of 1] (2) {$\bullet$} 
      child {node[blue!50!black] {$\bullet$} 
      	child[blue!50!black]
				child[blue!50!black]
			}
      child {node[blue!50!black] {$\bullet$} 
      	child[blue!50!black]
				child[blue!50!black]
			}
      child {node[blue!50!black] {$\bullet$} 
      	child[blue!50!black]
			};
%
    \node[right=1.2 of 2] (3) {$\bullet$} 
      child {node[blue!50!black] {$\bullet$} 
      	child[blue!50!black]
				child[blue!50!black]
			}
      child {node[blue!50!black] {$\bullet$} 
      	child[blue!50!black]
			}
      child {node[blue!50!black] {$\bullet$} 
      	child[blue!50!black]
				child[blue!50!black]
			};
%
    \node[right=1.2 of 3] (4) {$\bullet$} 
      child {node[blue!50!black] {$\bullet$} 
      	child[blue!50!black]
				child[blue!50!black]
			}
      child {node[blue!50!black] {$\bullet$} 
      	child[blue!50!black]
			}
      child {node[blue!50!black] {$\bullet$} 
      	child[blue!50!black]
			};

    \node[right=1.2 of 4] (5) {$\bullet$} 
      child {node[blue!50!black] {$\bullet$} 
      	child[blue!50!black]
			}
      child {node[blue!50!black] {$\bullet$} 
      	child[blue!50!black]
				child[blue!50!black]
			}
      child {node[blue!50!black] {$\bullet$} 
      	child[blue!50!black]
				child[blue!50!black]
			};

    \node[right=1.2 of 5] (6) {$\bullet$} 
      child {node[blue!50!black] {$\bullet$} 
      	child[blue!50!black]
			}
      child {node[blue!50!black] {$\bullet$} 
      	child[blue!50!black]
				child[blue!50!black]
			}
      child {node[blue!50!black] {$\bullet$} 
      	child[blue!50!black]
			};

    \node[right=1.2 of 6] (7) {$\bullet$} 
      child {node[blue!50!black] {$\bullet$} 
      	child[blue!50!black]
			}
      child {node[blue!50!black] {$\bullet$} 
      	child[blue!50!black]
			}
      child {node[blue!50!black] {$\bullet$} 
      	child[blue!50!black]
				child[blue!50!black]
			};
%
    \node[right=1.2 of 7] (8) {$\bullet$} 
      child {node[blue!50!black] {$\bullet$} 
      	child[blue!50!black]
			}
      child {node[blue!50!black] {$\bullet$} 
      	child[blue!50!black]
			}
      child {node[blue!50!black] {$\bullet$} 
      	child[blue!50!black]
			};
%
    \node[right=1 of 8] (9) {$\bullet$};
  \end{tikzpicture}
  };
\end{tikzpicture}
\]
    
    \item Here is a picture of $p\tri p$:
\[
\begin{tikzpicture}[rounded corners]
	\node (p1) [draw] {
	\begin{tikzpicture}[trees,
		level 1/.style={sibling distance=8mm},
	  level 2/.style={sibling distance=3mm},
	  blue!50!black]
    \node[blue!50!black] (1) {$\bullet$} 
      child {node {$\bullet$} 
      	child
				child
			}
      child {node {$\bullet$} 
      	child
				child
			};
%
    \node[blue!50!black, right=1.5 of 1] (2) {$\bullet$} 
      child {node {$\bullet$} 
      	child
				child
			}
      child {node {$\bullet$} 
        child
			};
%
    \node[blue!50!black, right=1.5 of 2] (3) {$\bullet$} 
      child {node {$\bullet$} 
        child
			}
      child {node {$\bullet$} 
      	child
				child
			};
%
    \node[blue!50!black, right=1.5 of 3] (4) {$\bullet$} 
      child {node {$\bullet$}
        child
			}
      child {node {$\bullet$}
        child
			};
%
    \node[blue!50!black, right=1.2 of 4] (5) {$\bullet$} 
      child {node {$\bullet$} 
      	child
				child
			};
%
    \node[blue!50!black, right=1 of 5] (6) {$\bullet$} 
      child {node {$\bullet$} 
        child
			};
  \end{tikzpicture}
  };
\end{tikzpicture}
\]

    \item To obtain a picture of $p\tri p\tri\1$, we take our picture of $p\tri p$ and glue the single, leafless $\1$-root to every (height-$2$) leaf:
\[
\begin{tikzpicture}[rounded corners]
	\node (p1) [draw] {
	\begin{tikzpicture}[trees,
		level 1/.style={sibling distance=8mm},
	  level 2/.style={sibling distance=3mm},
	  blue!50!black]
    \node[blue!50!black] (1) {$\bullet$} 
      child {node {$\bullet$} 
      	child {node[black] {$\bullet$}}
				child {node[black] {$\bullet$}}
			}
      child {node {$\bullet$} 
      	child {node[black] {$\bullet$}}
				child {node[black] {$\bullet$}}
			};
%
    \node[blue!50!black, right=1.5 of 1] (2) {$\bullet$} 
      child {node {$\bullet$} 
      	child {node[black] {$\bullet$}}
				child {node[black] {$\bullet$}}
			}
      child {node {$\bullet$} 
        child {node[black] {$\bullet$}}
			};
%
    \node[blue!50!black, right=1.5 of 2] (3) {$\bullet$} 
      child {node {$\bullet$} 
        child {node[black] {$\bullet$}}
			}
      child {node {$\bullet$} 
      	child {node[black] {$\bullet$}}
				child {node[black] {$\bullet$}}
			};
%
    \node[blue!50!black, right=1.5 of 3] (4) {$\bullet$} 
      child {node {$\bullet$}
        child {node[black] {$\bullet$}}
			}
      child {node {$\bullet$}
        child {node[black] {$\bullet$}}
			};
%
    \node[blue!50!black, right=1.2 of 4] (5) {$\bullet$} 
      child {node {$\bullet$} 
      	child {node[black] {$\bullet$}}
				child {node[black] {$\bullet$}}
			};
%
    \node[blue!50!black, right=1 of 5] (6) {$\bullet$} 
      child {node {$\bullet$} 
        child {node[black] {$\bullet$}}
			};
  \end{tikzpicture}
  };
\end{tikzpicture}
\]
\end{enumerate}

Now $r\coloneqq \2\yon+\1$. Before we draw the composites, here's a picture of $r$ itself, with different colors to distinguish the different positions:

\[
\begin{tikzpicture}[rounded corners]
	\node (p1) [draw] {
	\begin{tikzpicture}[trees, sibling distance=2.5mm]
    \node[blue!50!black] (1) {$\bullet$} 
      child[blue!50!black];
%  
    \node[right=.5 of 1, red!75!black] (2) {$\bullet$} 
      child[red!75!black];
%
    \node[right=.5 of 2] (3) {$\bullet$};
  \end{tikzpicture}
  };
\end{tikzpicture}
\]

\begin{enumerate}[resume]
    \item Here is a picture of $r\tri r$:
\[
\begin{tikzpicture}[rounded corners]
	\node (p1) [draw] {
	\begin{tikzpicture}[trees,
		level 1/.style={sibling distance=8mm},
	  level 2/.style={sibling distance=2.5mm},
	  blue!50!black]
    \node (1) {$\bullet$} 
      child {node {$\bullet$} 
      	child
			};
%
    \node[right=.5 of 1] (2) {$\bullet$} 
      child {node[red!75!black] {$\bullet$} 
      	child[red!75!black]
			};
%
    \node[right=.5 of 2] (3) {$\bullet$} 
      child {node[black] {$\bullet$}};
%
    \node[right=.5 of 3, red!75!black] (4) {$\bullet$} 
      child[red!75!black] {node {$\bullet$}
        child};
%
    \node[right=.5 of 4, red!75!black] (5) {$\bullet$} 
      child[red!75!black] {node[red!75!black] {$\bullet$} 
      	child[red!75!black]
			};
%
    \node[right=.5 of 5, red!75!black] (6) {$\bullet$} 
      child[red!75!black] {node[black] {$\bullet$}};
%
    \node[right=.5 of 6, black] (7) {$\bullet$};
  \end{tikzpicture}
  };
\end{tikzpicture}
\]
    
    \item Here is a picture of $r\tri r\tri r$:
\[
\begin{tikzpicture}[rounded corners]
	\node (p1) [draw] {
	\begin{tikzpicture}[trees,
		level 1/.style={sibling distance=8mm},
	  level 2/.style={sibling distance=2.5mm},
	  blue!50!black]
    \node (1) {$\bullet$} 
      child {node {$\bullet$} 
      	child {node {$\bullet$}
      	  child
      	      }
			};
%
    \node[right=.5 of 1] (2) {$\bullet$} 
      child {node {$\bullet$} 
      	child {node[red!75!black] {$\bullet$}
      	  child[red!75!black]
      	      }
			};
%
    \node[right=.5 of 2] (3) {$\bullet$} 
      child {node {$\bullet$} 
      	child {node[black] {$\bullet$}}
			};
%
    \node[right=.5 of 3] (4) {$\bullet$} 
      child {node[red!75!black] {$\bullet$} 
      	child[red!75!black] {node[blue!50!black] {$\bullet$}
      	  child[blue!50!black]
      	      }
			};
%
    \node[right=.5 of 4] (5) {$\bullet$} 
      child {node[red!75!black] {$\bullet$} 
      	child[red!75!black] {node[red!75!black] {$\bullet$}
      	  child[red!75!black]
      	      }
			};
%
    \node[right=.5 of 5] (6) {$\bullet$} 
      child {node[red!75!black] {$\bullet$} 
      	child[red!75!black] {node[black] {$\bullet$}}
			};
%
    \node[right=.5 of 6] (7) {$\bullet$} 
      child {node[black] {$\bullet$}};
%
    \node[right=.5 of 7, red!75!black] (8) {$\bullet$} 
      child[red!75!black] {node[blue!50!black] {$\bullet$} 
      	child[blue!50!black] {node[blue!50!black] {$\bullet$}
      	  child[blue!50!black]
      	      }
			};
%
    \node[right=.5 of 8, red!75!black] (9) {$\bullet$} 
      child[red!75!black] {node[blue!50!black] {$\bullet$} 
      	child[blue!50!black] {node[red!75!black] {$\bullet$}
      	  child[red!75!black]
      	      }
			};
%
    \node[right=.5 of 9, red!75!black] (10) {$\bullet$} 
      child[red!75!black] {node[blue!50!black] {$\bullet$} 
      	child[blue!50!black] {node[black] {$\bullet$}}
			};
%
    \node[right=.5 of 10, red!75!black] (11) {$\bullet$} 
      child[red!75!black] {node[red!75!black] {$\bullet$} 
      	child[red!75!black] {node[blue!50!black] {$\bullet$}
      	  child[blue!50!black]
      	      }
			};
%
    \node[right=.5 of 11, red!75!black] (12) {$\bullet$} 
      child[red!75!black] {node[red!75!black] {$\bullet$} 
      	child[red!75!black] {node[red!75!black] {$\bullet$}
      	  child[red!75!black]
      	      }
			};
%
    \node[right=.5 of 12, red!75!black] (13) {$\bullet$} 
      child[red!75!black] {node[red!75!black] {$\bullet$} 
      	child[red!75!black] {node[black] {$\bullet$}}
			};
%
    \node[right=.5 of 13, red!75!black] (14) {$\bullet$} 
      child[red!75!black] {node[black] {$\bullet$}};
%
    \node[right=.5 of 14, black] (15) {$\bullet$};
  \end{tikzpicture}
  };
\end{tikzpicture}
\]
\end{enumerate}
\end{solution}
\end{exercise}


\begin{example}[Composing polynomials with constants] \label{ex.apply_2}
For any set $X$ and polynomial $p$, we can take $p(X)\in\smset$; indeed $p\colon\smset\to\smset$ is a functor! In particular, by this point you've seen us write $p(\1)$ hundreds of times. But we've also seen that $X$ is itself a polynomial, namely a constant one.

It's not hard to see that $p(X)\iso p\tri X$. Here's a picture, where $p\coloneqq\yon^\3+\yon+\1$ and $X\coloneqq\2$.
\[
\begin{tikzpicture}[rounded corners]
	\node (p1) [draw, blue!50!black, "\color{blue!50!black} $p$" above] {
	\begin{tikzpicture}[trees, sibling distance=2.5mm]
    \node["\tiny 1" below] (1) {$\bullet$} 
      child {}
      child {}
      child {};
    \node[right=.5 of 1,"\tiny 2" below] (2) {$\bullet$} 
      child {};
      ;
    \node[right=.5 of 2,"\tiny 3" below] (3) {$\bullet$} 
      ;
  \end{tikzpicture}
  };
%
	\node (p2) [draw, red!75!black, right=2 of p1, "\color{red!75!black}$X$" above] {
	\begin{tikzpicture}[trees, sibling distance=2.5mm]
    \node["\tiny 1" below] (1) {$\bullet$};
    \node[right=.5 of 1,"\tiny 2" below] (4) {$\diamond$};
    \node[above=10pt of 4] {};
    ;
  \end{tikzpicture}
  };
\end{tikzpicture}
\]
Let's see how $(\yon^\3+\yon+\1)\tri\2$ looks.
\[
\begin{tikzpicture}[rounded corners]
	\node (p1) [draw, "{\color{blue!50!black} $p$}$\:\tri\:${\color{red!75!black}$X$}" above] {
	\begin{tikzpicture}[trees, sibling distance=2.5mm, blue!50!black]
    \node[blue!50!black] (1) {$\bullet$} 
      child {node[red!75!black] {$\bullet$}}
      child {node[red!75!black] {$\bullet$}}
      child {node[red!75!black] {$\bullet$}};
    \node[blue!50!black, right=of 1] (2) {$\bullet$} 
      child {node[red!75!black] {$\bullet$}}
      child {node[red!75!black] {$\bullet$}}
      child {node[red!75!black] {$\diamond$}};
    \node[blue!50!black, right=of 2] (3) {$\bullet$} 
      child {node[red!75!black] {$\bullet$}}
      child {node[red!75!black] {$\diamond$}}
      child {node[red!75!black] {$\bullet$}};
    \node[blue!50!black, right=of 3] (4) {$\bullet$} 
      child {node[red!75!black] {$\bullet$}}
      child {node[red!75!black] {$\diamond$}}
      child {node[red!75!black] {$\diamond$}};
    \node[blue!50!black, right=of 4] (5) {$\bullet$} 
      child {node[red!75!black] {$\diamond$}}
      child {node[red!75!black] {$\bullet$}}
      child {node[red!75!black] {$\bullet$}};
    \node[blue!50!black, right=of 5] (6) {$\bullet$} 
      child {node[red!75!black] {$\diamond$}}
      child {node[red!75!black] {$\bullet$}}
      child {node[red!75!black] {$\diamond$}};
    \node[blue!50!black, right=of 6] (7) {$\bullet$} 
      child {node[red!75!black] {$\diamond$}}
      child {node[red!75!black] {$\diamond$}}
      child {node[red!75!black] {$\bullet$}};
    \node[blue!50!black, right=of 7] (8) {$\bullet$} 
      child {node[red!75!black] {$\diamond$}}
      child {node[red!75!black] {$\diamond$}}
      child {node[red!75!black] {$\diamond$}};
    \node[blue!50!black, right=.8 of 8] (9) {$\bullet$} 
      child {node[red!75!black] {$\bullet$}};
    \node[blue!50!black, right=.6 of 9] (10) {$\bullet$} 
      child {node[red!75!black] {$\diamond$}};
    \node[blue!50!black, right=.6 of 10] (11) {$\bullet$};
	\end{tikzpicture}
	};
\end{tikzpicture}
\]
It has $11$ positions and no height-$2$ leaves, which means it's a set (constant polynomial, with no directions), namely $p\tri X\iso \1\1$.

We could also draw $X\tri p$, since both are perfectly valid polynomials. Here it is:
\[
\begin{tikzpicture}[rounded corners]
	\node (p2) [draw, "{\color{red!75!black}$X$}$\:\tri\:${\color{blue!50!black} $p$}" above] {
	\begin{tikzpicture}[trees, sibling distance=2.5mm, red!75!black]
    \node["\tiny 1" below] (1) {$\bullet$};
    \node[right=.5 of 1,"\tiny 2" below] (4) {$\diamond$};
    \node[above=10pt of 4] {};
    ;
  \end{tikzpicture}
  };
\end{tikzpicture}
\]
Each of the leaves in $X$---of which there are none---is given a $p$-corolla.
\end{example}

\begin{exercise}\label{exc.composing_with_constants}
\begin{enumerate}
	\item Choose a polynomial $p$ and draw $p\tri\1$ in the style of \cref{ex.apply_2}.
	\item Show that if $X$ is a set (considered as a constant polynomial) and $p$ is any polynomial, then $X\tri p\iso X$.
	\item \label{exc.composing_with_constants.appl} Show that if $X$ is a set and $p$ is a polynomial, then $p\tri X\iso p(X)$, where $p(X)$ is the set given by applying $p$ as a functor to $X$.
\qedhere
\end{enumerate}
\begin{solution}
\begin{enumerate}
    \item We pick the list polynomial, $p\coloneqq\1+\yon+\yon^\2+\yon^\3+\cdots$, drawn as follows:
\[
\begin{tikzpicture}[rounded corners]
\node (p1) [draw] {
  \begin{tikzpicture}[trees, sibling distance=3mm]
    \node (1) {$\bullet$};
    \node[right=.3 of 1] (2) {$\bullet$}
      child {};
    \node[right=.4 of 2] (3) {$\bullet$} 
      child {}
      child {};
    \node[right=.6 of 3] (4) {$\bullet$} 
      child {}
      child {}
      child {};
    \node[right=.6 of 4] {$\cdots$};
  \end{tikzpicture}
};
\end{tikzpicture}
\]
Then here is a picture of $p\tri\1$:
\[
\begin{tikzpicture}[rounded corners]
\node (p1) [draw] {
  \begin{tikzpicture}[trees, sibling distance=3mm]
    \node (1) {$\bullet$};
    \node[right=.3 of 1] (2) {$\bullet$}
      child {node {$\bullet$}};
    \node[right=.4 of 2] (3) {$\bullet$} 
      child {node {$\bullet$}}
      child {node {$\bullet$}};
    \node[right=.6 of 3] (4) {$\bullet$} 
      child {node {$\bullet$}}
      child {node {$\bullet$}}
      child {node {$\bullet$}};
    \node[right=.6 of 4] {$\cdots$};
  \end{tikzpicture}
};
\end{tikzpicture}
\]
\end{enumerate}
Below, $X$ is a set and $p$ is a polynomial.
\begin{enumerate}[resume]
    \item A constant functor composed with any functor is still the same constant functor, so $X \tri p \iso X$.
    We can also verify this using \eqref{eqn.composite_formula}:
    \[
        X \tri p \iso \sum_{i \in X} \prod_{a \in \varnothing} \sum_{j \in p(\1)} \prod_{b \in p[j]} \yon \iso \sum_{i \in X} \1 \iso X.
    \]
    \item When viewed as functors, it is easy to see that $p \tri X \iso p(X)$.
    We can also verify this using \eqref{eqn.composite_formula}:
    \[
        p \tri X \iso \sum_{i \in p(\1)} \prod_{a \in p[i]} \sum_{j \in X} \prod_{b \in \varnothing} \yon \iso \sum_{i \in p(\1)} \prod_{a \in p[i]} \sum_{j \in X} \1 \iso \sum_{i \in p(\1)} \prod_{a \in p[i]} X \iso \sum_{i \in p(\1)} X^{p[i]} \iso p(X).
    \]
\end{enumerate}
\end{solution}
\end{exercise}

In particular, this means we could write the position-set of a polynomial $p$ interchangeably as $p(\1)$ or as $p\tri\1$.
We'll generally write $p(\1)$ when we want to emphasize the position-set as a set, and $p\tri\1$ when we want to emphasize the position-set as a polynomial (albeit a constant one, with no directions).

\begin{exercise}
Let $\varphi\colon p\to q$ be a lens and $X$ be a set viewed as a constant polynomial.
Consider the lens $\varphi\tri X\colon p\tri X\to q\tri X$, given by taking the composition product of $\varphi$ with the identity lens on $X$.
Show that $\varphi\tri X$, when viewed as a function $p(X)\to q(X)$ between sets, is exactly the $X$-component of $\varphi$ viewed as a natural transformation.
\begin{solution}
Let $\varphi\colon p\to q$ be a lens and $X$ be a set viewed as a constant polynomial.
Note that every component of the identity natural transformation on $X$ as a constant functor is just the identity function $\id_X\colon X\to X$ on $X$ as a set.
Then by \cref{def.horiz_comp_nat_trans}, any component of the composition product $\varphi\tri X$ viewed as a natural transformation is given by the composite function
\[
    p(X) \To{\varphi_X} q(X) \To{q(\id_X)} q(X).
\]
By functoriality, $q(\id_X)$ is itself an identity function, so every component of $\varphi\tri X$ is the $X$-component of $\varphi$.
Therefore $\varphi\tri X$ as a function can be identified with the $X$-component of $\varphi$, as desired.
\end{solution}
\end{exercise}

\begin{exercise}\label{ex.compose_yon}
For any $p\in\poly$ there are natural isomorphisms $p\iso p\tri \yon$ and $p\iso\yon\tri p$.
\begin{enumerate}
	\item Thinking of polynomials as functors $\smset\to\smset$, what functor does $\yon$ represent?
	\item Why are $p\tri\yon$ and $\yon\tri p$ isomorphic to $p$?
	\item Let $p\coloneqq\yon^\3+\yon+\1$.
	In terms of tree pictures, draw $p\tri\yon$ and $\yon\tri p$, and explain pictorially how to see the isomorphisms $p\tri\yon \iso p \iso \yon\tri p$.
\qedhere
\end{enumerate}
\begin{solution}
\begin{enumerate}
    \item The polynomial $\yon$ is the identity functor on $\smset$.
    \item Composing any functor with the identity functor yields the original functor, so $p\tri\yon \iso p \iso \yon\tri p$.
    \item Before we draw $\yon\tri p$ and $p\tri\yon$, here are pictures of $p$ and $\yon$ individually as corolla forests:
\[
\begin{tikzpicture}[rounded corners]
	\node (p1) [draw, blue!50!black, "\color{blue!50!black} $p$" above] {
	\begin{tikzpicture}[trees, sibling distance=2.5mm]
    \node (1) {$\bullet$} 
      child {}
      child {}
      child {};
    \node[right=.5 of 1] (2) {$\bullet$} 
      child {};
    \node[right=.5 of 2] (3) {$\bullet$};
  \end{tikzpicture}
  };
%
	\node (p2) [draw, right=2 of p1, "$\yon$" above] {
	\begin{tikzpicture}[trees, sibling distance=2.5mm]
    \node (1) {$\bullet$}
      child {};
  \end{tikzpicture}
  };
\end{tikzpicture}
\]
Now here is a picture of $p\tri\yon$, obtained by gluing the one-leaf $\yon$-corolla to all the leaves of each $p$-corolla in turn:
\[
\begin{tikzpicture}[rounded corners]
	\node (p1) [draw, blue!50!black, "{\color{blue!50!black}$p$}$\:\tri\:\yon$" above] {
	\begin{tikzpicture}[trees, sibling distance=5mm]
    \node (1) {$\bullet$} 
      child {node[black] {$\bullet$} child[black]}
      child {node[black] {$\bullet$} child[black]}
      child {node[black] {$\bullet$} child[black]};
    \node[right=1 of 1] (2) {$\bullet$} 
      child {node[black] {$\bullet$} child[black]};
    \node[right=.5 of 2] (3) {$\bullet$};
  \end{tikzpicture}
  };
\end{tikzpicture}
\]
This is just $p$ with every direction extended up one level, so it is still a picture of $p$.

And here is a picture of $\yon\tri p$, obtained by gluing each $p$-corolla to the single leaf of $\yon$:
\[
\begin{tikzpicture}[rounded corners]
	\node (p2) [draw, "$\yon\:\tri\:${\color{blue!50!black}$p$}" above] {
	\begin{tikzpicture}[trees, sibling distance=2.5mm]
    \node (1) {$\bullet$}
      child {
        node[blue!50!black] {$\bullet$}
            child[blue!50!black]
            child[blue!50!black]
            child[blue!50!black]
      };
    \node[right=.5 of 1] (2) {$\bullet$} 
      child {
        node[blue!50!black] {$\bullet$}
            child[blue!50!black]
      };
    \node[right=.5 of 2] (3) {$\bullet$}
      child {
        node[blue!50!black] {$\bullet$}
      };
  \end{tikzpicture}
  };
\end{tikzpicture}
\]
\end{enumerate}
\end{solution}
This is just $p$ with every position propped up one level, so it is also still a picture of $p$.
\end{exercise}

How shall we think about taking the composition product of lenses in terms of our tree pictures?
We can interpret the results of \cref{exc.comp_prod_lens} as follows.

\begin{example}\label{ex.comp_prod_trees}
Let's take $p\coloneqq \yon^\2+\yon$, $q\coloneqq\yon^\2+\yon$, $p'\coloneqq\yon^\3+\yon$, and $q'\coloneqq\yon+\1$.
\[
\begin{tikzpicture}[rounded corners]
	\node (p) [draw, blue!50!black, "$p=$" left] {
	\begin{tikzpicture}[trees, sibling distance=5mm]
    \node["\tiny 1" below] (1) {$\bullet$} 
      child {}
      child {};
    \node[right=.5 of 1,"\tiny 2" below] (2) {$\bullet$} 
      child {};
  \end{tikzpicture}
  };
%
	\node (q) [draw, red!75!black, above=1 of p, "$q=$" left] {
	\begin{tikzpicture}[trees, sibling distance=5mm]
    \node["\tiny 1" below] (1) {$\bullet$} 
      child {}
      child {};
    \node[right=.5 of 1,"\tiny 2" below] (2) {$\bullet$} 
      child {};
  \end{tikzpicture}
  };
	\node (p') [draw, blue, right=3 of p, "$p'=$" left] {
	\begin{tikzpicture}[trees, sibling distance=2.5mm]
    \node["\tiny 1" below] (1) {$\bullet$} 
      child {}
      child {}
      child {};
    \node[right=.5 of 1,"\tiny 2" below] (2) {$\bullet$}
      child {};
  \end{tikzpicture}
  };
	\node (q') [draw, red, above=1 of p', "$q'=$" left] {
	\begin{tikzpicture}[trees, sibling distance=2.5mm]
    \node["\tiny 1" below] (1) {$\bullet$} 
      child {};
    \node[right=.5 of 1,"\tiny 2" below] (2) {$\bullet$}
    ;
  \end{tikzpicture}
  };
\end{tikzpicture}
\]
For any pair of lenses $p\to p'$ and $q\to q'$, we have a lens $p\tri q\to p'\tri q'$. Let's draw $p\tri q$ and $p'\tri q'$.
\[
\begin{tikzpicture}[rounded corners]
	\node (p1) [draw, "$p\tri q$" above] {
	\begin{tikzpicture}[trees,
		level 1/.style={sibling distance=8mm},
	  level 2/.style={sibling distance=2.5mm}]
    \node[blue!50!black] (1) {$\bullet$} 
      child[blue!50!black] {node[red!75!black] {$\bullet$} 
      	child[red!75!black]
				child[red!75!black]
			}
      child[blue!50!black] {node[red!75!black] {$\bullet$} 
      	child[red!75!black]
				child[red!75!black]
			};
%
    \node[blue!50!black, right=1.7 of 1] (2) {$\bullet$} 
      child[blue!50!black] {node[red!75!black] {$\bullet$} 
				child[red!75!black]
				child[red!75!black]
			}
      child[blue!50!black] {node[red!75!black] {$\bullet$} 
				child[red!75!black]
			};
%
    \node[blue!50!black, right=1.5 of 2] (3) {$\bullet$} 
      child[blue!50!black] {node[red!75!black] {$\bullet$} 
      	child[red!75!black]
			}
      child[blue!50!black] {node[red!75!black] {$\bullet$} 
				child[red!75!black]
				child[red!75!black]
			};
%
    \node[blue!50!black, right=1.5 of 3] (4) {$\bullet$} 
      child[blue!50!black] {node[red!75!black] {$\bullet$} 
      	child[red!75!black]
			}
      child[blue!50!black] {node[red!75!black] {$\bullet$} 
				child[red!75!black]
			};
%
    \node[blue!50!black, right=1.2 of 4] (5) {$\bullet$} 
      child[blue!50!black] {node[red!75!black] {$\bullet$} 
      	child[red!75!black]
      	child[red!75!black]
			};
%
    \node[blue!50!black, right=.8 of 5] (6) {$\bullet$} 
      child[blue!50!black] {node[red!75!black] {$\bullet$} 
      	child[red!75!black]
			};
  \end{tikzpicture}
  };
\end{tikzpicture}
\]
\[
\begin{tikzpicture}[rounded corners]
	\node (p1) [draw, "$p'\tri q'$" above] {
	\begin{tikzpicture}[trees,
		level 1/.style={sibling distance=4mm},
	  level 2/.style={sibling distance=2.5mm}]
    \node[blue] (1) {$\bullet$} 
      child[blue] {node[red] {$\bullet$} 
      	child[red]
			}
      child[blue] {node[red] {$\bullet$} 
      	child[red]
			}
      child[blue] {node[red] {$\bullet$} 
				child[red]
			};
%
    \node[blue, right=1.4 of 1] (2) {$\bullet$} 
      child[blue] {node[red] {$\bullet$} 
      	child[red]
			}
      child[blue] {node[red] {$\bullet$} 
      	child[red]
			}
      child[blue] {node[red] {$\bullet$} 
			};
%
    \node[blue, right=1.4 of 2] (3) {$\bullet$} 
      child[blue] {node[red] {$\bullet$} 
      	child[red]
			}
      child[blue] {node[red] {$\bullet$} 
			}
      child[blue] {node[red] {$\bullet$} 
				child[red]
			};
%
    \node[blue, right=1.4 of 3] (4) {$\bullet$} 
      child[blue] {node[red] {$\bullet$} 
      	child[red]
			}
      child[blue] {node[red] {$\bullet$} 
			}
      child[blue] {node[red] {$\bullet$} 
			};
%
    \node[blue, right=1.4 of 4] (5) {$\bullet$} 
      child[blue] {node[red] {$\bullet$} 
			}
      child[blue] {node[red] {$\bullet$} 
      	child[red]
			}
      child[blue] {node[red] {$\bullet$} 
				child[red]
			};
%
    \node[blue, right=1.4 of 5] (6) {$\bullet$} 
      child[blue] {node[red] {$\bullet$} 
			}
      child[blue] {node[red] {$\bullet$} 
      	child[red]
			}
      child[blue] {node[red] {$\bullet$} 
			};
%
    \node[blue, right=1.4 of 6] (7) {$\bullet$} 
      child[blue] {node[red] {$\bullet$} 
			}
      child[blue] {node[red] {$\bullet$} 
			}
      child[blue] {node[red] {$\bullet$} 
      	child[red]
			};
%
    \node[blue, right=1.4 of 7] (8) {$\bullet$} 
      child[blue] {node[red] {$\bullet$} 
			}
      child[blue] {node[red] {$\bullet$} 
			}
      child[blue] {node[red] {$\bullet$} 
			};
%
    \node[blue, right=1 of 8] (9) {$\bullet$} 
      child[blue] {node[red] {$\bullet$} 
      	child[red]
			};
%
    \node[blue, right=.8 of 9] (10) {$\bullet$} 
      child[blue] {node[red] {$\bullet$} 
			};
  \end{tikzpicture}
  };
\end{tikzpicture}
\]

Let's also pick a pair of lenses, $\varphi\colon p\to p'$ and $\psi\colon q\to q'$.
\[
\begin{tikzpicture}
	\node (p1) {\raisebox{.3cm}{$\varphi\colon p\to p'$}\qquad
	\begin{tikzpicture}[trees, sibling distance=5mm]
    \node[blue!50!black, "\color{blue!50!black} \tiny 1" below] (1) {$\bullet$} 
      child[blue!50!black] {coordinate (11)}
      child[blue!50!black] {coordinate (12)};
    \node[right=1.5 of 1, blue, "\color{blue} \tiny 1" below] (2) {$\bullet$} 
      child[blue] {coordinate (21)}
      child[blue] {coordinate (22)}
      child[blue] {coordinate (23)};
    \draw[|->, shorten <= 3pt, shorten >= 3pt] (1) -- (2);
    \begin{scope}[densely dotted, bend right]
      \draw[postaction={decorate}] (21) to (12);
      \draw[postaction={decorate}] (22) to (12);
      \draw[postaction={decorate}] (23) to (11);
    \end{scope}
  \end{tikzpicture}	
	};	
%
	\node (p2) [below right=-1.3 and 1 of p1] {
	\begin{tikzpicture}[trees, sibling distance=5mm]
    \node[blue!50!black, "\color{blue!50!black} \tiny 2" below] (1) {$\bullet$} 
      child[blue!50!black] {coordinate (11)};
    \node[right=of 1, blue, "\color{blue} \tiny 2" below] (2) {$\bullet$}
      child[blue] {coordinate (21)};
    \draw[|->, shorten <= 3pt, shorten >= 3pt] (1) -- (2);
    \begin{scope}[densely dotted, bend right]
      \draw[postaction={decorate}] (21) to (11);
		\end{scope}
  \end{tikzpicture}	
	};	
	\node [below=.5 of p1] (p3) {\raisebox{.3cm}{$\psi\colon q\to q'$}\qquad
	\begin{tikzpicture}[trees, sibling distance=5mm]
    \node[red!75!black, "\color{red!75!black} \tiny 1" below] (1) {$\bullet$} 
      child[red!75!black] {coordinate (11)}
      child[red!75!black] {coordinate (12)};
    \node[right=1.5 of 1, red, "\color{red} \tiny 1" below] (2) {$\bullet$} 
      child[red] {coordinate (21)};
    \draw[|->, shorten <= 3pt, shorten >= 3pt] (1) -- (2);
    \begin{scope}[densely dotted, bend right]
      \draw[postaction={decorate}] (21) to (12);
    \end{scope}
  \end{tikzpicture}	
	};	
%
	\node (p4) [below right=-1.05 and 1 of p3] {
	\begin{tikzpicture}[trees, sibling distance=5mm]
    \node[red!75!black, "\color{red!75!black} \tiny 2" below] (1) {$\bullet$} 
      child[red!75!black] {coordinate (11)};
    \node[right=of 1, red, "\color{red} \tiny 2" below] (2) {$\bullet$};
    \draw[|->, shorten <= 3pt, shorten >= 3pt] (1) -- (2);
  \end{tikzpicture}	
	};	
\end{tikzpicture}
\]
Then by \cref{exc.comp_prod_lens}, we can form the lens $\varphi\tri \psi\colon p\tri q\to p'\tri q'$ as follows.
On positions, we follow \eqref{eqn.comp_lens_pos}: for each tree $t$ in the picture of $p\tri q$, we begin by using $\varphi_\1$ to send the $p$-corolla $i$ that forms the bottom level of $t$ to a $p'$-corolla $i'$.
Then for each $p'[i']$-leaf $a'$ of $i'$, to choose which $q'$-corolla gets glued to $a'$, we use $\varphi^\sharp_i$ to send $a'$ back to a $p[i]$-leaf $a$.
Since $t$ has the corolla $i$ as its bottom level, $a$ is just a height-$1$ vertex of the tree $t$.
So we can take the $q$-corolla $j$ that is glued to $a$ in $t$, then use $\psi_\1$ to send $j$ forward to a $q'$-corolla $j'$.
This is the corolla we glue to the $p'[i']$-leaf $a'$.
All this specifies a tree $t'$ in $p'\tri q'$ that $t$ gets sent to via $(\varphi\tri \psi)_\1$.

On directions, we follow \eqref{eqn.comp_lens_dir}: picking a direction of $t'$ consists of picking a height-$1$ vertex $a'$ and a height-$2$ leaf $b'$ emanating from $a'$.
The on-directions function $\varphi^\sharp_i$ sends $a'$ back to a height-$1$ vertex $a$ of $t$, and as we saw, the on-positions function $\psi_\1$ sends the $q$-corolla $j$ glued to $a$ in $t$ forward to the $q'$-corolla glued to $a'$.
Then $b'$ is a leaf of that $q'$-corolla, and $\psi^\sharp_j$ sends $b'$ back to a leaf $b$ emanating from $a$.
So the on-directions function $(\varphi\tri \psi)^\sharp_t$ sends the height-$2$ leaf $b'$ to the height-$2$ leaf $b$.

We draw the lens $\varphi\tri \psi\to p\tri q\to p'\tri q'$ below.
To avoid clutter, we leave out the arrows for $\psi_\1$ that show how the red corollas on the right are selected; we hope the reader can put it together for themselves.
\[
	\begin{tikzpicture}[trees]
	\begin{scope}[
		level 1/.style={sibling distance=8mm},
	  level 2/.style={sibling distance=5mm}]
    \node[blue!50!black] (1) {$\bullet$} 
      child[blue!50!black] {node[red!75!black] (11') {$\bullet$} 
      	child[red!75!black] {coordinate (11)}
				child[red!75!black] {coordinate (12)}
			}
      child[blue!50!black] {node[red!75!black] (12') {$\bullet$} 
      	child[red!75!black] {coordinate (13)}
				child[red!75!black] {coordinate (14)}
			};
%
    \node[blue!50!black, right=5 of 1] (2) {$\bullet$} 
      child[blue!50!black] {node[red!75!black] (21') {$\bullet$} 
      	child[red!75!black] {coordinate (21)}
				child[red!75!black] {coordinate (22)}
			}
      child[blue!50!black] {node[red!75!black] (22') {$\bullet$} 
      	child[red!75!black] {coordinate (23)}
			};
%
    \node[blue!50!black, below=1.3 of 1] (3) {$\bullet$} 
      child[blue!50!black] {node[red!75!black] (31') {$\bullet$} 
      	child[red!75!black] {coordinate (31)}
			}
      child[blue!50!black] {node[red!75!black] (32') {$\bullet$} 
      	child[red!75!black] {coordinate (32)}
				child[red!75!black] {coordinate (33)}
			};
%
    \node[blue!50!black] at (2|-3) (4) {$\bullet$} 
      child[blue!50!black] {node[red!75!black] (41') {$\bullet$} 
      	child[red!75!black] {coordinate (41)}
			}
      child[blue!50!black] {node[red!75!black] (42') {$\bullet$} 
      	child[red!75!black] {coordinate (42)}
			};
%
    \node[blue!50!black, below=1.3 of 3] (5) {$\bullet$} 
      child[blue!50!black] {node[red!75!black] (51') {$\bullet$} 
      	child[red!75!black] {coordinate (51)}
				child[red!75!black] {coordinate (52)}
			};
%
    \node[blue!50!black] at (4|-5) (6) {$\bullet$} 
      child[blue!50!black] {node[red!75!black] (61') {$\bullet$} 
      	child[red!75!black] {coordinate (61)}
			};
		\end{scope}
%%
	\begin{scope}[		
		level 1/.style={sibling distance=4mm},
	  level 2/.style={sibling distance=5mm}]
	    \node[blue, right=2 of 1] (1') {$\bullet$} 
      child[blue] {node[red] (1'1') {$\bullet$} 
      	child[red] {coordinate (1'1)}
			}
      child[blue] {node[red] (1'2') {$\bullet$} 
      	child[red] {coordinate (1'2)}
			}
      child[blue] {node[red] (1'3') {$\bullet$} 
      	child[red] {coordinate (1'3)}
			};
%
    \node[blue, right=2 of 2] (2') {$\bullet$} 
      child[blue] {node[red] (2'1') {$\bullet$} 
			}
      child[blue] {node[red] (2'2') {$\bullet$} 
			}
      child[blue] {node[red] (2'3') {$\bullet$} 
      	child[red] {coordinate (2'1)}
			};
%
    \node[blue, right=2 of 3] (3') {$\bullet$} 
      child[blue] {node[red] (3'1') {$\bullet$} 
      	child[red] {coordinate (3'1)}
			}
      child[blue] {node[red] (3'2') {$\bullet$} 
      	child[red] {coordinate (3'2)}
			}
      child[blue] {node[red] (3'3') {$\bullet$} 
			};
%
    \node[blue, right=2 of 4] (4') {$\bullet$} 
      child[blue] {node[red] (4'1') {$\bullet$} 
			}
      child[blue] {node[red] (4'2') {$\bullet$} 
			}
      child[blue] {node[red] (4'3') {$\bullet$} 
			};
%
    \node[blue, right=2 of 5] (5') {$\bullet$} 
      child[blue] {node[red] (5'1') {$\bullet$} 
      	child[red] {coordinate (5'1)}
			};
%
    \node[blue, right=2 of 6] (6') {$\bullet$} 
      child[blue] {node[red] (6'1') {$\bullet$} 
			};
%
\draw[|->, shorten <= 3pt, shorten >= 3pt] (1) -- (1');
\draw[|->, shorten <= 3pt, shorten >= 3pt] (2) -- (2');
\draw[|->, shorten <= 3pt, shorten >= 3pt] (3) -- (3');
\draw[|->, shorten <= 3pt, shorten >= 3pt] (4) -- (4');
\draw[|->, shorten <= 3pt, shorten >= 3pt] (5) -- (5');
\draw[|->, shorten <= 3pt, shorten >= 3pt] (6) -- (6');
    \begin{scope}[densely dotted, bend right=15pt]
      \draw[postaction={decorate}] (1'1') to (12');
      \draw[postaction={decorate}] (1'2') to (12');
      \draw[postaction={decorate}] (1'3') to (11');
      \draw[postaction={decorate}] (1'1) to (14);
      \draw[postaction={decorate}] (1'2) to (14);
      \draw[postaction={decorate}] (1'3) to (12);
%
      \draw[postaction={decorate}] (2'1') to (22');
      \draw[postaction={decorate}] (2'2') to (22');
      \draw[postaction={decorate}] (2'3') to (21');
      \draw[postaction={decorate}] (2'1) to (23);
%
      \draw[postaction={decorate}] (3'1') to (32');
      \draw[postaction={decorate}] (3'2') to (32');
      \draw[postaction={decorate}] (3'3') to (31');
      \draw[postaction={decorate}] (3'1) to (33);
      \draw[postaction={decorate}] (3'2) to (33);
%
      \draw[postaction={decorate}] (4'1') to (42');
      \draw[postaction={decorate}] (4'2') to (42');
      \draw[postaction={decorate}] (4'3') to (41');
%
      \draw[postaction={decorate}] (5'1') to (51');
      \draw[postaction={decorate}] (5'1) to (52);
%
      \draw[postaction={decorate}] (6'1') to (61');
    \end{scope}

	\end{scope}
  \end{tikzpicture}
\]
\end{example}

\begin{exercise}
With $p,q,p',q'$ and $\varphi,\psi$ as in \cref{ex.comp_prod_trees}, draw the lens $\psi\tri\varphi\colon q\tri p\to q'\tri p'$ in terms of trees as in the example.
\begin{solution}
Using the definitions, instructions, and style from \cref{ex.comp_prod_trees}, we draw $\psi\tri\varphi\colon q\tri p\to q'\tri p'$:
\[
	\begin{tikzpicture}[trees]
	\begin{scope}[
		level 1/.style={sibling distance=8mm},
	  level 2/.style={sibling distance=5mm}]
    \node[red!75!black] (1) {$\bullet$} 
      child[red!75!black] {node[blue!50!black] (11') {$\bullet$} 
      	child[blue!50!black] {coordinate (11)}
				child[blue!50!black] {coordinate (12)}
			}
      child[red!75!black] {node[blue!50!black] (12') {$\bullet$} 
      	child[blue!50!black] {coordinate (13)}
				child[blue!50!black] {coordinate (14)}
			};
%
    \node[red!75!black, right=5 of 1] (2) {$\bullet$} 
      child[red!75!black] {node[blue!50!black] (21') {$\bullet$} 
      	child[blue!50!black] {coordinate (21)}
				child[blue!50!black] {coordinate (22)}
			}
      child[red!75!black] {node[blue!50!black] (22') {$\bullet$} 
      	child[blue!50!black] {coordinate (23)}
			};
%
    \node[red!75!black, below=1.3 of 1] (3) {$\bullet$} 
      child[red!75!black] {node[blue!50!black] (31') {$\bullet$} 
      	child[blue!50!black] {coordinate (31)}
			}
      child[red!75!black] {node[blue!50!black] (32') {$\bullet$} 
      	child[blue!50!black] {coordinate (32)}
				child[blue!50!black] {coordinate (33)}
			};
%
    \node[red!75!black] at (2|-3) (4) {$\bullet$} 
      child[red!75!black] {node[blue!50!black] (41') {$\bullet$} 
      	child[blue!50!black] {coordinate (41)}
			}
      child[red!75!black] {node[blue!50!black] (42') {$\bullet$} 
      	child[blue!50!black] {coordinate (42)}
			};
%
    \node[red!75!black, below=1.3 of 3] (5) {$\bullet$} 
      child[red!75!black] {node[blue!50!black] (51') {$\bullet$} 
      	child[blue!50!black] {coordinate (51)}
				child[blue!50!black] {coordinate (52)}
			};
%
    \node[red!75!black] at (4|-5) (6) {$\bullet$} 
      child[red!75!black] {node[blue!50!black] (61') {$\bullet$} 
      	child[blue!50!black] {coordinate (61)}
			};
		\end{scope}
%%
	\begin{scope}[		
		level 1/.style={sibling distance=4mm},
	  level 2/.style={sibling distance=2.5mm}]
	    \node[red, right=2 of 1] (1') {$\bullet$} 
      child[red] {node[blue] (1'1') {$\bullet$} 
      	child[blue] {coordinate (1'1)}
      	child[blue] {coordinate (1'2)}
      	child[blue] {coordinate (1'3)}
			};
%
    \node[red, right=2 of 2] (2') {$\bullet$} 
      child[red] {node[blue] (2'1') {$\bullet$} 
        child[blue] {coordinate (2'1)}
			};
%
    \node[red, right=2 of 3] (3') {$\bullet$} 
      child[red] {node[blue] (3'1') {$\bullet$} 
      	child[blue] {coordinate (3'1)} 
      	child[blue] {coordinate (3'2)} 
      	child[blue] {coordinate (3'3)}
			};
%
    \node[red, right=2 of 4] (4') {$\bullet$} 
      child[red] {node[blue] (4'1') {$\bullet$}  
      	child[blue] {coordinate (4'1)}
			};
%
    \node[red, right=2 of 5] (5') {$\bullet$};
%
    \node[red, right=2 of 6] (6') {$\bullet$};
%
\draw[|->, shorten <= 3pt, shorten >= 3pt] (1) -- (1');
\draw[|->, shorten <= 3pt, shorten >= 3pt] (2) -- (2');
\draw[|->, shorten <= 3pt, shorten >= 3pt] (3) -- (3');
\draw[|->, shorten <= 3pt, shorten >= 3pt] (4) -- (4');
\draw[|->, shorten <= 3pt, shorten >= 3pt] (5) -- (5');
\draw[|->, shorten <= 3pt, shorten >= 3pt] (6) -- (6');
    \begin{scope}[densely dotted, bend right=15pt]
      \draw[postaction={decorate}] (1'1') to (12');
      \draw[postaction={decorate}] (1'1) to (14);
      \draw[postaction={decorate}] (1'2) to (14);
      \draw[postaction={decorate}] (1'3) to (13);
%
      \draw[postaction={decorate}] (2'1') to (22');
      \draw[postaction={decorate}] (2'1) to (23);
%
      \draw[postaction={decorate}] (3'1') to (32');
      \draw[postaction={decorate}] (3'1) to (33);
      \draw[postaction={decorate}] (3'2) to (33);
      \draw[postaction={decorate}] (3'3) to (32);
%
      \draw[postaction={decorate}] (4'1') to (42');
      \draw[postaction={decorate}] (4'1) to (42);
    \end{scope}

	\end{scope}
  \end{tikzpicture}
\]
\end{solution}
\end{exercise}

\begin{exercise}
Suppose $p$, $q$, and $r$ are polynomials and you're given arbitrary lenses $\varphi\colon q\to p\tri q$ and $\psi\colon q\to q\tri r$. Does the following diagram necessarily commute?\tablefootnote{When the name of an object is used in place of a morphism, we refer to the identity morphism on that object.
So for instance, $\varphi\tri r$ is the composition product of $\varphi$ with the identity lens on $r$.}
\[
\begin{tikzcd}
	q\ar[r, "g"]\ar[d, "\varphi"']&
	q\tri r\ar[d, "\varphi\:\tri\:r"]\\
	p\tri q\ar[r, "p\:\tri\:\psi"']&
	p\tri q\tri r\ar[ul, phantom, "?"]
\end{tikzcd}
\]
That is, do we have $\varphi\then (p\tri \psi)=^?\psi\then (\varphi\tri r)$?
\begin{solution}
Given arbitrary polynomials $p,q,r$ and lenses $\varphi\colon q\to p\tri q$ and $\psi\colon q\to q\tri r$, it is \emph{not} necessarily the case that $\varphi\then (p\tri \psi)=\psi\then (\varphi\tri r)$!
After all, we can let $p\coloneqq\yon$ and $q\coloneqq\2$ so that $\varphi$ is a lens $\2\to\yon\tri\2\iso\2$ (see \cref{ex.compose_yon}) and $\psi$ is a lens $\2\to\2\tri r\iso\2$ (see \cref{exc.composing_with_constants}).
Then by following the instructions for interpreting a composition product of lenses from either \cref{exc.comp_prod_lens} or \cref{ex.comp_prod_trees}, we can verify that $p\tri \psi=\yon\tri \psi$ is a lens $\2\iso\yon\tri\2\to\yon\tri\2\tri r\iso\2$ equivalent to the lens $\psi$, while $\varphi\tri r$ is a lens $\2\iso\2\tri r\to\yon\tri\2\tri r\iso\2$ equivalent to the lens $\varphi$.
If, say, we let $\varphi\colon\2\to\2$ be the function sending everything to $1\in\2$ and $\psi\colon\2\to\2$ be the function sending everything to $2\in\2$, then in this case $\varphi\then (p\tri \psi)=\varphi\then \psi\neq \psi\then \varphi=\psi\then (\varphi\tri r)$.
\end{solution}
\end{exercise}

\subsection{Dynamical systems and the composition product} \label{subsec.comon.comp.def.dyn_sys}

Back in \cref{ex.do_nothing}, we posed the question of how to model running multiple steps of dynamical system in $\poly$.
The answer lies with the composition product.

Recall that a dependent dynamical system is a lens $\varphi\colon S\yon^S\to p$, where $S$ is a set of states and $p$ is a polynomial interface.
We call $S\yon^S$ the state system, each $p$-position $i$ an output, each $p[i]$-direction an input at $i$, and the on-position and on-direction functions of $\varphi$ the return and update functions, respectively.
More generally, we saw in \cref{ex.do_nothing} that we could replace the state system with a monomial $q\coloneqq S\yon^{S'}$, where $S'$ is another set, as long as there is a function $e\colon S\to S'$ (or equivalently a situation $\epsilon\colon S\yon^{S'}\to\yon$) that is bijective.

The lens models a dynamical system as follows.
Every state $s\in q(\1)=S$ returns an output $o\coloneqq\varphi_\1(s)\in p(\1)$, and every input $i\in p[o]$ yields an updated direction $s'\coloneqq\varphi^\sharp_s(a)\in q[s]=S'$.
Then to model a second step through the system, we identify the $q[s]$-direction $s'$ with a $q$-position $e^{-1}(s')$, plug this position back into $\varphi_\1$, and repeat the process all over again.

% Equivalently, we could think of running through two steps of the system as picking an initial state $s\in q(\1)$ and using a bijection $\ol{t}\colon q[s]\to q(\1)$ to assign each direction at $s$ to a state in $q(\1)$.
% Then we apply $\varphi$ in two rounds.
% First, we use the return function to compute an output $i\coloneqq\varphi_\1(s)$ and the update function $\varphi^\sharp_s\colon p[i]\to q[s]$ to compute a direction at $s$ for each input.
% Before the next round, we use $\ol{t}$ to compute the state assigned to that direction.
% Second, we use the return function to compute an output for that state 

But this is exactly what the composition product $\varphi\tri\varphi\colon q\tri q\to p\tri p$ does: by \eqref{eqn.comp_lens_pos}, its on-positions function sends the pair $(s_0,e^{-1})\in(q\tri q)(\1)$, comprised of an initial state $s_0\in q(\1)$ and the function $e^{-1}\colon q[s_0]=S'\to S=q(\1)$, to the pair
\begin{equation} \label{eqn.interface_position_pair}
    \left(\varphi_\1(s_0),\varphi^\sharp_{s_0}\then e^{-1}\then\varphi_\1\right)\in(p\tri p)(\1),
\end{equation}
comprised of the initial output $o_0\coloneqq\varphi_\1(s)\in p(\1)$ and a composite function
\begin{equation} \label{eqn.interface_position_fn1}
    p[o_0]\To{\varphi^\sharp_{s_0}}q[s_0]=S'\To{e^{-1}}S=q(\1)\To{\varphi_\1}p(\1),
\end{equation}
which uses the update function at $s_0$ and the return function to tell us what the next output $o_1$ will be for every possible input $i_1$ we could select.
Then by \eqref{eqn.comp_lens_dir}, the on-directions function of $\varphi\tri\varphi$ sends each direction $(i_1,i_2)$ at the position \eqref{eqn.interface_position_pair}, comprised of a first input $i_1\in p[o_0]$ and (setting $o_1$ to be the function \eqref{eqn.interface_position_fn1} applied to $i_1$) a second input $i_2\in p[o_1]$, to the pair
\[
    \left(\varphi^\sharp_{s_0}(i_1), \varphi^\sharp_{e^{-1}(\varphi^\sharp_{s_0}(i_1))}(i_2)\right),
\]
comprised of directions in $S'$ that (under $e^{-1}$) correspond to the next state $s_1$ upon selecting input $i_1$ at state $s_0$ and the successive state $s_2$ upon selecting input $i_2$ at $s_1$.
In summary, at certain positions, $\varphi\tri\varphi$ tells us how the dynamical system will behave when we step through it twice: starting from state $s_0$, returning output $o_0$, receiving input $i_1$, updating its state to $s_1$, returning output $o_1$, receiving input $i_2$, and preparing to update its state to $s_2$.
Adding another layer, $\varphi\tri\varphi\tri\varphi\colon q\tri q\tri q\to p\tri p\tri p$ will tell us how the system behaves when we step through it three times; and in general, $\varphi\tripow{n}\colon q\tripow{n}\to p\tripow{n}$ will tell us how the system behaves when we step through it $n$ times.

\begin{example}[Composition products of dynamical systems as trees] \label{ex.comp_dyn_sys_tree}
Consider the dynamical system $\varphi\colon S\yon^S\to p$ with $p\coloneqq\yon^A+\1$, corresponding to the halting deterministic state automaton \eqref{eqn.halt_dsa} from \cref{exc.halt_dsa}, depicted again here for convenience:
\[
\begin{tikzcd}[column sep=small]
	\bul[blue]\ar[rr, bend left, orange]\ar[loop left, dgreen]&&
	\bul[dyellow]\ar[dl, bend left, orange]\ar[ll, dgreen, bend left]\\&
	\bul[red]
\end{tikzcd}
\]
Below, we draw the corolla pictures for $S\yon^S$ and for $p$.
\[
\begin{tikzpicture}[rounded corners]
	\node (p1) [draw, "$S\yon^S$" above] {
	    \begin{tikzpicture}[trees, sibling distance=2.5mm]
            \node[blue, below] (1) {$\bullet$} 
              child[blue] {}
              child[dyellow] {}
              child[red] {};
            \node[dyellow, right=1 of 1] (2) {$\bullet$} 
              child[blue] {}
              child[dyellow] {}
              child[red] {};
            \node[red, right=1 of 2] (3) {$\bullet$} 
              child[blue] {}
              child[dyellow] {}
              child[red] {};
        \end{tikzpicture}
    };
%
	\node (p2) [draw, right=2 of p1, "$p$" above] {
        \begin{tikzpicture}[trees, sibling distance=4mm]
            \node (1) {$\circ$}
                child[dgreen] {}
                child[orange] {};
            \node[right=0.5 of 1] (2) {$\diamond$};
            ;
        \end{tikzpicture}
    };
\end{tikzpicture}
\]
In the picture for $S\yon^S$, the roots are the three states in $\{\bul[blue],\bul[dyellow],\bul[red]\}$ appearing in the automaton, while the leaves of each corolla correspond to the three states as well.
In the picture for $p$, there is one corolla whose two leaves correspond to the two arrows coming out of every state---except for the halting state, which is sent to the corolla with no leaves instead.
So the lens $\varphi\colon S\yon^S\to p$ capturing the dynamics of the automaton can be drawn as follows:
\[
\begin{tikzpicture}
	\node (p1) {
	\begin{tikzpicture}[trees, sibling distance=4mm]
        \node[blue] (1) {$\bullet$} 
            child[blue]     {coordinate (11)}
            child[dyellow]  {coordinate (12)}
            child[red]      {coordinate (13)};
        \node[right=1.5 of 1] (2) {$\circ$} 
            child[dgreen] {coordinate (21)}
            child[orange] {coordinate (22)};
        \draw[|->, shorten <= 3pt, shorten >= 3pt] (1) -- (2);
        \begin{scope}[densely dotted, bend right]
          \draw[postaction={decorate}] (21) to (11);
          \draw[postaction={decorate}] (22) to (12);
        \end{scope}
    \end{tikzpicture}	
	};	
%
	\node [right=1 of p1] (p2) {
	\begin{tikzpicture}[trees, sibling distance=4mm]
        \node[dyellow] (1) {$\bullet$} 
            child[blue]     {coordinate (11)}
            child[dyellow]  {coordinate (12)}
            child[red]      {coordinate (13)};
        \node[right=1.5 of 1] (2) {$\circ$} 
            child[dgreen] {coordinate (21)}
            child[orange] {coordinate (22)};
        \draw[|->, shorten <= 3pt, shorten >= 3pt] (1) -- (2);
        \begin{scope}[densely dotted, bend right]
          \draw[postaction={decorate}] (21) to (11);
          \draw[postaction={decorate}] (22) to (13);
        \end{scope}
    \end{tikzpicture}	
	};	
%
	\node [right=1 of p2, yshift=-5pt] (p3) {
	\begin{tikzpicture}[trees, sibling distance=4mm]
        \node[red] (1) {$\bullet$} 
            child[blue]     {coordinate (11)}
            child[dyellow]  {coordinate (12)}
            child[red]      {coordinate (13)};
        \node[right=1.5 of 1] (2) {$\diamond$};
        \draw[|->, shorten <= 3pt, shorten >= 3pt] (1) -- (2);
    \end{tikzpicture}	
	};	
\end{tikzpicture}
\]
The corolla picture tells us, for example, that from the yellow state, we can go in one of two directions: the green direction, which leads us to the blue state, or the orange direction, which leads us to the red state.
This describes the dynamics of the automaton one step away from the yellow state.

But what if we want to understand the dynamics of $\varphi$ \emph{two} steps away from the yellow state?
Consider the following tree, corresponding to a position of the $2$-fold composite $S\yon^S\tri S\yon^S$:
\begin{equation} \label{eqn.sys_tri2_good_tree}
\begin{tikzpicture}[trees,
  level 1/.style={sibling distance=7.5mm},
  level 2/.style={sibling distance=2.5mm}]
	\node[dyellow] (a) {$\bullet$}
		child[blue] {node[blue] {$\bullet$}
			child[blue]
			child[dyellow]
			child[red]
		}
		child[dyellow] {node[dyellow] {$\bullet$}
			child[blue]
			child[dyellow]
			child[red]
		}
		child[red] {node[red] {$\bullet$}
			child[blue]
			child[dyellow]
			child[red]
		};
\end{tikzpicture}
\end{equation}
We can follow the steps from \cref{ex.comp_prod_trees} to find that the composition product of lenses $\varphi\tri\varphi\colon S\yon^S\tri S\yon^S\to p\tri p$ acts on this tree as follows:
\[
\begin{tikzpicture}[trees,
  level 1/.style={sibling distance=10mm},
  level 2/.style={sibling distance=4mm}]
    \node[dyellow] (1) {$\bullet$}
		child[blue] {node[blue] (11) {$\bullet$}
			child[blue] {coordinate (111)}
			child[dyellow] {coordinate (112)}
			child[red] {coordinate (113)}
		}
		child[dyellow] {node[dyellow] (12) {$\bullet$}
			child[blue] {coordinate (121)}
			child[dyellow] {coordinate (122)}
			child[red] {coordinate (123)}
		}
		child[red] {node[red] (13) {$\bullet$}
			child[blue] {coordinate (131)}
			child[dyellow] {coordinate (132)}
			child[red] {coordinate (133)}
		};
%
    \node[right=5 of 1] (2) {$\circ$}
        child[dgreen] {node[black, sibling distance=5mm] (21) {$\circ$}
            child[dgreen] {coordinate (211)}
            child[orange] {coordinate (212)}
        }
        child[orange] {node[black] (22) {$\diamond$}
        };
			
	\draw[|->, shorten <= 3pt, shorten >= 3pt] (1) -- (2);
    \begin{scope}[densely dotted, bend right=10pt]
      \draw[postaction={decorate}] (21) to (11);
      \draw[postaction={decorate}] (22) to (13);
    \end{scope}
    \begin{scope}[densely dotted, bend right=25pt]
      \draw[postaction={decorate}] (211) to (111);
      \draw[postaction={decorate}] (212) to (112);
    \end{scope}
\end{tikzpicture}
\]
Read each tree the way you would read a decision tree, and you will find that this picture tells you exactly what the dynamics of the automaton are two steps away from the yellow state!
Actually, it says that if we start from the yellow state (the root on the left, which is sent to the root on the right) and go in the orange direction (up from the root along the orange arrow to the right), the automaton will halt (as there are no more directions to follow).
But if we instead go in the green direction (up from the root along the green arrow to the left), we could go in the green direction again (up the next green arrow) to arrive at a blue state (as indicated by the dashed arrow above), or instead in the orange direction to arrive at a yellow state (similarly).
\end{example}

This is what we meant in the introduction when we said that the composition product has to do with time.
It takes a specification $\varphi$ for how a state system and an interface can interact back-and-forth---or, indeed, any interaction pattern between wrapper interfaces---and extends it to a multistep model $\varphi\tripow{n}$ that simulates $n$ successive interaction cycles over time, accounting for all possible external input that the interface could encounter.
Alternatively, we can think of $\varphi\tripow{n}$ as ``speeding up'' the original dynamical system $\varphi$ by a factor of $n$, as it runs $n$ steps in one---as long as whatever's connected to its new interface $p\tripow{n}$ can keep up with its pace and feed it $n$ inputs of $p$ at a time!
The lens $\varphi$ tells us how the machine can run, but it is $\tri$ that makes the clock tick.

\subsubsection{Why this is not enough}\label{subsubsec.comon.comp.def.dyn_sys.issues}
There are several pressing issues we must address, however, before we can even begin to provide a satisfying answer to everything we asked for in \cref{ex.do_nothing}.
The first is a communication issue: as you probably sensed, our set-theoretic notation for $\varphi\tripow{n}$ is rather cumbersome, and that was just for $n=2$.
We could depict the behavior of our composition products of dynamical systems more clearly using tree pictures (see \cref{ex.comp_dyn_sys_tree}), but even that becomes infeasible in greater generality.
A concise visual representation of the back-and-forth interaction of lenses would help us reason about composition products more effectively.

The second issue is more technical: to ensure that $\varphi\tri\varphi$ behaves the way we want, when we specify a position of its domain $q\tri q$, we have to provide not only an initial state $s_0$ but also the isomorphism $e^{-1}\colon S'\to S$ to let the lens know which state in $S$ each $q[s_0]$-direction in $S'$ should lead to.
But there are many other positions $(s_0,f)$ of $q\tri q$ that we could have specified, and each $f\colon S'\to S$ associates $q[s_0]$-directions to $q$-positions in a different way.
So $\varphi\tri\varphi$ is carrying around a lot of extraneous---even misleading!---data about how our dynamical system behaves when the state system moves in the right direction but to the wrong state.
Our isomorphism $e^{-1}$ is a temporary fix, but as we pointed out in \cref{ex.do_nothing}, it relies on the set-theoretic equality of the direction-sets of $q$---there's nothing inherent to the categorical structure of $q$ in $\poly$ that encodes how directions map to states, at least not yet.
What are we missing?

\begin{example}[Composition products of dynamical systems can be misleading] \label{ex.comp_dyn_sys_mislead}
In \cref{ex.comp_dyn_sys_mislead}, instead of \eqref{eqn.sys_tri2_good_tree}, we could have picked the following tree, corresponding to a different (yet entirely valid) position of $S\yon^S\tri S\yon^S$:
\[
\begin{tikzpicture}[trees,
  level 1/.style={sibling distance=7.5mm},
  level 2/.style={sibling distance=2.5mm}]
	\node[dyellow] (a) {$\bullet$}
		child[blue] {node[red] {$\bullet$}
			child[blue]
			child[dyellow]
			child[red]
		}
		child[dyellow] {node[red] {$\bullet$}
			child[blue]
			child[dyellow]
			child[red]
		}
		child[red] {node[dyellow] {$\bullet$}
			child[blue]
			child[dyellow]
			child[red]
		};
\end{tikzpicture}
\]
The composition product $\varphi\tri\varphi\colon S\yon^S\tri S\yon^S\to p\tri p$ acts on this tree like so:
\[
\begin{tikzpicture}[trees,
  level 1/.style={sibling distance=10mm},
  level 2/.style={sibling distance=4mm}]
    \node[dyellow] (1) {$\bullet$}
		child[blue] {node[red] (11) {$\bullet$}
			child[blue] {coordinate (111)}
			child[dyellow] {coordinate (112)}
			child[red] {coordinate (113)}
		}
		child[dyellow] {node[red] (12) {$\bullet$}
			child[blue] {coordinate (121)}
			child[dyellow] {coordinate (122)}
			child[red] {coordinate (123)}
		}
		child[red] {node[dyellow] (13) {$\bullet$}
			child[blue] {coordinate (131)}
			child[dyellow] {coordinate (132)}
			child[red] {coordinate (133)}
		};
%
    \node[right=5 of 1] (2) {$\circ$}
        child[dgreen] {node[black] (21) {$\diamond$}
        }
        child[orange] {node[black] (22) {$\circ$}
            child[dgreen] {coordinate (221)}
            child[orange] {coordinate (222)}
        };
			
	\draw[|->, shorten <= 3pt, shorten >= 3pt] (1) -- (2);
    \begin{scope}[densely dotted, bend right=10pt]
      \draw[postaction={decorate}] (21) to (11);
      \draw[postaction={decorate}] (22) to (13);
    \end{scope}
    \begin{scope}[densely dotted, bend right=25pt]
      \draw[postaction={decorate}] (221) to (111);
      \draw[postaction={decorate}] (222) to (113);
    \end{scope}
\end{tikzpicture}
\]
Now the picture tells us that, starting from the yellow state, it is the green arrow that will lead to a halting state, whereas we should somehow be able to follow the orange arrow twice!

Of course, this is nonsense---stemming from the fact that we have glued the ``wrong'' corollas to each leaf when forming the position of $S\yon^S\tri S\yon^S$ on the left.
It's important to note, however, that this is nevertheless part of the data of $\varphi\tri\varphi$, and we don't yet know how to tell $\poly$ to rule it out.
\end{example}

The key to resolving both these issues lies in the next section, where we will introduce a graphical notation to help us study lenses whose codomains are composite polynomials.



%-------- Section --------%
\section{Lenses to composites}\label{sec.comon.comp.to_comp}

Lenses to composites---that is, lenses of the form $f\colon p\to q_1\tri\cdots\tri q_n$ for some $n\in\nn$ with composites as their codomains---will be ubiquitous in the remainder of our story.
Fortunately, they have some very nice properties that make them convenient to work with.
Before we explore these properties, we'll introduce a new way of visualizing lenses that is well-suited to capturing the behavior of lenses to composites.

\subsection{Lenses as polyboxes}
First, let us consider what goes into specifying a lens $f\colon p\to q$.
To visualize this, we will introduce a new form of notation, which we will call \emph{polyboxes}, that will generalize well to lenses to composites:
\begin{equation} \label{eqn.polybox_lens}
\begin{tikzpicture}
  \node (f) ["$f\colon p\to q$" above] {
    \begin{tikzpicture}[polybox, tos]
  	  \node[poly, dom, "$p$" below] (p) {};
  	  \node[left=0pt of p_pos] {$p(\1)$};
  	  \node[left=0pt of p_dir] {$p[-]$};

  	  \node[poly, cod, right=of p, "$q$" below] (q) {};
  	  \node[right=0pt of q_pos] {$q(\1)$};
	  \node[right=0pt of q_dir] {$q[-]$};
	  
  	  \draw (p_pos) -- node[below] {} (q_pos);
  	  \draw (q_dir) -- node[above] {} (p_dir);
    \end{tikzpicture}
  };
\end{tikzpicture}
\end{equation}
In our polyboxes, each pair of boxes stacked on top of each other represents a single polynomial.
The lower box in a pair can be filled with any position of the polynomial, while the upper box must be filled with a direction of the polynomial at the position in the lower box.

We think of \eqref{eqn.polybox_lens} as depicting the lens $f$ as a sort of gadget that acts like an automated spreadsheet: the blue boxes accept user input, while the white boxes are computed based on what is entered into the blue boxes according to the spreadsheet's preprogrammed rules.
The arrows track the flow of information, starting from the lower left.

When the user fills the lower left blue box with a $p$-position $i$, the arrow to the right tells us that the gadget should automatically fill the lower right white box with some $q$-position $j$, based on the value $i$ that has already been entered.
This process yields a map $i\mapsto j$ that corresponds to the on-position function $f_\1$ of the lens.

Then when the user fills the upper right blue box with a $q[j]$-direction $b$, the arrow to the left tells us that the gadget should automatically fill the upper left white box with some $p[i]$-position $a$, based on the values $i$ and $b$ that have already been entered.
Fixing $i\in p(\1)$, this process yields a map $b\mapsto a$ that corresponds to the on-directions function $f^\sharp_i$ of the lens.

So when both the user and the automation have finished filling all the boxes, we'll end up with something that looks like this:
\[ \label{eqn.polybox_lens_filled}
\begin{tikzpicture}[polybox, mapstos]
    \node[poly, dom, "$p$" left] (p) {$a$\at$i$};
    \node[poly, cod, "$q$" right, right=of p] (q) {$b$\at$j$};
    \draw (p_pos) -- node[below] {$f_\1$} (q_pos);
    \draw (q_dir) -- node[above] {$f^\sharp$} (p_dir);
\end{tikzpicture}
\]
Here, of course, $j\coloneqq f_\1(i)$ and $a\coloneqq f^\sharp_i(b)$.
So a lens is any protocol that will fill in the white boxes once the user fills in the blue boxes, following the directions of the arrows drawn.
Be careful: although the arrow $f^\sharp$ is drawn from the upper right box, it also takes into account what is entered into the lower left box previously.
After all, the on-directions function of a lens is dependent on both a position of the domain and a direction of the codomain.

If we have two composable lenses $f\colon p\to q$ and $g\colon q\to r$, then we can piece their polyboxes together to form polyboxes for their composite, $f\then g\colon p\to r$:
\[
\begin{tikzpicture}[polybox, tos]
    \node[poly, dom, "$p$" below] (p) {};

    \node[poly, right=of p, "$q$" below] (q) {};

    \node[poly, cod, right=of q, "$r$" below] (r) {};
  
    \draw (p_pos) -- node[below] {$f_\1$} (q_pos);
    \draw (q_dir) -- node[above] {$f^\sharp$} (p_dir);
  
    \draw (q_pos) -- node[below] {$g_\1$} (r_pos);
    \draw (r_dir) -- node[above] {$g^\sharp$} (q_dir);
\end{tikzpicture}
\]
The lower (position) box for $q$, which would normally be blue as part of the polyboxes for $g\colon q\to r$, is instead filled in via $f_\1$; similarly, the upper (direction box) for $q$, which would normally be blue as part of the polyboxes for $f\colon p\to q$, is filled in via $g^\sharp$.
This forms a gadget that is equivalent to what the polyboxes would be for $f\then g$.

Again, as we follow the arrows from left to right and up and left again, take care to note that the arrow $g^\sharp$ depends not only on the upper box for $r$, but also the lower box for $q$ that came before it.
Similarly, the arrow $f^\sharp$ depends on both the lower box for $p$ and the upper box for $q$.

On the other hand, the arrow $g_\1$ depends only on the lower box for $q$, and not the lower box for $p$ that came before it: $g_\1$ is the on-positions function for a lens $q\to r$ and therefore depends only on its domain. (Of course, changing the contents of the lower box for $p$ may change the lower box for $q$, thus indirectly affecting what $g_\1$ enters in the lower box for $r$; what we mean is that if the lower box for $p$ changes but the lower box for $q$ does not, $g_\1$ will not change the lower box for $r$.)
For the same reason, the arrow $g^\sharp$ does not depend on the lower box for $p$, and the arrow $f^\sharp$ does not depend on either box for $r$.
The key is to let each arrow depend on exactly the boxes that come before it in either the domain or the codomain of the lens that the arrow is a part of.
Or just remember that these arrows are all on-positions and on-directions functions of lenses!

\begin{remark}
At this point in our introduction to polyboxes, the reader may be concerned that we are referring to things like ``gadgets,'' ``spreadsheets,'' ``users,'' ``automation,'' etc.\ without being entirely precise or rigorous about what we mean by them, or what it means to say that they are ``equivalent.''
We choose to elide this issue to highlight the pictorial intuition of our work, rather than grinding through the nitty-gritty details.
This is not to say our work with polyboxes will lack rigor moving forward---if you're particularly worried, you should think of polyboxes simply as an alternate way to present information about dependent sets, functions, sums, and products that can be systematically translated---via elementary steps, though perhaps with some laborious bookkeeping---into the more standard $\in$ and $\sum$ and $\prod$ notation we have been using thus far.

For example, given lenses $f\colon p\to q$ and $g\colon q\to r$, the polyboxes above really do just represent the element of the set
\[
    \prod_{i\in p(\1)}\sum_{k\in r(\1)}p[i]^{r[k]}\iso\poly(p,r)
\]
corresponding to the lens $p\to r$ whose on-positions function $p(\1)\to r(\1)$ is equal to the composite of the on-positions functions $f_\1$ and $g_\1$, and whose on-directions function $r[g_\1(f_\1(i))]\to p[i]$ for each $i\in p(\1)$ is equal to the composite of the on-directions functions $g^\sharp_{f_\1(i)}$ and $f^\sharp_i$.
In other words, it represents the composite lens $f\then g$.
But it displays the way lenses pass positions and directions back and forth far more legibly than all the words in this paragraph can.
Throughout the rest of this book, we'll see how this polybox notation provides immediate, reader-friendly computations and justifications; but all these results can be translated back into more grounded mathematical language as desired.
\end{remark}

\begin{example}[Dynamical systems as polyboxes]
Polyboxes provide a natural way to model our dependent dynamical systems.
We can express such a system $\varphi\colon S\yon^S\to p$ in polyboxes as
\begin{equation*}
\begin{tikzpicture}[polybox, mapstos]
    \node[poly, dom, "$S\yon^S$" left] (S) {$t$\at$s$};

    \node[poly, cod, right=of S, "$p$" right] (p) {$i$\at$o$};
  
    \draw (S_pos) -- node[below] {return} (p_pos);
    \draw (p_dir) -- node[above] {update} (S_dir);
\end{tikzpicture}
\end{equation*}
Then the polybox acts as a channel between the internal state system on the left and the external interface on the right.
The state system enters its current state $s\in S$ into the lower left blue box, and the return function converts this state to the output $o\in p(\1)$, which is exposed by the interface in the lower right white box.
Associated with this output is a set of inputs $p[o]$; an interacting agent selects one of these inputs $i\in p[o]$ to enter into the upper right blue box.
Finally, the update function takes in the current state $s$ and the input $i$ and fills in the upper left white box accordingly with the next state $t\in S$ (or, more precisely, a direction at the current state $s$ that should point to the next state $t$).

We then compose $\varphi$ with a wrapper $f\colon p\to q$ like so:
\begin{equation*}
\begin{tikzpicture}[polybox, mapstos]
    \node[poly, dom, "$S\yon^S$" left] (S) {$t$\at$s$};

    \node[poly, right=of S, "$p$" below] (p) {$i$\at$o$};

    \node[poly, cod, right=of p, "$q$" right] (q) {$i'$\at$o'$};
  
    \draw (S_pos) -- node[below] {return} (p_pos);
    \draw (p_dir) -- node[above] {update} (S_dir);
    \draw (p_pos) -- node[below] {$f_\1$} (q_pos);
    \draw (q_dir) -- node[above] {$f^\sharp$} (p_dir);
\end{tikzpicture}
\end{equation*}
The output $o$ displayed by the intermediary interface $p$ is instead exposed as an output $f_\1(o)=o'$ of the wrapper interface $q$ in the lower box on the far right.
Moreover, the upper box of $p$ is no longer blue: an agent who wishes to interact with the middle interface $p$ can only do so via the rightmost interface $q$.
The on-directions function of the wrapper at $o$ converts input $i'\in q[o']$ from the upper right blue box into input $i\in p[o]$.

Picture the agent standing to the right of all the polyboxes (i.e.\ ``outside'' of the system) with their attention directed leftward (i.e.\ ``inward''), receiving output from the white box below and feeding input into the blue box above.
To an agent who is unaware of its inner workings, the composite dynamical system $\varphi\then f$ might as well look like this:
\begin{equation*}
\begin{tikzpicture}[polybox, mapstos]
    \node[poly, dom, "$S\yon^S$" left] (S) {$t$\at$s$};

    \node[poly, cod, right=of p, "$q$" right] (q) {$i'$\at$o'$};
  
    \draw (S_pos) -- node[below] {return$'$} (q_pos);
    \draw (q_dir) -- node[above] {update$'$} (S_dir);
\end{tikzpicture}
\end{equation*}
\end{example}

\subsection{Situations as polyboxes}
When a polynomial has only $1$ position (i.e.\ it is representable), we shade its lower (position) polybox gray to indicate that there is no choice to be made there, either by the user or by the automation; similarly, if a polynomial has only $1$ direction at every position (i.e.\ it is linear), we shade its upper (direction) polybox gray.
So both polyboxes for $\yon$ are shaded gray.

In \cref{subsec.poly.dyn_sys.new.sit_encl}, we discussed situations, which are lenses with codomain $\yon$.
A situation $\gamma\colon p\to\yon$, then, can be depicted as follows, where $!$ is the unique function into $\1$:
\[
 \begin{tikzpicture}[polybox, tos]
  	\node[poly, dom, "$p$" left] (p) {};
  	\node[poly, identity, right=of p, "$\yon$" right] (yon) {};
  	\draw (p_pos) -- node[below] {$!$} (yon_pos);
  	\draw (yon_dir) -- node[above] {$\gamma^\sharp$} (p_dir);
	\end{tikzpicture}
\]
But this is equivalent to a gadget where, when the user fills in the lower left blue box with a $p$-position $i$, the upper left white box is automatically filled with a $p[i]$-direction $a$.
(Remember that the arrow $\gamma^\sharp$ depends not only on the box to its right, but also on the lower left box of $p$.)
So we can redraw the gadget like so, combining the arrows $!$ and $\gamma^\sharp$ into one arrow $\gamma$:
\begin{equation}\label{eqn.map_to_0ary_composite}
\begin{tikzpicture}[polybox, tos]
    \node[poly, dom, "$p$" left] (p) {};
    \draw (p_pos) to[climb'] node[right] {$\gamma$} (p_dir);
\end{tikzpicture}
\end{equation}
This lines up with what we already know: that a situation $\gamma\colon p\to\yon$ is just a dependent function $\gamma\colon(i\in p(\1))\to p[i]$.

\begin{example}[Enclosures as polyboxes]
Recall that in the language of dynamical systems, situations for interfaces are thought of as enclosures: a fixed selection of input at every output that closes off the interface from external observation or interference.
In polyboxes, composing a system $S\yon^S\to p$ with an enclosure $\gamma$ for $p$ can be depicted as
\begin{equation*}
\begin{tikzpicture}[polybox, tos]
    \node[poly, dom, "$S\yon^S$" left] (S) {};

    \node[poly, right=of S, "$p$" below] (p) {};
    
  	\node[poly, identity, right=of p, "$\yon$" right] (yon) {};
  
    \draw (S_pos) -- node[below] {return} (p_pos);
    \draw (p_dir) -- node[above] {update} (S_dir);
    \draw (p_pos) -- node[below] {$!$} (yon_pos);
    \draw (yon_dir) -- node[above] {$\gamma^\sharp$} (p_dir);
\end{tikzpicture}
\end{equation*}
or, equivalently, as
\begin{equation*}
\begin{tikzpicture}[polybox, tos]
    \node[poly, dom, "$S\yon^S$" left] (S) {};

    \node[poly, right=of S, "$p$" below] (p) {};
  
    \draw (S_pos) -- node[below] {return} (p_pos);
    \draw (p_dir) -- node[above] {update} (S_dir);
    \draw (p_pos) to[climb'] node[right] {$\gamma$} (p_dir);
\end{tikzpicture}
\end{equation*}
Remember: in a polybox depiction of a dynamical system, the world outside the system exists to the right of all the boxes.
So the first picture represents $\yon$ as a gray wall, cutting off any interaction between the system to its left and the world to its right.
Meanwhile, the second picture illustrates how an enclosed system independently selects inputs to the intermediary interface $p$ via $\gamma$, according to the outputs of $p$ that the inner (leftward) system $S\yon^S\to p$ returns.
While the second picture shows us why the closed system neither seeks nor requires external input, the first picture helps remind us that the output of $p$ never reaches the outside world either.
The composite system is therefore equivalent to the enclosure drawn as follows:
\begin{equation*}
\begin{tikzpicture}[polybox, tos]
    \node[poly, dom, "$S\yon^S$" left] (S) {};

    \draw (S_pos) to[climb'] node[right] {$\gamma'$} (S_dir);
\end{tikzpicture}
\end{equation*}
In polynomial morphism parlance, $\gamma'\colon S\yon^S\to\yon$ is the original system $S\yon^S\to p$ composed with $\gamma\colon p\to\yon$; in the language of dependent functions, $\gamma'\colon S\to S$ is given by
\[
    \gamma'(s)=\text{update}(s,\gamma(\text{return}(s))) \qquad \text{for all }s\in S,
\]
where we interpret $\gamma$ as a dependent function $(i\in p(\1))\to p[i]$.
We can deduce this equation by matching up the previous two different polybox pictures, knowing that they represent the same lens.
Placing the boxes side by side and filling them in with dummy variables makes the equation easier to read off the picture:
\[
\begin{tikzpicture}
	\node (1) {
    \begin{tikzpicture}[polybox, mapstos]
        \node[poly, dom, "$S\yon^S$" left] (S) {$t$\at$s$};
    
        \node[poly, right=of S, "$p$" below] (p) {$o$\at$i$};
      
        \draw (S_pos) -- node[below] {return} (p_pos);
        \draw (p_dir) -- node[above] {update} (S_dir);
        \draw (p_pos) to[climb'] node[right] {$\gamma$} (p_dir);
    \end{tikzpicture}
	};
	\node[right=1.8 of 1] (2) {
    \begin{tikzpicture}[polybox, mapstos]
        \node[poly, dom, "$S\yon^S$" left] (S) {$t'$\at$s$};

        \draw (S_pos) to[climb'] node[right] {$\gamma'$} (S_dir);
    \end{tikzpicture}
	};
	\node at ($(1.east)!.5!(2.west)$) {=};
\end{tikzpicture}
\]
Notice that we filled the blue boxes on either side with the same entry.
Matching up the upper boxes of the domain in both pictures, we have that $t=t'$, so
\[
    \gamma'(s)=t'=t=\text{update}(s,o)=\text{update}(s,\gamma(i))=\text{update}(s,\gamma(\text{return}(s))).
\]
Later on, we will read more intricate equations off of polyboxes in this manner, although we won't spell it out in so much detail.
We encourage you to trace through the arrows on your own.
\end{example}

\begin{example}[The do-nothing enclosure in polyboxes]  \label{ex.do_nothing_polybox}
In \cref{ex.do_nothing}, we saw that every state system $S\yon^S$ can be equipped with an enclosure $\epsilon\colon S\yon^S\to\yon$ called the do-nothing enclosure, which assigns each state-position to its corresponding state-direction, thus leaving the state unchanged.
That is, it is the enclosure whose polyboxes can be drawn as follows:
\begin{equation*}
\begin{tikzpicture}[polybox, mapstos]
    \node[poly, dom, "$S\yon^S$" left] (S) {$s$\at$s$};

    \draw (S_pos) to[climb'] node[right] {$\epsilon$} (S_dir);
\end{tikzpicture}
\end{equation*}

This simple example illustrates how we can use polyboxes to specify a particular lens---or, equivalently, how we can use polyboxes to \emph{define} a lens, the same way we might define a function by writing it as a formula in a dummy variable.
\end{example}


\subsection{Lenses to composites as polyboxes}
A lens $p\to q_1\tri q_2$ is an element of the set
\begin{align*}
    \poly(p, q_1\tri q_2) &\iso \poly\left(p, \sum_{j_1\in q_1(\1)}\;\prod_{b_1\in q_1[j_1]}\;\sum_{j_2\in q_2(\1)}\;\prod_{b_2\in q_2[j_2]}\yon\right) \tag*{\eqref{eqn.composite_formula}} \\
    &\iso \prod_{i\in p(\1)}\;\sum_{j_1\in q_1(\1)}\;\prod_{b_1\in q_1[j_1]}\;\sum_{j_2\in q_2(\1)}\;\prod_{b_2\in q_2[j_2]}p[i]. \tag*{\eqref{eqn.main_formula}}
\end{align*}
So we can write down the instructions for picking a lens $p\to q_1\tri q_2$ as follows.
\begin{quote}
To choose a lens $p\to q_1\tri q_2$:
\begin{enumerate}
    \item for each $p$-position $i$:
    \begin{enumerate}[label*=\arabic*.]
        \item choose a $q_1$-position $j_1$;
        \item for each $q_1[j_1]$-direction $b_1$:
        \begin{enumerate}[label*=\arabic*.]
            \item choose a $q_2$-position $j_2$;
            \item for each $q_2[j_2]$-direction $b_2$:
            \begin{enumerate}[label*=\arabic*.]
                \item choose a $p[i]$-direction $a$.
            \end{enumerate}
        \end{enumerate}
    \end{enumerate}
\end{enumerate}
\end{quote}
We could try to write out the dependent functions that these instructions correspond to.
Alternatively, we could simply draw this protocol out using polyboxes, with every ``for each'' step corresponding to a user-maintained blue box and every ``choose'' step corresponding to an automated white box:
\begin{equation}\label{eqn.map_to_2ary_composite}
\begin{tikzpicture}[polybox, mapstos]
	\node[poly, dom, "$p$" left] (p) {$a$\at$i$};
	\node[poly, cod, right=1.5cm of p.south, yshift=-1ex, "$q_1$" right] (q1) {$b_1$\at$j_1$};
	\node[poly, cod, above=of q1, "$q_2$" right] (q2) {$b_2$\at$j_2$};
  	\draw (p_pos) to[first] (q1_pos);
  	\draw (q1_dir) to[climb] (q2_pos);
  	\draw (q2_dir) to[last] (p_dir);
\end{tikzpicture}
\end{equation}
Whenever we draw two pairs of polyboxes on top of each other, as we do with the polyboxes for $q_1$ and $q_2$ above on the right, we are indicating that the entire column of polyboxes depicts the composite of the polynomials depicted by each individual pair.
So the column of polyboxes on the right represents the composite $q_1\tri q_2$.
In particular, the position in the lower box of the top pair is the position associated with the direction in the upper box of the bottom pair, for the depicted position of the composite.

So a lens $p\to q_1\tri q_2$ is any protocol that will fill in the white boxes above as the user fills in the blue boxes in the direction of the arrows.
We'll see this in action in \cref{ex.map_to_comp}.

In fact, \eqref{eqn.map_to_0ary_composite}, \eqref{eqn.polybox_lens}, and \eqref{eqn.map_to_2ary_composite} are the respective polybox depictions of the $n=0, n=1,$ and $n=2$ cases of lenses $p\to q_1\tri\cdots\tri q_n$ to $n$-fold composites (we consider the monoidal unit $\yon$ of $\tri$ to be the $0$-fold composite, and a $1$-fold composite is just a polynomial on its own).
In general, for any $n\in\nn$, we can apply 
\begin{align} \label{eqn.lens_to_comp}
    \poly(p, q_1\tri\cdots\tri q_n) &\iso\poly\left(p, \sum_{j_1\in q_1(\1)}\;\prod_{b_1\in q_1[j_1]}\cdots\sum_{j_n\in q_n(\1)}\;\prod_{b_n\in q_n[j_n]}\yon\right) \tag*{\eqref{eqn.composite_formula}} \\
    &\iso \prod_{i\in p(\1)}\;\sum_{j_1\in q_1(\1)}\;\prod_{b_1\in q_1[j_1]}\cdots\sum_{j_n\in q_n(\1)}\;\prod_{b_n\in q_n[j_n]}p[i], \tag*{\eqref{eqn.main_formula}}
\end{align}
so the polybox depiction of $p\to q_1\tri\cdots\tri q_n$ generalizes analogously.
For example, here are the polyboxes corresponding to a lens to a $4$-fold composite:
\[
\begin{tikzpicture}[polybox, tos]
	\node[poly, dom, "$p$" left] (p) {};
	\foreach \i in {1,...,4}
	{
  	\node[poly, cod, "$q_\i$" right] (q\i) at (3,1.3*\i-3.25) {};
	};
	\draw (p_pos) to[first] node[below] {} (q1_pos.west);
	\foreach \i/\j in {1/2,2/3,3/4}
	{
		\draw 
			(q\i_dir.west) 
			to[climb] 
			node[left] {}
			(q\j_pos.west);
	};
	\draw (q4_dir) to[last] node[above left] {} (p_dir);
\end{tikzpicture}
\]

% We can use this to generalize our notation in the case $k=1$, i.e.\ for lenses $p\to q$. That is we denoted such a morphism by $\lens{f^\sharp}{f_\1}$, where $f_\1\colon p(\1)\to q(\1)$ and $f^\sharp_i\colon q[f_\1(i)]\to p[i]$. We generalize this to the $k$-ary composite case as
% \begin{equation}\label{eqn.notation_f1f2fk}
% (f_1,f_2,\ldots,f_k,f^\sharp)\colon p\too q_1\tri q_2\tri\cdots\tri q_k,
% \end{equation}
% where
% \begin{equation}\label{eqn.maps_to_comp}
% \begin{aligned}
% f_1&:p(\1)\to q_1(\1),\\
% f_2&:(i\in p(\1))\to (b_1\in q_1[f_1(i)])\to q_2(\1),\\
% f_3&:(i\in p(\1))\to (b_1\in q_1[f_1(i)])\to (b_2\in q_2[f_2(i,b_1)])\to q_3(\1),\\
% f_k&:(i\in p(\1))\to (b_1\in q_1[f_1(i)])\to  \cdots\to(b_{k-1}\in q_{k-1}[f_{k-1}(i,b_1,\ldots,b_{k-2})])\to q_k(\1),\\
% f^\sharp&:(i\in p(\1))\to (b_1\in q_1[f_1(i)])\to \cdots\to(b_{k}\in q_k[f_{k}(i,b_1,\ldots,b_{k-1})])\to p[i]
% \end{aligned}
% \end{equation}

These lenses to $n$-fold composites lend themselves to a very natural interpretation in terms of our decision-making language.
Each of $p$'s menus is passed forward to a menu for $q_1$ to choose from.
For every option that $q_1$ may choose, there is then also a menu for $q_2$ to choose from.
Then for every option that $q_2$ may choose, there is a menu for $q_3$ to choose from, and so on, all the way until $q_n$ has chosen an option.
Together, all the options that $q_1,\ldots,q_n$ chose then inform the option that $p$ should select from its original menu.

\slogan{A lens $p\to q_1\tri\cdots\tri q_n$ is a multi-step policy for $p$ to make decisions by asking for decisions from $q_1$, then $q_2$, etc., all the way to $q_n$, then interpreting the results.}

\begin{example}[Lenses $p\to q\tri r$]\label{ex.map_to_comp}
Consider a lens $\varphi\colon p\to q\tri r$.
Let's label the three arrows in the lens's polybox depiction:
\[
\begin{tikzpicture}[polybox, tos]
	\node[poly, dom, "$p$" left] (p) {};
	\node[poly, cod, right=1.5cm of p.south, yshift=-1ex, "$q$" right] (q) {};
	\node[poly, cod, above=of q, "$r$" right] (r) {};
  	\draw (p_pos) to[first] node[below] {$\varphi^q$} (q_pos);
  	\draw (q_dir) to[climb] node[right] {$\varphi^r$} (r_pos);
  	\draw (r_dir) to[last] node[above] {$\varphi^\sharp$} (p_dir);
\end{tikzpicture}
\]
So the on-position function of $\varphi$ can be split into two parts: a function $\varphi^q\colon p(\1)\to q(\1)$ and, for each $i\in p(\1)$, a function $\varphi^r_i\colon q[\varphi^q(i)]\to r(\1)$.
Then the on-directions function $\varphi^\sharp_i\colon (q\tri r)[\varphi_\1(i)]\to p[i]$ takes the direction of $q$ and the direction of $r$ in the two blue boxes on the right and sends them to a direction of $p$ at $i$ to fill the white box on the left.

For example, let $p\coloneqq\{A\}\yon^{\{R,S\}}+{B}\yon^{\{T\}}$, $q\coloneqq\{C\}\yon^{\{U,V,W\}}+\{D\}\yon^{\{X\}}$, and $r\coloneqq\{E\}\yon^{\{Y,Z\}}+\{F\}$.
\[
\begin{tikzpicture}[rounded corners]
	\node (p) [draw, "$p=$" left] {
	\begin{tikzpicture}[trees, sibling distance=4mm]
    \node["\tiny $A$" below] (1) {$\bullet$} 
      child {node[above, font=\tiny] {$R$}}
      child {node[above, font=\tiny] {$S$}};
    \node[right=.5 of 1,"\tiny $B$" below] (2) {$\bullet$} 
      child {node[above, font=\tiny] {$T$}};
  \end{tikzpicture}
  };
%
	\node (q) [draw, blue, right=2 of p, "$q=$" left] {
	\begin{tikzpicture}[trees, sibling distance=4mm]
    \node["\tiny $C$" below] (1) {$\bullet$} 
      child {node[above, font=\tiny] {$U$}}
      child {node[above, font=\tiny] {$V$}}
      child {node[above, font=\tiny] {$W$}};
    \node[right=.75 of 1,"\tiny $D$" below] (2) {$\bullet$} 
      child {node[above, font=\tiny] {$X$}};
  \end{tikzpicture}
  };
	\node (r) [draw, red, right=2 of q, "$r=$" left] {
	\begin{tikzpicture}[trees, sibling distance=4mm]
    \node["\tiny $E$" below] (1) {$\bullet$} 
      child {node[above, font=\tiny] {$Y$}}
      child {node[above, font=\tiny] {$Z$}};
    \node[right=.5 of 1,"\tiny $F$" below] (2) {$\bullet$};
  \end{tikzpicture}
  };
\end{tikzpicture}
\]
Here is a tree picture of a lens $\varphi\colon p\to q\tri r$:
\[
	\begin{tikzpicture}[trees,
		level 1/.style={sibling distance=5mm},
	  level 2/.style={sibling distance=5mm}]
    \node["\tiny $A$" below] (1) {$\bullet$} 
      child {coordinate (11')}
      child {coordinate (12')};
    \node[right=2 of 1, blue, "\color{blue} \tiny $C$" below] (1') {$\bullet$}
    	child[blue] {node[red] {$\bullet$}
				child[red] {coordinate (1'1)}
				child[red] {coordinate (1'2)}
			}
		child[blue] {node[red] {$\bullet$}
			}
		child[blue] {node[red] {$\bullet$}
				child[red] {coordinate (1'3)}
				child[red] {coordinate (1'4)}
			}
			;
%
    \node (2) [right=3 of 1',"\tiny $B$" below] {$\bullet$} 
      child {coordinate (21')};
    \node[right=2 of 2, blue,"\color{blue} \tiny $D$" below] (2') {$\bullet$}
			child[blue] {node[red] {$\bullet$}
				child[red] {coordinate (2'1)}
				child[red] {coordinate (2'2)}
			}
			;
%
  \draw[|->, shorten <= 3pt, shorten >= 3pt] (1) -- (1');
  \draw[|->, shorten <= 3pt, shorten >= 3pt] (2) -- (2');
  \begin{scope}[densely dotted, bend right=60pt]
  	\draw[postaction={decorate}] (1'1) to (12');
  	\draw[postaction={decorate}] (1'2) to (11');
  	\draw[postaction={decorate}] (1'3) to (11');
  	\draw[postaction={decorate}] (1'4) to (11');
  	\draw[postaction={decorate}] (2'1) to (21');
  	\draw[postaction={decorate}] (2'2) to (21');
  \end{scope}
\end{tikzpicture}
\]
If we write $\varphi$ as the corresponding triple $(\varphi^q, \varphi^r, \varphi^\sharp)$, then we have
\begin{gather*}
\varphi^q(A)=C,\quad \varphi^q(B)=D;\\
\varphi^r_A(U)=E,\quad \varphi^r_A(V)=F,\quad \varphi^r_A(W)=E;\\
\varphi^r_B(X)=E;\\
\varphi^\sharp_A(U,Y)=S,\quad \varphi^\sharp_A(U,Z)=R,\quad \varphi^\sharp_A(W,Y)=R,\quad \varphi^\sharp_A(W,Z)=R;\\
\varphi^\sharp_B(X,Y)=T,\quad \varphi^\sharp_B(X,Z)=T.
\end{gather*}
Polyboxes display the same data in a different format:
\[
\begin{tikzpicture}[polybox, mapstos, node distance=2ex and 1.4cm]
  \node (a) {
  \begin{tikzpicture}
  	\node[poly, dom] (p) {$S$\at$A$};
  	\node[poly, cod, right= of p.south, yshift=-1ex] (q) {$U$\at$C$};
  	\node[poly, cod, above=of q] (r) {$Y$\at$E$};
  	\draw (p_pos) to[first] (q_pos);
  	\draw (q_dir) to[climb] (r_pos);
  	\draw (r_dir) to[last] (p_dir);
  \end{tikzpicture}
  };
  \node[right=.6 of a] (b) {
  \begin{tikzpicture}
  	\node[poly, dom] (p) {$R$\at$A$};
  	\node[poly, cod, right= of p.south, yshift=-1ex] (q) {$U$\at$C$};
  	\node[poly, cod, above=of q] (r) {$Z$\at$E$};
  	\draw (p_pos) to[first] (q_pos);
  	\draw (q_dir) to[climb] (r_pos);
  	\draw (r_dir) to[last] (p_dir);
  \end{tikzpicture}
  };
  \node[right=.6of b] (c) {
  \begin{tikzpicture}
  	\node[poly, dom] (p) {\at$A$};
  	\node[poly, cod, right= of p.south, yshift=-1ex] (q) {$V$\at$C$};
  	\node[poly, constant, above=of q] (r) {\at$F$};
  	\draw (p_pos) to[first] (q_pos);
  	\draw (q_dir) to[climb] (r_pos);
		\draw[densely dotted] (r_dir) to[last] (p_dir);
  \end{tikzpicture}
  };
  \node[right=.6 of c] (d) {
  \begin{tikzpicture}
  	\node[poly, dom] (p) {$R$\at$A$};
  	\node[poly, cod, right= of p.south, yshift=-1ex] (q) {$W$\at$C$};
  	\node[poly, cod, above=of q] (r) {$Y$\at$E$};
  	\draw (p_pos) to[first] (q_pos);
  	\draw (q_dir) to[climb] (r_pos);
  	\draw (r_dir) to[last] (p_dir);
  \end{tikzpicture}
	};
  \node[right=.6 of d] (e) {
  \begin{tikzpicture}
  	\node[poly, dom] (p) {$R$\at$A$};
  	\node[poly, cod, right= of p.south, yshift=-1ex] (q) {$W$\at$C$};
  	\node[poly, cod, above=of q] (r) {$Z$\at$E$};
  	\draw (p_pos) to[first] (q_pos);
  	\draw (q_dir) to[climb] (r_pos);
  	\draw (r_dir) to[last] (p_dir);
  \end{tikzpicture}
	};
  \node[below=.6 of a] (f) {
  \begin{tikzpicture}
  	\node[poly, dom] (p) {$T$\at$B$};
  	\node[poly, cod, right= of p.south, yshift=-1ex] (q) {$X$\at$D$};
  	\node[poly, cod, above=of q] (r) {$Y$\at$E$};
  	\draw (p_pos) to[first] (q_pos);
  	\draw (q_dir) to[climb] (r_pos);
  	\draw (r_dir) to[last] (p_dir);
  \end{tikzpicture}
	};
  \node[below=.6 of b] (g) {
  \begin{tikzpicture}
  	\node[poly, dom] (p) {$T$\at$B$};
  	\node[poly, cod, right= of p.south, yshift=-1ex] (q) {$X$\at$D$};
  	\node[poly, cod, above=of q] (r) {$Z$\at$E$};
  	\draw (p_pos) to[first] (q_pos);
  	\draw (q_dir) to[climb] (r_pos);
  	\draw (r_dir) to[last] (p_dir);
  \end{tikzpicture}
	};
\end{tikzpicture}
\]
As before, keep in mind that each arrow of a lens depends not only on the box it emerges from, but also on every box that came before it in our usual reading order (lower left to lower right to upper right to upper left).

The third set of polyboxes, where the left blue box has been filled with an $A$ and the lower right blue box has been filled with a $V$, is worth highlighting: as $\varphi^r_A(V)=F$, but $r[F]=\varnothing$, it is impossible to write a direction of $r$ at $F$ to go in the upper right box.
To indicate this, we color the upper right box red and leave the arrow emerging from it dashsed.
\end{example}

% \begin{example}[Using \eqref{eqn.notation_f1f2fk} to denote positions and directions in a composite]\label{ex.pos_in_composite}
% Given polynomials $p_1,\ldots,p_n$, recall from \cref{exc.positions_maps_yon} that the position-set of their composite is isomorphic to the hom-set
% \[
%     \poly(\yon, p_1\tri\cdots\tri p_n),
% \]
% which by \eqref{eqn.lens_to_comp} is in turn isomorphic to
% \[
%     \sum_{i_1\in p_1(\1)}\;\prod_{d_1\in p_1[i_1]}\cdots\sum_{i_n\in p_n(\1)}\;\prod_{d_n\in p_n[i_n]}\1.
% \]

% We can denote $i$ in the notation \eqref{eqn.notation_f1f2fk} as $i=(i_1,\ldots,i_n)$, forgoing the input to $i_1$ because it is always $1\in\1$ and also forgoing $f^\sharp$ because it is always the unique map to $\1$. Then in this notation 
% \begin{gather*}
% i_1\in p_1(\1),\quad
% i_2\colon p_1[i_1]\to p_2(\1),\quad
% i_3\colon (d_1\in p_1[i_1])\to(d_2\in p_2[i_2(d_1)])\to p_3(\1),\\
% i_k\colon(d_1\in p_1[i_1])\to(d_2\in p_2[i_2(d_1)])\to\cdots(d_{k-1}\in p_{k-1}[i_{k-1}(d_1,\ldots,d_{k-2})])\to p_k(\1)
% \end{gather*}

% So for example to give a position in $p\tri q\tri r$ we need 
% \[
% i\in p(\1),\quad
% j\colon p[i]\to q(\1),\quad
% k:(a\in p[i])\to(b\in q[j(a)])\to r(\1).
% \]

% The direction-set of $p_1\tri\cdots\tri p_k$ at position $(i_1,\ldots,i_k)$ is 
% \[
% (p_1\tri\cdots\tri p_k)[(i_1,\ldots,i_k)]\cong\sum_{d_1\in p_1[i_1]}\sum_{d_2\in p_2[i_2(d_1)]}\cdots\sum_{d_k\in p_k[i_k(d_1,\ldots,d_{k-1})]}\1
% \]
% So for example given a position $(i,j,k)\in p\tri q\tri r$, a direction there consists of a tuple $(a,b,c)$ where $a\in p[i]$, $b\in q[j(a)]$ and $f\in r[k(a,b)]$.
% \end{example}

% \begin{exercise}
% Suppose $A_1,\ldots,A_k$ are sets and $p_i\coloneqq A_i\yon$ for each $i$. Use the notation of \cref{ex.pos_in_composite} to give the position-set $p\coloneqq p_1\tri\cdots\tri p_k$.
% \end{exercise}

\begin{example}[Dynamical systems with composite interfaces] \label{ex.dyn_sys_comp_inter}
We explored dynamical systems with product interfaces in \cref{subsec.poly.dyn_sys.new.prod} and parallel product interfaces in \cref{subsec.poly.dyn_sys.new.par}.
How about dynamical systems with composite interfaces?
We now have all the tools we need to characterize them.

By the previous example, a dynamical system $\varphi\colon S\yon^S\to q\tri r$ can be drawn as
\[
\begin{tikzpicture}[polybox, mapstos]
	\node[poly, dom, "$S\yon^S$" left] (p) {$t$\at$s$};
	\node[poly, cod, right=1.5cm of p.south, yshift=-1ex, "$q$" right] (q) {$b$\at$j$};
	\node[poly, cod, above=of q, "$r$" right] (r) {$c$\at$k$};
  	\draw (p_pos) to[first] node[below] {$\varphi^q$} (q_pos);
  	\draw (q_dir) to[climb] node[right] {$\varphi^r$} (r_pos);
  	\draw (r_dir) to[last] node[above] {$\varphi^\sharp$} (p_dir);
\end{tikzpicture}
\]
We can interpret the behavior of this system as follows.
Rather than a single interface $q\tri r$, we view $\varphi$ as having two interfaces that must be interacted with in succession, $q$ followed by $r$.

Given the current state $s\in S$, the system feeds it into $\varphi^q$ to return an output $j$ of the first interface $q$.
Upon receiving an input $b\in q[j]$, it then uses $\varphi^r$ to return another output $k$ (dependent on the state $s$ and the input $b$), this time belonging to the second interface $r$.
Once a second input $c$ is received, this time from $r[k]$, the system updates its state by feeding the current state $s$ and the pair of inputs $(b,c)$ it received into $\varphi^\sharp$, yielding a new state $t\in S$.

That's a lot of words, which is why the polybox picture is so helpful: by following the arrows, we can see that a dynamical system with a composite interface actually captures a very natural type of interaction!
Mixing our metaphors a little, $\varphi$ could model a system that displays cascading menus, where selecting an option $b$ on the first menu $j$ opens up a second menu $k$.
It is only when the interacting agent selects an option $c$ from this second menu that both choices are sent back to the state system, which updates its state accordingly.

All this generalizes to $n$-fold composite interfaces exactly how you'd expect: a dynamical system with interface $q_1\tri\cdots\tri q_n$ produces output and receives input through interface $q_1$, then accordingly produces output and receives input through interface $q_2$, and so on, until it produces output (according to the current state and all previous inputs) and receives input through $q_n$, whereupon it updates its state according to the $n$ inputs it received along with the current state.
\end{example}


\subsection{The composition product of lenses as polyboxes}

A special case of a lens whose codomain is a composite is a lens that is itself the composition product of lenses.
If we draw such a lens using polyboxes by following the instructions from \eqref{eqn.comp_lens_pos} and \eqref{eqn.comp_lens_dir}, we would really just be stacking the polyboxes for the constituent lenses on top of each other.
For example, given lenses $\varphi\colon p\to q$ and $\varphi'\colon p'\to q'$, here is $\varphi\tri \varphi'$ drawn as polyboxes:
\begin{equation} \label{eqn.comp_lens_polybox}
\begin{tikzpicture}[polybox, tos]
	\node[poly, dom, "$p$" left] (p) {};
	\node[poly, dom, above=.8 of p, "$p'$" left] (p') {};
	\node[poly, cod, right=of p, "$q$" right] (q) {};
	\node[poly, cod, above=.8 of q, "$q'$" right] (q') {};
	\draw (p_pos) -- node[below] {$\varphi_\1$} (q_pos);
	\draw (q_dir) -- node[above] {$\varphi^\sharp$} (p_dir);
	\draw (p'_pos) -- node[below] {$\varphi'_\1$} (q'_pos);
	\draw (q'_dir) -- node[above] {$(\varphi')^\sharp$} (p'_dir);	
\end{tikzpicture}
\end{equation}
What differentiates this from simply writing down the polyboxes for $\varphi$ and the polyboxes for $\varphi'$ is that we are explictly associating the position that will fill the lower box of $p'$ with the direction that will fill the upper box of $p$, and likewise the position that will fill the lower box of $q'$ with the direction that will fill the upper box of $q$.
Moreover, we have the user fill out the lower set of boxes first and work their way up, so that, in particular, they can use the information they obtained from the behavior of $\varphi_\1$ and $\varphi^\sharp$ to decide what to put in the lower box of $p'$.
So this really does depict a lens $p\tri p'\to q\tri q'$.

How does \eqref{eqn.comp_lens_polybox} relate to our usual polybox depiction of a lens to a composite, as in \eqref{eqn.map_to_2ary_composite}, but with the domain also replaced with a composite?
A user who interacts with \eqref{eqn.comp_lens_polybox} can fill the lower set of polyboxes (the ones for $\varphi$) first, ignoring the upper set of polyboxes (the ones for $\varphi'$) until the entire lower half is filled.
Alternatively, after they fill in the lower box of $p$, but before they fill in anything else, they can already decide what position to put in the lower box of $p'$ for every possible direction that could end up in the upper box of $p$.
By \eqref{eqn.comp_pos}, such a choice is equivalent to picking a position of the composite $p\tri p'$.
Then by \eqref{eqn.comp_lens_pos}, following just the bottom arrow $\varphi_\1$ leads to the corresponding position of $q$ given by $\varphi\tri \varphi'$, while filling in the upper box of $q$ and following $\varphi^\sharp$, then $\varphi'_\1$ leads to the position of $q'$ that goes in the bottom box of $q'$.
Finally, once the user fills in the upper box of $q'$, following the top arrow $(\varphi')^\sharp$ completes the specification of a direction of $p\tri p'$.
In this way, \eqref{eqn.comp_lens_polybox} can be thought of as a special case of \eqref{eqn.map_to_2ary_composite}.

\begin{example}[Dynamical systems and the composition product, revisited] \label{ex.dyn_sys_comp_polyboxes}
In \cref{subsec.comon.comp.def.dyn_sys}, we explained how the $n$-fold composition product $\varphi\tripow{n}$ of a dynamical system $\varphi\colon S\yon^S\to p$ models the behavior of running through the system $n$ times, provided we choose the positions of $(S\yon^S)\tripow{n}$ appropriately.
We can visualize this behavior using polyboxes---for example, here's what the $n=3$ case looks like:
\[
\begin{tikzpicture}[polybox, mapstos]
	\node[poly, dom, "$S\yon^S$" left] (s) {$s_1$\at$s_0$};
	\node[poly, dom, above=.8 of s, "$S\yon^S$" left] (s') {$s_2$\at$s_1$};
	\node[poly, dom, above=.8 of s', "$S\yon^S$" left] (s'') {$s_3$\at$s_2$};
	
	\node[poly, cod, right=of s, "$p$" right] (p) {$i_1$\at$o_0$};
	\node[poly, cod, above=.75 of p, "$p$" right] (p') {$i_2$\at$o_1$};
	\node[poly, cod, above=.7 of p', "$p$" right] (p'') {$i_3$\at$o_2$};
	
	\draw (s_pos) -- node[below] {return} (p_pos);
	\draw (p_dir) -- node[above] {update} (s_dir);
	
	\draw (s'_pos) -- node[below] {return} (p'_pos);
	\draw (p'_dir) -- node[above] {update} (s'_dir);
	
	\draw (s''_pos) -- node[below] {return} (p''_pos);
	\draw (p''_dir) -- node[above] {update} (s''_dir);
\end{tikzpicture}
\]
It is now patently obvious what $\varphi\tripow3$ does from this picture, as long as we know how to read polyboxes (and we could probably make a pretty good guess even if we didn't!).
This resolves the first issue we raised in \cref{subsec.comon.comp.def.dyn_sys}, page~\pageref{subsubsec.comon.comp.def.dyn_sys.issues}: we now have a concise way of depicting the $n$-fold composite of a dynamical system.
The second issue becomes clear when we look at which boxes are blue along the left: we would really like the position $s_1$ to be entered above the direction $s_1$ automatically, the $s_2$ entered above $s_2$ automatically, etc.\ rather than having to specify the contents of those blue boxes manually.
We shouldn't even having the option to fill those blue boxes in with anything else.
We'll see how to address this issue shortly in \cref{ex.dyn_sys_trans_polyboxes}.
\end{example}

We make a big deal out of it, but \eqref{eqn.comp_lens_polybox} really is just the polyboxes of two separate lenses drawn together.
Where such polyboxes truly get interesting is when we compose them with polyboxes that look like \eqref{eqn.map_to_2ary_composite}.
That is, given a lens $g\colon r\to p\tri p'$, consider the polyboxes for $g\then(f\tri f')$:
\[
\begin{tikzpicture}[polybox, tos]
	\node[poly, dom, "$r$" left] (r) {};
	\node[poly, right=1.8 of r.south, yshift=-2.5ex, "$p$" below] (p) {};
	\node[poly, above=.8 of p, "$p'$" above] (p') {};
	\node[poly, cod, right=of p, "$q$" right] (q) {};
	\node[poly, cod, above=.8 of q, "$q'$" right] (q') {};
	\draw (p_pos) -- node[below] {$f_\1$} (q_pos);
	\draw (q_dir) -- node[above] {$f^\sharp$} (p_dir);
	\draw (p'_pos) -- node[below] {$f'_\1$} (q'_pos);
	\draw (q'_dir) -- node[above] {$(f')^\sharp$} (p'_dir);	
	\draw (r_pos) to[first] node[below] {$g^{p}$} (p_pos);
	\draw (p_dir) to[climb] node[right] {$g^{p'}$} (p'_pos);
	\draw (p'_dir) to[last] node[above] {$g^\sharp$} (r_dir);
\end{tikzpicture}
\]
There's a lot going on with this lens! To fill out these polyboxes, we start from the lower box of $r$, go all the way right to the lower box of $q$, loop back left, up, and right again to the lower box of $q'$, then travel left all the way back to the upper box of $r$.

Say we knew that $g\then(f\tri f')$ were equal to some other lens $h\colon r\to q\tri q'$:
\[
\begin{tikzpicture}
	\node (1) {
  \begin{tikzpicture}[polybox, mapstos]
	\node[poly, dom, "$r$" left] (r) {\at$k$};
	\node[poly, right=1.8 of r.south, yshift=-2.5ex, "$p$" below] (p) {};
	\node[poly, above=.8 of p, "$p'$" above] (p') {};
	\node[poly, cod, right=of p, "$q$" right] (q) {$b$};
	\node[poly, cod, above=.8 of q, "$q'$" right] (q') {$b'$};
	\draw (p_pos) -- node[below] {$f_\1$} (q_pos);
	\draw (q_dir) -- node[above] {$f^\sharp$} (p_dir);
	\draw (p'_pos) -- node[below] {$f'_\1$} (q'_pos);
	\draw (q'_dir) -- node[above] {$(f')^\sharp$} (p'_dir);	
	\draw (r_pos) to[first] node[below] {$g^{p}$} (p_pos);
	\draw (p_dir) to[climb] node[right] {$g^{p'}$} (p'_pos);
	\draw (p'_dir) to[last] node[above] {$g^\sharp$} (r_dir);
  \end{tikzpicture}
	};
	\node[right=1.8 of 1] (2) {
  \begin{tikzpicture}[polybox, mapstos]
  	\node[poly, dom, "$r$" left] (r) {\at$k$};
  	\node[poly, cod, right=1.8 of r.south, yshift=-1ex, "$q$" right] (q) {$b$};
  	\node[poly, cod, above=of q, "$q'$" right] (q') {$b'$};
  	\draw (r_pos) to[first] node[below] {$h^q$} (q_pos);
  	\draw (q_dir) to[climb] node[right] {$h^{q'}$} (q'_pos);
  	\draw (q'_dir) to[last] node[above] {$h^\sharp$} (r_dir);
  \end{tikzpicture}
	};
	\node at ($(1.east)!.5!(2.west)$) {=};
\end{tikzpicture}
\]

We've filled in the corresponding blue boxes on either side of the equation with the same entries.
So if these two sets of polyboxes really do depict the same lens, each of the three white boxes in the domain and codomain on the left should end up with the same entry as the corresponding white box on the right (although the intermediary mechanics may differ).
Then if we follow the arrows in order on either side, matching up the white boxes in the domain and codomain along the way, we can read off three equations:
\[
    g^p\then f_\1 = h^q, \qquad f^\sharp_{g^p(k)}\then g^{p'}_k\then f'_\1 = h^{q'}_k, \qqand (f')^\sharp_{g^{p'}\left(f^\sharp_{g^p(k)}(b)\right)}\then g^\sharp_k = h^\sharp_k.
\]
The converse holds as well: if the three equations above all hold, then $g\then(f\tri f')=h$.
We will read equations off of polyboxes like this repeatedly in the rest of the book.%, including in the following example.

\begin{example}[Transition lenses for state systems] \label{ex.dyn_sys_trans_polyboxes}

In \cref{ex.dyn_sys_comp_polyboxes}, we saw that the $2$-fold composition product $\varphi\tripow2$ of a dynamical system $\varphi\colon S\yon^S\to p$ can be drawn as follows:
\[
\begin{tikzpicture}[polybox, mapstos]
	\node[poly, dom, "$S\yon^S$" left] (s) {$s_1$\at$s_0$};
	\node[poly, dom, above=.8 of s, "$S\yon^S$" left] (s') {$s_2$\at$s_1$};

	\node[poly, cod, right=of s, "$p$" right] (p) {$i_1$\at$o_0$};
	\node[poly, cod, above=.75 of p, "$p$" right] (p') {$i_2$\at$o_1$};

	\draw (s_pos) -- node[below] {return} (p_pos);
	\draw (p_dir) -- node[above] {update} (s_dir);
	
	\draw (s'_pos) -- node[below] {return} (p'_pos);
	\draw (p'_dir) -- node[above] {update} (s'_dir);
\end{tikzpicture}
\]
This \emph{almost} models the behavior of running through the system twice, except that we should really only have one blue box on the domain side---the one we fill with the initial state $s_0$.
The second blue box on the domain side, the one we fill with $s_1$, should instead be filled automatically with the same state as the direction $s_1$ in the white box below it.

In fact, it would be nice if the domain were still just $S\yon^S$.
Then we would have a lens $S\yon^S\to p\tri p$ that takes an initial state $s_0\in S$ and runs the original system $\varphi$ twice, returning two outputs and receiving two inputs before stopping at the new state $s_2$.
But we just learned how to take a composition product of lenses such as $\varphi\tripow2\colon S\yon^S\tri S\yon^S\to p\tri p$ and convert its domain to a new polynomial, say $S\yon^S$, with only one blue box on the domain side---just compose it with another lens $S\yon^S\to S\yon^S\tri S\yon^S$ like so:
\[
\begin{tikzpicture}
	\node (1) {
  \begin{tikzpicture}[polybox, mapstos]
	\node[poly, dom, "$S\yon^S$" left] (r) {$s_2$\at$s_0$};
	\node[poly, right=1.8 of r.south, yshift=-2.5ex, "$S\yon^S$" below] (p) {$s_1$\at$s_0$};
	\node[poly, above=.8 of p, "$S\yon^S$" above] (p') {$s_2$\at$s_1$};
	\node[poly, cod, right=of p, "$p$" right] (q) {$i_1$\at$o_0$};
	\node[poly, cod, above=.75 of q, "$p$" right] (q') {$i_2$\at$o_1$};
	\draw (p_pos) -- node[below] {return} (q_pos);
	\draw (q_dir) -- node[above] {update} (p_dir);
	\draw (p'_pos) -- node[below] {return} (q'_pos);
	\draw (q'_dir) -- node[above] {update} (p'_dir);	
	\draw (r_pos) to[first] node[below] {} (p_pos);
	\draw (p_dir) to[climb] node[right] {} (p'_pos);
	\draw (p'_dir) to[last] node[above] {} (r_dir);
  \end{tikzpicture}
	};
	\node[right=1.8 of 1] (2) {
  \begin{tikzpicture}[polybox, mapstos]
  	\node[poly, dom, "$S\yon^S$" left] (r) {$s_2$\at$s_0$};
  	\node[poly, cod, right=1.8 of r.south, yshift=-1ex, "$p$" right] (q) {$i_1$\at$o_0$};
  	\node[poly, cod, above=of q, "$p$" right] (q') {$i_2$\at$o_1$};
  	\draw (r_pos) to[first] node[below] {} (q_pos);
  	\draw (q_dir) to[climb] node[right] {} (q'_pos);
  	\draw (q'_dir) to[last] node[above] {} (r_dir);
  \end{tikzpicture}
	};
	\node at ($(1.east)!.5!(2.west)$) {=};
\end{tikzpicture}
\]
We'll denote our new lens $S\yon^S\to S\yon^S\tri S\yon^S$ on the far left by $\delta$.
Let's take a closer look at how $\delta$ behaves on its own, labeling its arrows for ease of reference:
\[
\begin{tikzpicture}[polybox, mapstos]
	\node[poly, dom, "$S\yon^S$" left] (r) {$s_2$\at$s_0$};
	\node[poly, cod, right=1.8 of r.south, yshift=-2.5ex, "$S\yon^S$" below] (p) {$s_1$\at$s_0$};
	\node[poly, cod, above=.8 of p, "$S\yon^S$" above] (p') {$s_2$\at$s_1$};

	\draw[double, -] (r_pos) to[first] node[below] {$\delta_0$} (p_pos);
	\draw (p_dir) to[climb] node[right] {$\delta_1$} (p'_pos);
	\draw (p'_dir) to[last] node[above] {$\delta_2$} (r_dir);
  \end{tikzpicture}
\]
We can see from this picture that $\delta$ arises very naturally from the structure of $S\yon^S$; indeed, every state system can be equipped with such a lens, just as every state system can be equipped with a do-nothing enclosure from \cref{ex.do_nothing}.
The bottom arrow $\delta_0\colon S\to S$ sending $s_0\mapsto s_0$ is the identity on the position-set $S$: it sends each state to itself.
We use a double arrow to denote this equality.
While the middle arrow $\delta_1$ also looks like an identity arrow, remember that we should think of it as depending on the left blue box as well; so it is really a function $\delta_1\colon S\times S\to S$ sending $(s_0,s_1)$, a position-state $s_0$ and a direction at $s_0$ corresponding to state $s_1$, to the new position-state $s_1$.
Similarly, $\delta_2\colon S\times S\times S\to S$ sends $(s_0,s_1,s_2)$, where the last coordinate is the direction at position-state $s_1$ corresponding to state $s_2$, to the direction at position-state $s_0$ that also corresponds to state $s_2$.

Notice the crucial role that $\delta_1$ plays here: it matches up every direction at a given state to the new state that the direction in question should point to, encoding how the state system transitions from one state to the next.
We have been labeling each direction by the state that it points to, but we should really think of all the directions of $S\yon^S$ as pairs of position-states $(s,t)\in S\times S$, where $(s,t)$ is a direction at $s$ that represents the transition from state $s$ to state $t$.
The structure of the polynomial $S\yon^S$ tells us the state that each direction transitions from, but it is $\delta_1$ that tells us the new state $\delta_1(s,t)=t$ that $(s,t)$ transitions to.
For that reason, we call $\delta$ the \emph{transition lens} of the state system $S\yon^S$, and we call $\delta_1\colon S\times S\to S$ the \emph{target function}, relabeling it tgt for short, indicating where each direction leads.

This is exactly what we wanted back in \cref{ex.do_nothing}: a way to encode which directions of a state system point to which positions in the language of $\poly$. Expressions in that language are lenses such as $\delta$, and polyboxes like the ones above are the way we write them down.

We highlighted $\delta_1$ above, but the arrows $\delta_0$ and $\delta_2$ are no less important.
As an identity function, $\delta_0=\id_S$ remembers the initial state $s_0$ as we shift from its original setting $S\yon^S$, where we can only move one state away from $s_0$, to a new setting $S\yon^S\tri S\yon^S$, where we can think about all the ways to move two states away from $s_0$.
Meanwhile, $\delta_2$ shifts us from the two-state setting back to the one-state setting while ensuring a sort of transitive coherence condition: the state where we end up after moving from $s_0$ through $s_1$ to $s_2$ is the same state we would end up at if we had moved from $s_0$ directly to $s_2$.
We will call it the \emph{run function}, because it runs a sequence of two transitions together, and because it is what keeps the system running as it tells the original state system to actually move along one of its directions.

Here is another picture of the transition lens $\delta$ of $S\yon^S$ with our new arrow names:
\[
\begin{tikzpicture}[polybox, mapstos]
	\node[poly, dom, "$S\yon^S$" left] (r) {$s_2$\at$s_0$};
	\node[poly, cod, right=1.8 of r.south, yshift=-2.5ex, "$S\yon^S$" below] (p) {$s_1$\at$s_0$};
	\node[poly, cod, above=.8 of p, "$S\yon^S$" above] (p') {$s_2$\at$s_1$};

	\draw[double, -] (r_pos) to[first] node[below=.3] {$\id_S$} (p_pos);
	\draw (p_dir) to[climb] node[right] {tgt} (p'_pos);
	\draw (p'_dir) to[last] node[above=.4] {run} (r_dir);
  \end{tikzpicture}
\]
This resolves the second issue we raised in \cref{subsec.comon.comp.def.dyn_sys}, page~\pageref{subsubsec.comon.comp.def.dyn_sys.issues} for the case of $n=2$, giving us a dynamical system $\delta\then(\varphi\tri\varphi)\colon S\yon^S\to p\tri p$ that simulates stepping through the system $\varphi$ twice.
But what about more general values of $n$?

We already have a way of talking about the $n=0$ case: that is what the do-nothing enclosure $\epsilon\colon S\yon^S\to\yon$ models.
But there is some overlap in how $\epsilon$ matches up state-positions with directions and how $\delta$ does.
Put another way, if $\epsilon$ tells us how to do nothing, and $\delta$ tells us how to do two things, then we had better check that if one of the two things we do is nothing, then that's the same as doing just one thing.
Can we ensure that $\epsilon$ and $\delta$ agree on what they are saying about our state system?

Then for $n=3$, we would like a dynamical system $S\yon^S\to p\tri p\tri p$ that simulates stepping through $\varphi$ three times.
One way to do this would be to compose $\varphi\tripow3$ with a lens of the form $S\yon^S\to\left(S\yon^S\right)\tripow3$ that we obtain by extending $\delta$ from modeling two-step transitions to three-step transitions.
But there are two ways to derive a lens with codomain $\left(S\yon^S\right)\tripow3$ from $\delta$: we could either take $\delta\then\left(\delta\tri\id_{S\yon^S}\right)$, or we could take $\delta\then\left(\id_{S\yon^S}\tri\delta\right)$
For larger values of $n$, there are even more possibilities for what we could do.
But there should really only be one dynamical system that models stepping through $\varphi$ a fixed number of times.
How do we guarantee that all these different ways of extending $\delta$ to $n$-step transitions end up telling us the same thing?

In summary, we need some kind of compatibility condition between $\epsilon$ and $\delta$, as well as some kind of associativity condition on $\delta$ to guarantee that it can be extended coherently.
In fact, we already have all the tools we need to characterize these conditions: we'll see exactly how to state the properties we want in the next chapter.
And if this is all starting to sound suspiciously familiar, youre not wrongbut well save that surprise for the next chapter as well.
\end{example}

\begin{exercise}
Let $S\coloneqq\nn$ and $p\coloneqq\rr\yon^\1$, and define $\varphi\colon S\yon^S\to p$ to be the dynamical system with return function $\varphi_\1(k)\coloneqq k$ and update function $\varphi^\sharp_k(1)\coloneqq k+1$.
\begin{enumerate}
    \item Draw the polyboxes for $\varphi$ and describe its dynamics: what does $1$ run through the system look like?
    \item Let $\delta\colon S\yon^S\to S\yon^S\tri S\yon^S$ be the transition lens of $S\yon^S$, and draw the polyboxes for the new system $\delta\then(\varphi\tri\varphi)\colon S\yon^S\to p\tri p$.
    Describe its dynamics: how does it model $2$ runs through the system? \qedhere
\end{enumerate}

\begin{solution}
Given $S\coloneqq\nn$ and $p\coloneqq\rr\yon^\1$, we have a dynamical system $\varphi\colon S\yon^S\to p$ given by $\varphi_\1(k)\coloneqq k$ and $\varphi^\sharp_k(1)\coloneqq k+1$.
\begin{enumerate}
    \item Here is the polybox picture for $\varphi$ (recall that we shade the upper box of a linear polynomial gray, as there is only one option to place there):
    \[
    \begin{tikzpicture}[polybox, mapstos]
		\node[poly, dom, "$S\yon^S$" left] (S) {$k+1$\at$k$};
		\node[poly, right=of S, linear, "$p$" right] (p) {$\vphantom{k}$\at$k$};
%
		\draw (S_pos) to[first] (p_pos);
		\draw (p_dir) to[last ] (S_dir);
    \end{tikzpicture}
    \]
    A single run through the system returns the current state $k\in\nn$, then increases that state by $1$.
    \item Here is the polybox picture for $\delta\then(\varphi\tri\varphi)\colon S\yon^S\to p\tri p$:
    \[
    \begin{tikzpicture}[polybox, mapstos]
		\node[poly, dom, "$S\yon^S$" left] (S) {$k+2$\at$k$};
		
    	\node[poly, cod, right=1.8 of S.south, yshift=-2.5ex, "$S\yon^S$" below] (S1) {$k+1$\at$k$};
    	\node[poly, cod, above=.8 of S1, "$S\yon^S$" above] (S2) {$k+2$\at$k+1$};
    	
		\node[poly, linear, right=of S1, "$p$" right] (p1) {$\vphantom{k}$\at$k$};
		\node[poly, linear, right=of S2, "$p$" right] (p2) {$\vphantom{k}$\at$k+1$};
%
		\draw (S1_pos) to[first] (p1_pos);
		\draw (p1_dir) to[last] (S1_dir);		
		\draw (S2_pos) to[first] (p2_pos);
		\draw (p2_dir) to[last]  (S2_dir);	
		
		\draw (S_pos) to[first] (S1_pos);
		\draw (S1_dir) to[climb] (S2_pos);
		\draw (S2_dir) to[last] (S_dir);
    \end{tikzpicture}
    \]
    The new system has $p\tri p\iso\rr\yon\tri\rr\yon\iso\rr^\2\yon$ as its interface.
    Indeed, we see that it returns two numbers at once: the current state $k$ (what the first run through $\varphi$ would return) as well as the increased state $k+1$ (what the second run through $\varphi$ would return).
    We update the current state from $k$ to $k+1$ in one run, and from $k+1$ to $k+2$ in the next---thus increasing the current state by $2$ overall.
\end{enumerate}
\end{solution}
\end{exercise}

\begin{exercise}
As a lens whose domain is a state system, the transition lens $\delta\colon S\yon^S\to S\yon^S\tri S\yon^S$ of a state system $S\yon^S$ can be interpreted as a standalone dynamical system. Describe the dynamics of this system.
\begin{solution}
We give two reasonable (and of course equivalent) ways to interpret the transition lens $\delta\colon S\yon^S\to S\yon^S\tri S\yon^S$.

One way is to first evaluate its interface as $S\yon^S\tri S\yon^S\iso S\!\left(S\yon^S\right)^S\iso\left(S\times S^S\right)\yon^{S\times S}$.
Then we see that if the current state is $s_0\in S$, the system returns a position consisting of that current state $s_0$ along with a function $S\to S$, namely the identity function $s_1\mapsto s_1$.
The system then takes in a pair $(s_1,s_2)\in S\times S$, discarding $s_1$ and setting its new state to be $s_2$.

Alternatively, we can draw from \cref{ex.dyn_sys_comp_inter} to interpret $\delta$ as a dynamical system that behaves as follows.
Each run through the system is a $2$-step process: first, the current state $s_0\in S$ is returned, and a new state $s_1\in S$ is received.
Then this new state $s_1$ is immediately returned, and an ever newer state $s_2\in S$ is received.
Then the current state is updated to the newer state $s_2$.
\end{solution}
\end{exercise}

%-------- Section --------%
\section{Categorical properties of the composition product} \label{sec.comon.comp.prop}

We conclude this chapter by discussing several interesting properties of the composition product, many of which will come in handy in the following chapters.
We'll focus on how $\tri$ interacts with other constructions on $\poly$ that we introduced in previous chapters.

\subsection{Interaction with products and coproducts} \label{subsec.comon.comp.prop.prod}

It turns out that the composition product behaves well---albeit asymmetrically---with products and coproducts.

\begin{proposition}[Left distributivity of $\tri$ over $+$ and $\times$]\label{prop.left_dist_prod}
Given a polynomial $r$, the functor $(-\tri r)\colon\poly\to\poly$ that sends each $p\in\poly$ to $p\tri r$ commutes with coproducts and products (up to natural isomorphism).
That is, for any $p,q\in\poly$, we have the following natural isomorphisms:
\begin{equation}\label{eqn.comp_left_pres_plus}
    (p+q)\tri r\iso (p\tri r)+(q\tri r)
\end{equation}
and
\begin{equation}\label{eqn.comp_left_pres_times}
    pq\tri r\iso (p\tri r)(q\tri r).
\end{equation}
More generally, given a set $A$ and polynomials $(q_a)_{a\in A}$, we have the following natural isomorphisms:
\begin{equation}\label{eqn.comp_left_pres_sum}
    \left(\sum_{a\in A}q_a\right)\tri r\iso \sum_{a\in A} (q_a\tri r)
\end{equation}
and
\begin{equation}\label{eqn.comp_left_pres_prod}
    \left(\prod_{a\in A}q_a\right)\tri r\iso \prod_{a\in A} (q_a\tri r)
\end{equation}
\end{proposition} 
\begin{proof}
Formally, this comes down to the fact that (co)products of functors $\smset\to\smset$ are computed pointwise (\cref{prop.presheaf_lim_ptwise}) and that (co)products in $\poly$ coincide with (co)products in $\smset^\smset$ (\cref{prop.poly_coprods,prop.poly_prods}).
One could instead give an explicit proof using \eqref{eqn.composite_formula}; this is done in \cref{exc.left_dist}.
In fact, we will see yet another proof of \eqref{eqn.comp_left_pres_prod} (and thus \eqref{eqn.comp_left_pres_times}) in \cref{exc.comp_left_pres_lim} \cref{exc.comp_left_pres_lim.prod}.
\end{proof}

\begin{exercise}\label{exc.left_dist}
Prove \cref{prop.left_dist_prod} using the explicit formula for $\tri$ given in \eqref{eqn.composite_formula} by manipulating sums and products.
\begin{solution}
To prove \cref{prop.left_dist_prod}, it suffices to verify \eqref{eqn.comp_left_pres_sum} and \eqref{eqn.comp_left_pres_prod}, as \eqref{eqn.comp_left_pres_plus} and \eqref{eqn.comp_left_pres_times} follow directly when $A\coloneqq\2$.

Given polynomials $(q_a)_{a\in A}$, recall that the position-set of the sum $\sum_{a\in A}q_a$ is $\sum_{a\in A}q_a(\1)$, while the direction-set at each position $(a,j)$ with $a\in A$ and $j\in q_a(\1)$ is $q_a[j]$.
So by \eqref{eqn.composite_formula}, we have that
\begin{align*}
    \left(\sum_{a\in A}q_a\right)\tri r &\iso \sum_{\substack{a\in A, \\ j\in q_a(\1)}}\;\prod_{b \in q_a[j]}\;\sum_{k \in r(\1)}\;\prod_{c \in r[k]}\yon \\
    &\iso \sum_{a\in A}\;\sum_{j\in q_a(\1)}\;\prod_{b \in q_a[j]}\;\sum_{k \in r(\1)}\;\prod_{c \in r[k]}\yon \\
    &\iso\sum_{a\in A}(q_a\tri r).
\end{align*}
We can also recall that the position-set of the product $\prod_{a\in A}q_a$ is $\prod_{a\in A}q_a(\1)$, while the direction-set at each position $\ol{j}\colon(a\in A)\to q_a(\1)$ is $\sum_{a\in A}q_a[\ol{j}(a)]$.
So by \eqref{eqn.composite_formula}, we have that
\begin{align*}
    \left(\prod_{a\in A}q_a\right)\tri r &\iso \sum_{\ol{j}\in\prod_{a\in A}q_a(\1)} \; \prod_{\substack{a\in A, \\ b\in q_a[\ol{j}(a)]}} \; \sum_{k \in r(\1)} \; \prod_{c \in r[j]} \yon \\
    &\iso \prod_{a\in A} \; \sum_{j\in q_a(\1)} \; \prod_{b\in q_a[j]} \; \sum_{k \in r(\1)} \; \prod_{c \in r[k]} \yon \tag*{\eqref{eqn.cat_completely_distributive}} \\
    &\iso\prod_{a\in A}(q_a\tri r).
\end{align*}
\end{solution}
\end{exercise}

\begin{example}[Picturing the left distributivity of $\tri$ over $\times$]\label{ex.picturing_dist}
We want an intuitive understanding of the left distributivity given by \eqref{eqn.comp_left_pres_times}.
Let $p\coloneqq\yon$, $q\coloneqq\yon+\1$, and $r\coloneqq\yon^\2+\1$, as shown here:
\[
\begin{tikzpicture}[rounded corners]
	\node (p) [draw, blue!50!black, "$p$" above] {
	\begin{tikzpicture}[trees, sibling distance=2.5mm]
    \node (p1) {$\bullet$} 
      child {};
  \end{tikzpicture}
  };
	\node (q) [draw, blue!50!black, right=1 of p, "$q$" above] {
	\begin{tikzpicture}[trees, sibling distance=2.5mm]
    \node (q1) {$\bullet$} 
      child {};
    \node[right=.5 of q1] (q2) {$\bullet$};
  \end{tikzpicture}
  };
	\node (r) [draw, red!75!black, right=1 of q, "$r$" above] {
	\begin{tikzpicture}[trees, sibling distance=2.5mm]
    \node (r1) {$\bullet$} 
      child {}
      child {};
    \node[right=.5 of r1] (r2) {$\bullet$};
  \end{tikzpicture}
  };
\end{tikzpicture}
\]
Then $pq\cong\yon^\2+\yon$ can be drawn as follows, with each corolla comprised of a $p$-corolla and a $q$-corolla with their roots glued together:
\[
\begin{tikzpicture}[rounded corners]
	\node (p) [draw, blue!50!black, "$pq\cong$" left] {
	\begin{tikzpicture}[trees, sibling distance=2.5mm]
        \node (q1) {$\bullet$}
          child {}
          child {};
        \node[right=.5 of q1] (q2) {$\bullet$}
          child {};
    \end{tikzpicture}
	};
\end{tikzpicture}
\]
We can therefore draw $pq\tri r$ by gluing $r$-corollas to leaves of $pq$ in every way, as follows:
\[
\begin{tikzpicture}[rounded corners]
	\node (p) [draw, "$pq\tri r\cong$" left] {
	\begin{tikzpicture}[trees,
		level 1/.style={sibling distance=5mm},
	  level 2/.style={sibling distance=2.5mm}]
    \node[blue!50!black] (1) {$\bullet$} 
      child[blue!50!black] {node[red!75!black] {$\bullet$} 
      	child[red!75!black]
				child[red!75!black]
			}
      child[blue!50!black] {node[red!75!black] {$\bullet$} 
      	child[red!75!black]
				child[red!75!black]
			};
%
    \node[blue!50!black, right=1.3 of 1] (2) {$\bullet$} 
      child[blue!50!black] {node[red!75!black] {$\bullet$} 
				child[red!75!black]
				child[red!75!black]
			}
      child[blue!50!black] {node[red!75!black] {$\bullet$} 
			};
%
    \node[blue!50!black, right=1.3 of 2] (3) {$\bullet$} 
      child[blue!50!black] {node[red!75!black] {$\bullet$} 
			}
      child[blue!50!black] {node[red!75!black] {$\bullet$} 
				child[red!75!black]
				child[red!75!black]
			};
%
    \node[blue!50!black, right=1.3 of 3] (4) {$\bullet$} 
      child[blue!50!black] {node[red!75!black] {$\bullet$} 
			}
      child[blue!50!black] {node[red!75!black] {$\bullet$} 
			};
%
    \node[blue!50!black, right=1 of 4] (5) {$\bullet$} 
      child[blue!50!black] {node[red!75!black] {$\bullet$} 
      	child[red!75!black]
      	child[red!75!black]
			};
%
    \node[blue!50!black, right=.8 of 5] (6) {$\bullet$} 
      child[blue!50!black] {node[red!75!black] {$\bullet$}
      };
  \end{tikzpicture}
	};
\end{tikzpicture}
\]
So each tree in $pq\tri r$ is obtained by gluing together the roots of a $p$-corolla and a $q$-corolla, then attaching $r$-corollas to each leaf.

Alternatively, we can compute $p\tri r$ and $q\tri r$ seperately, gluing $r$-corollas to leaves of $p$ in every way, then to leaves of $q$ in every way:
\[
\begin{tikzpicture}[rounded corners]
	\node (p) [draw, "$p\tri r\cong$" left] {
	\begin{tikzpicture}[trees,
		level 1/.style={sibling distance=5mm},
	  level 2/.style={sibling distance=2.5mm}]
    \node[blue!50!black] (p1) {$\bullet$} 
      child[blue!50!black] {node[red!75!black] {$\bullet$} 
      	child[red!75!black]
				child[red!75!black]
			};
    \node[blue!50!black, right=.5 of p1] (p2) {$\bullet$} 
      child[blue!50!black] {node[red!75!black] {$\bullet$} 
			};
  \end{tikzpicture}
  };
%
	\node (q) [draw, "$q\tri r\cong$" left] at (4,0) {
	\begin{tikzpicture}[trees,
		level 1/.style={sibling distance=5mm},
	  level 2/.style={sibling distance=2.5mm}]
    \node[blue!50!black] (q1) {$\bullet$} 
      child[blue!50!black] {node[red!75!black] {$\bullet$} 
      	child[red!75!black]
				child[red!75!black]
			};
    \node[blue!50!black, right=.5 of q1] (q2) {$\bullet$} 
      child[blue!50!black] {node[red!75!black] {$\bullet$} 
			};
    \node[blue!50!black, right=.5 of q2] (q3) {$\bullet$};		
  \end{tikzpicture}
  };
\end{tikzpicture}
\]
Their product is then obtained by taking each tree from $p\tri r$ and pairing it with each tree from $q\tri r$ by gluing their roots together:
\[
\begin{tikzpicture}[rounded corners]
	\node (p) [draw, "$(p\tri q)(p\tri r)\cong$" left] {
	\begin{tikzpicture}[trees,
		level 1/.style={sibling distance=5mm},
	  level 2/.style={sibling distance=2.5mm}]
    \node[blue!50!black] (1) {$\bullet$} 
      child[blue!50!black] {node[red!75!black] {$\bullet$} 
      	child[red!75!black]
				child[red!75!black]
			}
      child[blue!50!black] {node[red!75!black] {$\bullet$} 
      	child[red!75!black]
				child[red!75!black]
			};
%
    \node[blue!50!black, right=1.3 of 1] (2) {$\bullet$} 
      child[blue!50!black] {node[red!75!black] {$\bullet$} 
				child[red!75!black]
				child[red!75!black]
			}
      child[blue!50!black] {node[red!75!black] {$\bullet$} 
			};
%
    \node[blue!50!black, right=1 of 2] (3) {$\bullet$} 
      child[blue!50!black] {node[red!75!black] {$\bullet$} 
      	child[red!75!black]
      	child[red!75!black]
			};
%
    \node[blue!50!black, right=1 of 3] (4) {$\bullet$} 
      child[blue!50!black] {node[red!75!black] {$\bullet$} 
			}
      child[blue!50!black] {node[red!75!black] {$\bullet$} 
				child[red!75!black]
				child[red!75!black]
			};
%
    \node[blue!50!black, right=1.3 of 4] (5) {$\bullet$} 
      child[blue!50!black] {node[red!75!black] {$\bullet$} 
			}
      child[blue!50!black] {node[red!75!black] {$\bullet$} 
			};
%
    \node[blue!50!black, right=.8 of 5] (6) {$\bullet$} 
      child[blue!50!black] {node[red!75!black] {$\bullet$}
      };	  	
	\end{tikzpicture}
	};
\end{tikzpicture}
\]
So each tree in $(p\tri r)(q\tri r)$ is obtained by attaching $r$-corollas to each leaf of a $p$-corolla and a $q$-corolla before gluing their roots together.

But it doesn't matter if we glue $r$-corollas to leaves first, or if we glue the roots of $p$- and $q$-corollas together first--the processes are equivalent.
Hence the isomorphism $pq\tri r\iso(p\tri r)(q\tri r)$ holds.
\end{example}

\begin{exercise}\label{exc.picturing_dist}
Follow \cref{ex.picturing_dist} with coproducts $(+)$ in place of products $(\times)$: use pictures to give an intuitive understanding of the left distributivity given by \eqref{eqn.comp_left_pres_plus}.
\begin{solution}
We want an intuitive understanding of the left distributivity of $\tri$ over $+$.
Let $p\coloneqq\yon^\2$, $q\coloneqq\yon+\1$, and $r\coloneqq\yon^\2+\1$, as shown here:
\[
\begin{tikzpicture}[rounded corners]
	\node (p) [draw, green!50!black, "$p$" above] {
	\begin{tikzpicture}[trees, sibling distance=2.5mm]
    \node (p1) {$\bullet$} 
      child {}
      child {};
  \end{tikzpicture}
  };
	\node (q) [draw, blue!50!black, right=1 of p, "$q$" above] {
	\begin{tikzpicture}[trees, sibling distance=2.5mm]
    \node (q1) {$\bullet$} 
      child {};
    \node[right=.5 of q1] (q2) {$\bullet$};
  \end{tikzpicture}
  };
	\node (r) [draw, red!75!black, right=1 of q, "$r$" above] {
	\begin{tikzpicture}[trees, sibling distance=2.5mm]
    \node (r1) {$\bullet$} 
      child {}
      child {};
    \node[right=.5 of r1] (r2) {$\bullet$};
  \end{tikzpicture}
  };
\end{tikzpicture}
\]
Then $p+q\iso\yon^\2+\yon+\1$ can be drawn as follows, consisting of every $p$-corolla and every $q$-corolla:
\[
\begin{tikzpicture}[rounded corners]
	\node (p) [draw, "$p+q\iso$" left] {
	\begin{tikzpicture}[trees, sibling distance=2.5mm]
        \node[green!50!black] (q1) {$\bullet$}
          child[green!50!black] {}
          child[green!50!black] {};
        \node[blue!50!black, right=.5 of q1] (q2) {$\bullet$}
          child[blue!50!black] {};
        \node[blue!50!black, right=.5 of q2] (q3) {$\bullet$};
    \end{tikzpicture}
	};
\end{tikzpicture}
\]
We can therefore draw $(p+q)\tri r$ by gluing $r$-corollas to leaves of $p+q$ in every way, as follows:
\[
\begin{tikzpicture}[rounded corners]
	\node (p) [draw, "$(p+q)\tri r\cong$" left] {
	\begin{tikzpicture}[trees,
		level 1/.style={sibling distance=5mm},
	  level 2/.style={sibling distance=2.5mm}]
    \node[green!50!black] (1) {$\bullet$} 
      child[green!50!black] {node[red!75!black] {$\bullet$} 
      	child[red!75!black]
				child[red!75!black]
			}
      child[green!50!black] {node[red!75!black] {$\bullet$} 
      	child[red!75!black]
				child[red!75!black]
			};
%
    \node[green!50!black, right=1.3 of 1] (2) {$\bullet$} 
      child[green!50!black] {node[red!75!black] {$\bullet$} 
				child[red!75!black]
				child[red!75!black]
			}
      child[green!50!black] {node[red!75!black] {$\bullet$} 
			};
%
    \node[green!50!black, right=1.3 of 2] (3) {$\bullet$} 
      child[green!50!black] {node[red!75!black] {$\bullet$} 
			}
      child[green!50!black] {node[red!75!black] {$\bullet$} 
				child[red!75!black]
				child[red!75!black]
			};
%
    \node[green!50!black, right=1.3 of 3] (4) {$\bullet$} 
      child[green!50!black] {node[red!75!black] {$\bullet$} 
			}
      child[green!50!black] {node[red!75!black] {$\bullet$} 
			};
%
    \node[blue!50!black, right=1 of 4] (5) {$\bullet$} 
      child[blue!50!black] {node[red!75!black] {$\bullet$} 
      	child[red!75!black]
      	child[red!75!black]
			};
%
    \node[blue!50!black, right=.8 of 5] (6) {$\bullet$} 
      child[blue!50!black] {node[red!75!black] {$\bullet$}
      };
      
    \node[blue!50!black, right=.8 of 6] (7) {$\bullet$};
  \end{tikzpicture}
	};
\end{tikzpicture}
\]
So each tree in $(p+q)\tri r$ is obtained by taking either a $p$-corolla or a $q$-corolla, then attaching an $r$-corolla to each leaf.

Alternatively, we can compute $p\tri r$ and $q\tri r$ seperately, gluing $r$-corollas to leaves of $p$ in every way, then to leaves of $q$ in every way:
\[
\begin{tikzpicture}[rounded corners]
	\node (p) [draw, "$p\tri r\cong$" left] at (-2,0) {
	\begin{tikzpicture}[trees,
		level 1/.style={sibling distance=5mm},
	  level 2/.style={sibling distance=2.5mm}]
    \node[green!50!black] (1) {$\bullet$} 
      child[green!50!black] {node[red!75!black] {$\bullet$} 
      	child[red!75!black]
				child[red!75!black]
			}
      child[green!50!black] {node[red!75!black] {$\bullet$} 
      	child[red!75!black]
				child[red!75!black]
			};
%
    \node[green!50!black, right=1.3 of 1] (2) {$\bullet$} 
      child[green!50!black] {node[red!75!black] {$\bullet$} 
				child[red!75!black]
				child[red!75!black]
			}
      child[green!50!black] {node[red!75!black] {$\bullet$} 
			};
%
    \node[green!50!black, right=1.3 of 2] (3) {$\bullet$} 
      child[green!50!black] {node[red!75!black] {$\bullet$} 
			}
      child[green!50!black] {node[red!75!black] {$\bullet$} 
				child[red!75!black]
				child[red!75!black]
			};
%
    \node[green!50!black, right=1.3 of 3] (4) {$\bullet$} 
      child[green!50!black] {node[red!75!black] {$\bullet$} 
			}
      child[green!50!black] {node[red!75!black] {$\bullet$} 
			};
  \end{tikzpicture}
  };
%
	\node (q) [draw, "$q\tri r\cong$" left] at (4,0) {
	\begin{tikzpicture}[trees,
		level 1/.style={sibling distance=5mm},
	  level 2/.style={sibling distance=2.5mm}]
    \node[blue!50!black] (q1) {$\bullet$} 
      child[blue!50!black] {node[red!75!black] {$\bullet$} 
      	child[red!75!black]
				child[red!75!black]
			};
    \node[blue!50!black, right=.5 of q1] (q2) {$\bullet$} 
      child[blue!50!black] {node[red!75!black] {$\bullet$} 
			};
    \node[blue!50!black, right=.5 of q2] (q3) {$\bullet$};		
  \end{tikzpicture}
  };
\end{tikzpicture}
\]
Their coproduct then consists of all the trees from $p\tri r$ and all the trees from $q\tri r$:
\[
\begin{tikzpicture}[rounded corners]
	\node (p) [draw, "$p\tri r+q\tri r\cong$" left] {
	\begin{tikzpicture}[trees,
		level 1/.style={sibling distance=5mm},
	  level 2/.style={sibling distance=2.5mm}]
    \node[green!50!black] (1) {$\bullet$} 
      child[green!50!black] {node[red!75!black] {$\bullet$} 
      	child[red!75!black]
				child[red!75!black]
			}
      child[green!50!black] {node[red!75!black] {$\bullet$} 
      	child[red!75!black]
				child[red!75!black]
			};
%
    \node[green!50!black, right=1.3 of 1] (2) {$\bullet$} 
      child[green!50!black] {node[red!75!black] {$\bullet$} 
				child[red!75!black]
				child[red!75!black]
			}
      child[green!50!black] {node[red!75!black] {$\bullet$} 
			};
%
    \node[green!50!black, right=1.3 of 2] (3) {$\bullet$} 
      child[green!50!black] {node[red!75!black] {$\bullet$} 
			}
      child[green!50!black] {node[red!75!black] {$\bullet$} 
				child[red!75!black]
				child[red!75!black]
			};
%
    \node[green!50!black, right=1.3 of 3] (4) {$\bullet$} 
      child[green!50!black] {node[red!75!black] {$\bullet$} 
			}
      child[green!50!black] {node[red!75!black] {$\bullet$} 
			};
%
    \node[blue!50!black, right=1 of 4] (5) {$\bullet$} 
      child[blue!50!black] {node[red!75!black] {$\bullet$} 
      	child[red!75!black]
      	child[red!75!black]
			};
%
    \node[blue!50!black, right=.8 of 5] (6) {$\bullet$} 
      child[blue!50!black] {node[red!75!black] {$\bullet$}
      };
      
    \node[blue!50!black, right=.8 of 6] (7) {$\bullet$};
  \end{tikzpicture}
	};
\end{tikzpicture}
\]
So each tree in $p\tri r+q\tri r$ is either a $p$-corolla with an $r$-corolla attached to each leaf, or a $q$-corolla with an $r$-corolla attached to each leaf.

But it doesn't matter whether we glue $r$-corollas to leaves first, or if we pool together corollas from $p$ and $q$ first--the processes are equivalent.
Hence the isomorphism $(p+q)\tri r\iso p\tri r+q\tri r$ holds.
\end{solution}
\end{exercise}

\begin{exercise}
Show that for any set $A$ and polynomials $p,q$, we have an isomorphism $A(p\tri q)\iso (Ap)\tri q$.
\begin{solution}
Given a set $A$ and polynomials $p,q$, the left distributivity of $\tri$ over products from \eqref{eqn.comp_left_pres_prod} implies that $(Ap)\tri q\iso(A\tri q)(p\tri q)$, while \cref{exc.composing_with_constants} \cref{exc.composing_with_constants.appl} implies that $A\tri q\iso A$.
So $(Ap)\tri q\iso A(p\tri q)$.
\end{solution}
\end{exercise}

In \cref{subsec.comon.comp.prop.lim_left}, we will see how to generalize the left distributivity of $\tri$ over products to arbitrary limits.
But first, we observe that right distributivity does not hold.

\begin{exercise} \label{exc.right_not_dist_prod}
Show that the distributivities of \cref{prop.left_dist_prod} do not hold on the other side:
\begin{enumerate}
	\item \label{exc.right_not_dist_prod.prod} Find polynomials $p,q,r$ such that $p\tri (qr)\not\iso(p\tri q)(p\tri r)$.
	\item Find polynomials $p,q,r$ such that $p\tri (q+r)\not\iso(p\tri q)+(p\tri r)$.
\qedhere
\end{enumerate}
\begin{solution}
\begin{enumerate}
    \item Let $p \coloneqq \yon + \1, q \coloneqq \1,$ and $r \coloneqq \0$.
    Then $p \tri (qr) \iso (\yon + \1) \tri \0 \iso \1$, while $(p \tri q)(p \tri r) \iso ((\yon + \1) \tri \1)((\yon + \1) \tri \0) \iso \2 \times \1 \iso \2$.
    \item Again let $p \coloneqq \yon + \1, q \coloneqq \1,$ and $r \coloneqq \0$.
    Then $p \tri (q+r) \iso (\yon + \1) \tri \1 \iso \2$, while $(p \tri q)+(p \tri r) \iso ((\yon + \1) \tri \1)+((\yon + \1) \tri \0) \iso \2 + \1 \iso \3$.
\end{enumerate}
\end{solution}
\end{exercise}

Nevertheless, there is something to be said about the relationship between $p\tri q, p\tri r,$ and $p\tri(qr)$.
We'll see this in action after we discuss how $\tri$ preserves limits on the left.

\subsection{Interaction with limits on the left} \label{subsec.comon.comp.prop.lim_left}

We saw in \cref{thm.poly_limits} that $\poly$ has all limits, and we saw in \cref{exc.refl_limits} that these limits coincide with limits in $\smset^\smset$.
Hence the argument in the proof of \cref{prop.left_dist_prod} by appealing to \cref{prop.presheaf_lim_ptwise} can be generalized to arbitrary limits.
It follows that $\tri$ preserves all limits on the left.
But we will present a proof of this fact from an alternative perspective: by appealing to the left coclosure of $\tri$.

\begin{proposition}[Meyers] \label{prop.comp_left_coclosed}
The composition product is left coclosed.
That is, there exists a left coclosure operation, which we denote $\lchom{-}{-}\colon\poly\op\times\poly\to\poly$,
such that there is a natural isomorphism
\begin{equation} \label{eqn.lchom_adj_iso}
    \poly(p, r\tri q)\iso\poly\left(\lchom{q}{p}, r\right).
\end{equation}
In particular, the left coclosure operation sends $q,p\in\poly$ to
\begin{equation} \label{eqn.lchom_def}
    \lchom{q}{p}\coloneqq\sum_{i\in p(\1)}\yon^{q(p[i])}.
\end{equation}
\end{proposition}
\begin{proof} 
We present an argument using polyboxes; we leave it to the reader to write this proof in more standard mathematical notation in \cref{exc.comp_left_coclosed_calc}.

As in \cref{ex.map_to_comp}, a lens $\varphi\colon p\to r\tri q$ can be written as follows:
\[
\begin{tikzpicture}[polybox, mapstos]
	\node[poly, dom, "$p$" left] (p) {$a$\at$i$};
	\node[poly, cod, right=1.5cm of p.south, yshift=-1ex, "$r$" right] (r) {$c$\at$k$};
	\node[poly, cod, above=of r, "$q$" right] (q) {$b$\at$j$};
  	\draw (p_pos) to[first] node[below] {$\varphi^r$} (r_pos);
  	\draw (r_dir) to[climb] node[right] {$\varphi^q$} (q_pos);
  	\draw (q_dir) to[last] node[above] {$\varphi^\sharp$} (p_dir);
\end{tikzpicture}
\]
But this is equivalent to the following gadget (to visualize this equivalence, imagine leaving the positions box for $p$, the arrow $\varphi^r$, and the polyboxes for $r$ untouched, while dragging the polyboxes for $q$ leftward to the directions box for $p$, merging all the data from $q$ and the arrows $\varphi^q$ and $\varphi^\sharp$ into a single on-directions arrow and directions box):
\[
\begin{tikzpicture}[polybox, mapstos]
    \node[poly, dom, "$\lchom{q}{p}$" left] (l) {$(j,\varphi^\sharp)$\at$i$};
    \node[poly, cod, "$r$" right, right=of l, yshift=-0.5ex] (r) {$c$\at$k$};
    \draw (l_pos) -- node[below] {$\varphi^r$} (r_pos);
    \draw (r_dir) -- node[above] {} (l_dir);
\end{tikzpicture}
\]
Here the on-directions function encodes the behaviors of both $\varphi^q$ and $\varphi^\sharp$ by sending each $r[k]$-direction $c$ to both a $q$-position $j$, as $\varphi^q$ does, and a function sending $q[j]$-directions to $p[i]$-directions, as $\varphi^\sharp$ does.
So the polyboxes on the left represent a polynomial whose positions are the same as those of $p$, but whose directions at $i\in p(\1)$ are pairs $(j,\varphi^\sharp)$ consisting of a $q$-position $j$ and a function $\varphi^\sharp\colon q[j]\to p[i]$.
Such pairs are precisely the elements of $q(p[i])$, so the polynomial represented by the polyboxes on the left is indeed the one defined as $\lchom{q}{p}$ in \eqref{eqn.lchom_def}.
It follows that there is a natural isomorphism between lenses $p\to r\tri q$ and lenses $\lchom{q}{p}\to r$.
\end{proof}

\begin{exercise} \label{exc.comp_left_coclosed_calc}
Translate the polyboxes proof of \cref{prop.comp_left_coclosed} into standard mathematical notation, i.e.\ the $\sum$ and $\prod$ notation we have been using up till now.
\begin{solution}
We prove \cref{prop.comp_left_coclosed} by observing that
\begin{align*}
    \poly(p,r\tri q)&\iso\prod_{i\in p(\1)}r(q(p[i])) \tag*{\eqref{eqn.main_formula}} \\
    &\iso\poly\left(\sum_{i\in p(\1)}\yon^{q(p[i])}, r\right) \tag*{\eqref{eqn.main_formula}} \\
    &\iso\poly\left(\lchom{q}{p}, r\right) \tag*{\eqref{eqn.lchom_def}}.
\end{align*}
\end{solution}
\end{exercise}

\begin{remark}
The proof you came up with in \cref{exc.comp_left_coclosed_calc} may be more obviously rigorous and concise than the one we presented in the main text.
But polyboxes help us see right on paper exactly what is going on in this adjunction: how data on the codomain-side of a lens $p\to r\tri q$ can be simply repackaged and transferred to the domain-side of a new lens $\lchom{q}{p}\to r$.
\end{remark}

\begin{exercise} \label{exc.lchom_func}
In stating \cref{prop.comp_left_coclosed}, we implicitly assumed that $\lchom{-}{-}$ is a functor $\poly\op\times\poly\to\poly$.
Here we show that this is indeed the case.
\begin{enumerate}
    \item Given a polynomial $q$ and a lens $\varphi\colon p\to p'$, to what lens $\lchom{q}{p}\to\lchom{q}{p'}$ should the covariant functor $\lchom{q}{-}$ send $\varphi$?
    Prove that your construction is functorial.
    
    \item Given a polynomial $p$ and a lens $\psi\colon q'\to q$, to what lens $\lchom{q}{p}\to\lchom{q'}{p}$ should the contravariant functor $\lchom{-}{p}$ send $\psi$?
    Prove that your construction is functorial.
    \qedhere
\end{enumerate}
\begin{solution}
\begin{enumerate}
    \item Given a polynomial $q$ and a lens $\varphi\colon p\to p'$, the functor $\lchom{q}{-}$ should send $\varphi$ to a lens $\lchom{q}{p}\to\lchom{q}{p'}$; by \eqref{eqn.lchom_def}, this is a lens
    \[
        \lchom{q}{\varphi}\colon\sum_{i\in p(\1)}\yon^{q(p[i])}\to\sum_{i'\in p'(\1)}\yon^{q(p'[i'])}.
    \]
    We give $\lchom{q}{\varphi}$ the same on-positions function $p(\1)\to p'(\1)$ that $\varphi$ has.
    Then viewing $q$ as a functor, we define the on-directions function $\lchom{q}{\varphi}^\sharp_i\colon q(p'[\varphi_\1(i)])\to q(p[i])$ for each $i\in p(\1)$ to be the function obtained by applying $q$ to the corresponding on-directions function $\varphi^\sharp_i\colon p'[\varphi_\1(i)]\to p[i]$.
    Functoriality follows trivially on positions and by the functoriality of $q$ itself on directions.

    \item Given a polynomial $p$ and a lens $\psi\colon q'\to q$, the functor $\lchom{-}{p}$ should send $\psi$ to a lens $\lchom{q}{p}\to\lchom{q'}{p}$; by \eqref{eqn.lchom_def}, this is a lens
    \[
        \lchom{\psi}{p}\colon\sum_{i\in p(\1)}\yon^{q(p[i])}\to\sum_{i\in p(\1)}\yon^{q'(p[i])}.
    \]
    We let the on-positions function of $\lchom{\psi}{p}$ be the identity on $p(\1)$.
    Then viewing $\psi$ as a natural transformation, we define the on-directions function $\lchom{\psi}{p}^\sharp_i\colon q'(p[i])\to q(p[i])$ for each $i\in p(\1)$ to be the $p[i]$-component of $\psi$.
    Functoriality follows trivially on positions and because natural transformations compose componentwise on directions.
\end{enumerate}
\end{solution}
\end{exercise}

\begin{exercise}
In personal communication, Todd Trimble noted that the left coclosure can be thought of as a left Kan extension
\[
\begin{tikzcd}
	\smset\ar[r, "p"]\ar[d, "q"']\ar[dr, phantom, very near start, "\Downarrow"]&
	\smset\\
	\smset\ar[ur, "\lchom{q}{p}"']&~
\end{tikzcd}
\]
Verify this.
\end{exercise}
\begin{solution}
In order for $\lchom{q}{p}$ to be a left Kan extension of $p$ along $q$, we need to first provide a natural transformation $p\to \lchom{q}{p}\tri q$, and second show that it is universal. But this is exactly the content of \cref{prop.comp_left_coclosed}: the adjunction \eqref{eqn.lchom_adj_iso} provides a unit $p\to \lchom{q}{p}\tri q$ that is universal in the appropriate way. 
\end{solution}


\begin{exercise}
Let $A$ and $B$ be sets, and let $p$ and $q$ be polynomials.
\begin{enumerate}
    \item Prove that the following natural isomorphism holds:
    \begin{equation}\label{eqn.monomials_and_comp}
    	\poly(A\yon^B,p)\iso\smset(A,p(B)).
    \end{equation}
    
    \item Prove that the following natural isomorphism holds:
    \begin{equation}\label{eqn.flip_reps_lins}
        \poly\left(A\yon\tri p\tri \yon^B, q\right)\iso\poly\left(p,\yon^A\tri q\tri By\right). 
    \end{equation}
    (Hint: Break the isomorphism down into two parts.
    You may find \eqref{eqn.two_var_adj} helpful.)
    \qedhere
\end{enumerate}
\begin{solution}
We are given $A,B\in\smset$ and $p,q\in\poly$
\begin{enumerate}
    \item By \eqref{eqn.lchom_def},
    \[
        \lchom{B}{A}=\sum_{i\in A}\yon^{B}\iso A\yon^B,
    \]
    so by \eqref{eqn.lchom_adj_iso},
    \[
        \poly(A\yon^B,p)\iso\poly(A,p\tri B).
    \]
    But $A$ and $p\tri B\iso p(B)$ are both constants, so a lens $A\to p\tri B$ is just a function $A\to p(B)$ on positions.
    Hence \eqref{eqn.monomials_and_comp} follows.

    \item We prove \eqref{eqn.flip_reps_lins} in two parts: that
    \begin{equation} \label{eqn.flipping1}
        \poly\left(A\yon\tri p, q\right)\iso\poly\left(p,\yon^A\tri q\right)
    \end{equation}
    and that
    \begin{equation} \label{eqn.flipping2}
        \poly\left(p \tri \yon^B, q\right)\cong\poly\left(p, q\tri B\yon\right).
    \end{equation}
    We have that $A\yon \tri p \iso Ap$ and $\yon^A \tri q \iso q^A$, so \eqref{eqn.flipping1} follows from \eqref{eqn.two_var_adj}.
    Meanwhile, for \eqref{eqn.flipping2}, we have by \eqref{eqn.lchom_def} that
    \[
        \lchom{B\yon}{p}=\sum_{i\in p(\1)}\yon^{Bp[i]}\iso p\tri\yon^B,
    \]
    so \eqref{eqn.flip_reps_lins} follows from \eqref{eqn.lchom_adj_iso}.
    Then combining \eqref{eqn.flipping1} and \eqref{eqn.flipping2} yields
    \[
        \poly\left(A\yon\tri p\tri\yon^B,q\right)\iso\poly\left(p\tri\yon^B,\yon^A\tri q\right)\iso\poly\left(p,\yon^A\tri q\tri B\yon\right).
    \]
\end{enumerate}
\end{solution}
\end{exercise}

% \[
% \begin{tikzpicture}
% 	\node (p1) {
%   \begin{tikzpicture}[polybox,tos]
%   	\node[poly, "$p$" left] (p) {};
%   	\node[poly, linear, below=of p, "$A\yon$" left] (Ay) {};
%   	\node[poly, pure, above=of p, "$\yon^B$" left] (yB) {};
%   	\node[poly, right=2 of p, "$q$" right] (q) {};
%   	\node at ($(p.east)!.5!(q.west)$) {$\leftrightarrows$};
%   \end{tikzpicture}
%   };
%  \node[right=4 of p1] (p2) {
%  \begin{tikzpicture}[polybox,tos]
%   	\node[poly, "$p$" left] (p) {};
%   	\node[poly, right=2 of p, "$q$" right] (q) {};
%   	\node[poly, linear, above=of q, "$B\yon$" right] (By) {};
%   	\node[poly, pure, below=of q, "$\yon^A$" right] (yA) {};
% 		\draw (p_pos) to[first] (yA_pos);
% 		\draw (yA_dir) to[climb] (q_pos);
% 		\draw (q_dir) to[climb] (By_pos);
% 		\draw (By_dir) to[last] (p_dir);
%  \end{tikzpicture}
%  };
%  \node[align=center] at ($(p1)!.5!(p2)$) {is the\\same as};
% \end{tikzpicture} 
% \]
% Do you see how polyboxes with a black (one-element) part can flip upside-down to go to the other side?

\begin{example}[Dynamical systems as coalgebras] \label{ex.coalgebras}
Taking $A=B=S\in\smset$ in \eqref{eqn.monomials_and_comp}, we find that there is a natural isomorphism between dynamical systems $S\yon^S\to p$ and functions $S\to p(S)$.
Such a function is known as a \emph{coalgebra for the functor $p$} or a \emph{$p$-coalgebra}.%
\tablefootnote{There are two versions of coalgebras we are interested in (and more that we are not) with distinct definitions: a \emph{coalgebra for a functor}, which is the version used here, and a \emph{coalgebra for a comonad}, which is a coalgebra for a functor with extra conditions that we will introduce later in \cref{sec.comon.sharp.cof.from_state}.
The version we are using will usually be clear from context---here, for example, we do not expect $p$ to be a comonad---but we will try to be explicit with our terminology whenever the interpretation may be ambiguous.}

Coalgebras as models of dynamical systems have been studied extensively in the context of computer science, most notably by Jacobs in \cite{jacobs2017introduction}.
Indeed, much of what we developed in \label{sec.poly.dyn_sys.moore,sec.poly.dyn_sys.depend_sys} stems from the theory of coalgebras.
The coalgebraic perspective has the benefit of staying in the familiar category of sets; moreover, it can be generalized to functors $\smset\to\smset$ that are not polynomial, although many of the interesting examples are.

On the other hand, we have already seen that viewing dynamical systems as lenses $S\yon^S\to p$ rather than as functions $S\to p(S)$ has the benefit of isolating the internal state system to the domain and the external interface to the codomain, aiding both intuition and functionality.
Plus, our adjunction lets us switch to the coalgebraic perspective whenever we see fit: $\poly$ lets us talk about both.
\end{example}


\begin{proposition}[Left preservation of limits] \label{prop.left_pres_lim}
The operation $\tri$ preserves limits on the left (up to natural isomorphism).
That is, if $\cat{J}$ is a category, $p_-\colon\cat{J}\to\poly$ is a functor, and $q\in\poly$ is a polynomial, then there is a natural isomorphism
\begin{equation} \label{eqn.comp_left_pres_lim}
    \left(\lim_{j\in\cat{J}}p_j\right)\tri q\iso\lim_{j\in\cat{J}}(p_j\tri q).
\end{equation}
\end{proposition}
\begin{proof}
By \cref{prop.comp_left_coclosed}, the functor $(-\tri q)\colon\poly\to\poly$ is the right adjoint of the functor $\lchom{q}{-}\colon\poly\to\poly$, and right adjoints preserve limits.
\end{proof}

\begin{exercise} \label{exc.comp_left_pres_lim}
\begin{enumerate}
    \item Complete \cref{exc.composing_with_constants} \cref{exc.composing_with_constants.appl} using \eqref{eqn.comp_left_pres_lim} and \eqref{eqn.comp_left_pres_sum}.
    \item \label{exc.comp_left_pres_lim.prod} Deduce \eqref{eqn.comp_left_pres_prod} using \eqref{eqn.comp_left_pres_lim}.\qedhere
\end{enumerate}
\begin{solution}
\begin{enumerate}
    \item We wish to solve \cref{exc.composing_with_constants} \cref{exc.composing_with_constants.appl} using \eqref{eqn.comp_left_pres_lim} and \eqref{eqn.comp_left_pres_sum}.
    If we set $\cat{J}$ in \eqref{eqn.comp_left_pres_lim} to be the empty category, then the limit of the functor from $\cat{J}$ is just the terminal object.
    It follows that $\1\tri p\iso\1$.
    In other words, since $\tri$ preserves limits on the left, and since terminal objects are limits, $\tri$ preserves terminal objects on the left.
    
    Then a set $X$ can be written as a sum $\sum_{x\in X}\1$, so by \eqref{eqn.comp_left_pres_sum},
    \[
        X\tri p\iso\left(\sum_{x\in X}\1\right)\tri p\iso\sum_{x\in X}(\1\tri p)\iso\sum_{x\in X}\1\iso X.
    \]
    
    \item If we set $\cat{J}$ in \eqref{eqn.comp_left_pres_lim} to be the discrete category on the set $A$, then the limit of a functor from $\cat{J}$ is just an $A$-fold product, so \eqref{eqn.comp_left_pres_prod} follows.
    In other words, since $\tri$ preserves limits on the left, and since products are limits, $\tri$ preserves products on the left.
\end{enumerate}
\end{solution}
\end{exercise}


\subsection{Interaction with limits on the right} \label{subsec.comon.comp.prop.lim_right}

So $\tri$ preserves limits on the left.
How about limits on the right?
We saw in \cref{exc.right_not_dist_prod} that $\tri$ does not even preserve products on the right, so it certainly does not preserve all limits.
But it turns out that there is a special class of limits that $\tri$ does preserve on the right.

\begin{definition}[Connected limit]
A \emph{connected limit} is one whose indexing category $\cat{J}$ is nonempty and connected. That is, $\cat{J}$ has at least one object, and any two objects are connected by a finite zigzag of arrows.
\end{definition}

\begin{example}
The following categories are connected:
\[
\fbox{$\bullet$}
\qquad
\fbox{$\bullet\tto\bullet$}
\qquad
\fbox{$\bullet\to\bullet\from\bullet$}
\qquad
\fbox{$\bullet\from\bullet\from\bullet\from\cdots$}
\]
In particular, equalizers, pullbacks, and directed limits are examples of connected limits. 

The following categories are \emph{not} connected:
\[
\fbox{$\phantom{\bullet}$}
\qquad
\fbox{$\bullet\quad\bullet$}
\qquad
\fbox{$\bullet\quad\bullet\to \bullet$}
\]
In particular, terminal objects and products are \emph{not} examples of connected limits.
\end{example}

Connected limits are intimately related to slice categories, which we defined back in \cref{def.slice}.
For example, products in a slice category $\cat{C}/c$ are just pullbacks in $\cat{C}$, allowing us to view a non-connected limit as a connected one.
By relating $\poly$ to its slice categories via an adjunction, we'll be able to show that $\tri$ preserves connected limits.
(An alternative proof of this fact can be found in \cite[Proposition 1.16]{kock2012polynomial}.)
%The claim for the right side comes down to the fact that polynomials are sums of representables; representable functors commute with all limits and sums commute with connected limits in $\smset$.

Recall that objects in a slice category $\cat{C}/c$ are just morphisms with codomain $c$.
For ease of notation, we'll often suppress the actual morphism and just write down the name of its domain when there is a canonical choice for the morphism, or when it is clear from context.
So for example, on the left hand side of \eqref{eqn.rchom_adj_iso} below, $p$ represents the lens $f\colon p\to q\tri 1$ and $q\tri r$ represents the lens $q\:\tri\:!\colon q\tri r\to q\tri\1$, both objects in the slice category $\poly/q\tri\1$.

\begin{proposition} \label{prop.comp_right_slice_coclosed}
Given polynomials $p,q,r\in\poly$ and a function $f\colon p\to q\tri\1$, there is a natural isomorphism
\begin{equation} \label{eqn.rchom_adj_iso}
    \poly/(q\tri\1)\left(p, q\tri r\right)\iso\poly\left(p\rchom{f}q, r\right),
\end{equation}
where
\begin{equation} \label{eqn.rchom_def}
    p\rchom{f}q\coloneqq\sum_{i\in p(\1)}q[f(i)]\yon^{p[i]}.
\end{equation}
\end{proposition}
\begin{proof}
Again, we present an argument using polyboxes; we leave it to the reader to write this proof in more standard mathematical notation in \cref{exc.comp_right_slice_coclosed_calc}.

Note that to consider $q\tri r$ as an object in $\poly/(q\tri\1)$, we are implicitly using the map $q\:\tri\:!\colon q\tri r\to q\tri 1$. By definition, morphisms from $f$ to $q\:\tri\:!$ in $\poly/(q\tri\1)$ are lenses $\varphi\colon p\to q\tri r$ for which $\varphi\then(q\:\tri\:!)=f$.
We can write this equation using polyboxes:
\[
\begin{tikzpicture}
	\node (a) {
  \begin{tikzpicture}[polybox, mapstos]
	\node[poly, dom, "$p$" left] (p) {\at$i$};
	\node[poly, right=1.8 of p.south, yshift=-2.5ex, "$q$" below] (q) {$b$\at$j$};
	\node[poly, above=.8 of q, "$r$" above] (r) {\at$k$};
	\node[poly, cod, right=of q, "$q$" right] (q') {$b$\at$j$};
	\node[poly, terminal, above=.8 of q', "$\1$" right] (1) {};
	\draw[double, -] (q_pos) -- node[below] {} (q'_pos);
	\draw[double, -] (q'_dir) -- node[above] {} (q_dir);
	\draw (r_pos) -- node[below] {} (1_pos);
	\draw[densely dotted] (1_dir) -- node[above] {} (r_dir);	
	\draw (p_pos) to[first] node[below] {$\varphi^q$} (q_pos);
	\draw (q_dir) to[climb] node[right] {$\varphi^r$} (r_pos);
	\draw (r_dir) to[last] node[above] {$\varphi^\sharp$} (p_dir);
  \end{tikzpicture}
	};
	\node[right=1.8 of a] (b) {
  \begin{tikzpicture}[polybox, mapstos]
  	\node[poly, dom, "$p$" left] (p) {\at$i$};
  	\node[poly, cod, right=1.8 of p.south, yshift=-1ex, "$q$" right] (q) {$b$\at$f(i)$};
  	\node[poly, terminal, above=of q, "$\1$" right] (1) {};
  	\draw (p_pos) to[first] node[below] {$f$} (q_pos);
  	\draw (q_dir) to[climb] node[right] {} (1_pos);
  	\draw[densely dotted] (1_dir) to[last] node[above] {$!$} (p_dir);
  \end{tikzpicture}
	};
	\node at ($(a.east)!.5!(b.west)$) {=};
\end{tikzpicture}
\]
We can read off the picture that a lens $\varphi\colon p\to q\tri r$ is a morphism from $f$ to $q\:\tri\:!$ in $\poly/q\tri\1$ if and only if $\varphi^q=f_\1$.
% , so specifying such a morphism amounts to specifying a position $k$ of $r$ and an on-directions function $r[k]\to p[i]$ for each $i\in p(\1)$ and $b\in q[f_\1(i)]$.
So morphisms from $f$ to $q\:\tri\:!$ are equivalent to gadgets
\[
\begin{tikzpicture}[polybox, mapstos]
    \node[poly, dom, "$p$" left] (p) {$a$\at$i$};
    \node[poly, cod, right=1.8 of p.south, yshift=-2.5ex, "$q$" below] (q) {$b$\at$f_\1(i)$};
    \node[poly, cod, above=.8 of q, "$r$" above] (r) {$c$\at$k$};
    \draw (p_pos) to[first] node[below] {$f$} (q_pos);
    \draw (q_dir) to[climb] node[right] {$\varphi^r$} (r_pos);
    \draw (r_dir) to[last] node[above] {$\varphi^\sharp$} (p_dir);
\end{tikzpicture}
\]
with $f_\1$ fixed.
But this, in turn, is equivalent to the following gadget (to visualize this equivalence, imagine leaving the polyboxes for $r$, the arrow $\varphi^\sharp$, and the directions box for $p$ untouched, while dragging the polyboxes for $q$ leftward to the positions box for $p$, merging the data from $q$ and the predetermined arrow $f$ into a single positions box and adapting the arrow $\varphi^r$ into an on-positions arrow):
\[
\begin{tikzpicture}[polybox, mapstos]
    \node[poly, dom, "$p\rchom{f}q$" left] (h) {$a$\at$(i,b)$};
    \node[poly, cod, "$r$" right, right=of h] (r) {$c$\at$k$};
    \draw (h_pos) -- node[below] {$\varphi^r$} (r_pos);
    \draw (r_dir) -- node[above] {$\varphi^\sharp$} (h_dir);
\end{tikzpicture}
\]
Here the user can provide both the $p$-position $i$ and the $q[f(i)]$-direction $b$ right from the start, as they know what to expect from $f$ ahead of time.
Then the on-positions function encodes the behavior of $\varphi^r$.
So the polyboxes on the left represent a polynomial whose positions are pairs $(i,b)$ with $i\in p(\1)$ and $b\in q[f(i)]$, and whose directions at $(i,b)$ are the directions of the original polynomial $p$ at $i$.
This is precisely the polynomial we defined in \eqref{eqn.rchom_def}, so the isomorphism holds.
\end{proof}

\begin{remark}
As a lens $p\to q\tri\1$ can be identified with its on-positions function $p(\1)\to q(\1)$, we'll use the notation $p\rchom{f}q$ interchangeably for lenses $f\colon p\to q\tri\1$ and functions $f\colon p(\1)\to q(\1)$.
\end{remark}


\begin{exercise} \label{exc.comp_right_slice_coclosed_calc}
\begin{enumerate}
    \item Translate the polyboxes proof of \cref{prop.comp_right_slice_coclosed} into standard mathematical notation.
    \item Prove that the following natural isomorphism holds:
    \begin{equation}
        \poly(p,q\tri r)\iso\sum_{f\colon p(\1)\to q(\1)}\poly\left(p\rchom{f}q,r\right).
    \end{equation}
    Thus the functor $(q\tri-)\colon\poly\to\poly$ is said to have a \emph{left multiadjoint}.
\end{enumerate}
\begin{solution}
\begin{enumerate}
	\item Note that $\poly(p,q\tri \1)\cong\smset(p(1),q(1))$. A lens $p\to q\tri r$ is an element of
    \[
    \prod_{i\in p(\1)}\sum_{j\in q(\1)}\prod_{b\in q[j]}\sum_{k\in r(\1)}\prod_{c\in r[k]}p[i]\cong\sum_{f\colon p(\1)\to q(\1)}\prod{i\in p(1)}\prod_{b\in q[j]}\sum_{k\in r(\1)}\prod_{c\in r[k]}p[i]
    \]
    Fixing the function $f\colon p(\1)\to q(\1)$ as implicit in $p$, we get
\begin{align*}
	\poly/(q\tri\1)\left(p, q\tri r\right)&\cong
	\prod{i\in p(1)}\prod_{b\in q[j]}\sum_{k\in r(\1)}\prod_{c\in r[k]}p[i]\\&\cong
	\poly\left(p\rchom{f}q, r\right),
\end{align*}
	\item This follows from the first isomorphism above.
 \end{enumerate}
\end{solution}
\end{exercise}

\begin{exercise} \label{exc.rchom_func}
In stating \cref{prop.comp_right_slice_coclosed}, we implicitly assumed that $p\rchom{f}q\in\poly$ is functorial in each variable: covariantly on the left and contravariantly on the right.
Here we show that this is indeed the case.
\begin{enumerate}
    \item Given lenses $f\colon p\to q\tri\1$ and $g\colon p'\to p$, to what lens $p'\rchom{g\then f}q\to p\rchom{f}q$ should the covariant functor $-\rchom{f}q$ send $g$?
    Prove that your construction is functorial.
    
    \item Given lenses $f\colon p\to q\tri\1$ and $h\colon q\to q'$, to what lens $p\rchom{f\then(h\tri\1)}q'\to p\rchom{f}q$ should the contravariant functor $p\rchom{f}-$ send $h$?
    Prove that your construction is functorial.
    \qedhere
\end{enumerate}
\begin{solution}
\begin{enumerate}
    \item Given lenses $f\colon p\to q\tri\1$ and $g\colon p'\to p$, the functor $-\rchom{f}q$ should send $g$ to a lens $p'\rchom{g\then f}q\to p\rchom{f}q$; by \eqref{eqn.rchom_def}, this is a lens
    \[
        g\rchom{f}q\colon\sum_{i'\in p'(\1)}q[f_\1(g_\1(i'))]\yon^{p'[i']}\to\sum_{i\in p(\1)}q[f_\1(i)]\yon^{p[i]}.
    \]
    We give $g\rchom{f}q$ an on-positions function that is the on-positions function $p'(\1)\to p(\1)$ of $g$ on the first coordinate $i'\in p'(\1)$ and the identity on $q[f_\1(g_\1(i'))]$ on the second.
    Then we let the on-directions function at every position with first coordinate $i'\in p'(\1)$ be the on-directions function $g^\sharp_{i'}\colon p[g_\1(i')]\to p'[i']$.
    Functoriality follows trivially on both positions and directions.

    \item Given a polynomial $p$ and lenses $f\colon p\to q\tri\1$ and $h\colon q\to q'$, the functor $p\rchom{f}-$ should send $h$ to a lens $p\rchom{f\then(h\tri\1)}q'\to p\rchom{f}q$; by \eqref{eqn.rchom_def}, this is a lens
    \[
        p\rchom{f}h\colon\sum_{i\in p(\1)}q'[h_\1(f_\1(i))]\yon^{p[i]}\to\sum_{i\in p(\1)}q[f_\1(i)]\yon^{p[i]}.
    \]
    We let the on-positions function of $p\rchom{f}h$ be the identity on the first coordinate $i\in p(\1)$ and the on-directions function $h^\sharp_{f_\1(i)}\colon q'[h_\1(f_\1(i))]\to q[f_\1(i)]$ on the second.
    Then we let the on-directions function at every position with first coordinate $i\in p(\1)$ be the identity on $p[i]$.
    Functoriality follows trivially on both positions and directions.
\end{enumerate}
\end{solution}
\end{exercise}



\begin{theorem}[Preservation of connected limits]\label{thm.connected_limits}
The operation $\tri$ preserves connected limits on both sides.
That is, if $\cat{J}$ is a connected category, $p\colon \cat{J}\to\poly$ is a functor, and $q\in\poly$ is a polynomial, then there are natural isomorphisms
\[
	\left(\lim_{j\in \cat{J}} p_j\right)\tri q\iso \lim_{j\in \cat{J}}(p_j\tri q)
	\qqand
	q\tri\left(\lim_{j\in \cat{J}} p_j\right)\iso \lim_{j\in \cat{J}}(q\tri p_j)
\]
\end{theorem}
\begin{proof}
The claim for the left side is just a special case of \cref{prop.left_pres_lim}; it remains to prove the claim on the right.

By \cref{thm.poly_limits}, $\poly$ is complete, so by \cite[Theorem~4.3]{nlab:connected-limit}, it suffices to show that the functor $(q\tri-)\colon\poly\to\poly$ preserves wide pullbacks on the right.
By \cref{prop.comp_right_slice_coclosed}, the functor $(q\tri-)\colon\poly\to\poly/q\tri\1$ is a right adjoint, so it preserves limits, including wide pullbacks.
Thus $(q\tri-)$ sends a wide pullback over $r\in\poly$ to a wide pullback over the canonical lens $q\tri r\to q\tri\1$ in $\poly/q\tri\1$, corresponding to a limit in $\poly$ of a diagram consisting of arrows to $q\tri r$ and arrows to $q\tri\1$ factoring through $q\tri r$.
So up to isomorphism, this limit is just a wide pullback in $\poly$ over $q\tri r$, namely $(q\tri-)\colon\poly\to\poly$ applied to the original wide pullback.
So $\tri$ preserves wide pullbacks on the right.
\end{proof}


\begin{exercise}\label{ex.connected_limits_and_tri}
Use \cref{thm.connected_limits} in the following.
\begin{enumerate}
	\item Let $p$ be a polynomial, thought of as a functor $p\colon\smset\to\smset$. Show that $p$ preserves connected limits (of sets).
	\item Show that for any polynomials $p,q,r$ we have an isomorphism:
	\begin{equation} \label{eqn.right_prod_pullback}
	p\tri(qr)\iso (p\tri q)\times_{(p\tri\1)}(p\tri r).
	\end{equation}
	\item Take the polynomials $p,q,r$ from the counterexample you found in \cref{exc.right_not_dist_prod} \cref{exc.right_not_dist_prod.prod} and check that \eqref{eqn.right_prod_pullback} holds.
\qedhere
\end{enumerate}
\begin{solution}
\begin{enumerate}
    \item Given a polynomial functor $p \colon \smset \to \smset$, we wish to show that $p$ preserves connected limits of sets; that is, for a connected category $\cat{J}$ and a functor $X \colon \cat{J} \to \smset$, we have
    \[
        p\left(\lim_{j \in \cat{J}} X_j\right) \iso \lim_{j \in \cat{J}} p(X_j).
    \]
    But we can identify $\smset$ with the full subcategory of constant functors in $\poly$ and instead view $X$ as a functor into $\poly$.
    Then by \cref{exc.composing_with_constants} \cref{exc.composing_with_constants.appl}, the left hand side of the isomorphism we seek is isomorphic to $p\tri\left(\lim_{j \in \cat{J}} X_j\right)$, while the right hand side is isomorphic to $\lim_{j \in \cat{J}} \left(p \tri X_j\right)$.
    These are isomorphic by \cref{thm.connected_limits}.
    \item Given $p,q,r \in \poly$, we wish to show that \eqref{eqn.right_prod_pullback} holds.
    As $\1$ is terminal in $\poly$, the product $qr$ can also be written as the pullback $q \times_\1 r$.
    While products are not connected limits, pullbacks are, so by \cref{thm.connected_limits}, they are preserved by precomposition with $p$.
    Hence the desired isomorphism follows.
    \item We'll show that \eqref{eqn.right_prod_pullback} holds for $p\coloneqq\yon+\1, q\coloneqq\1,$ and $r\coloneqq\0$.
    We have $p\tri q = p\tri\1 \iso (\yon+\1)\tri\1 \iso \2$ and $p\tri r \iso (\yon+\1)\tri\0 \iso \1$, so $(p\tri q)\times_{(p\tri\1)}(p\tri r) \iso \2 \times_\2 \1$.
    We saw in \cref{ex.pullbacks_in_poly} that the position-set of a pullback in $\poly$ is just the pullback of the position-sets in $\smset$, while the direction-sets are given by a pushout of direction-sets in $\smset$.
    As our polynomials have empty direction-sets, their pullback must have an empty direction-set as well, so this pullback is just a pullback of sets: $(p\tri q)\times_{(p\tri\1)}(p\tri r) \iso \2 \times_\2 \1\iso\1$.
    And indeed we have $p\tri(qr) \iso (\yon+\1)\tri\0 \iso \1$ as well.
\end{enumerate}
\end{solution}
\end{exercise}

While we're here, it will be helpful to record the following.
\begin{proposition} %Make this an exercise, mimicking earlier stuff
For any polynomial $q\in\poly$, tensoring with $q$ (on either side) preserves connected limits. That is, if $\cat{J}$ is connected and $p\colon \cat{J}\to\poly$ is a functor, then there is a natural isomorphism:
\[
	\left(\lim_{j\in \cat{J}} p_j\right)\otimes q\cong
	\lim_{j\in \cat{J}} (p_j\otimes q).
\]
\end{proposition}


\subsection{Interaction with parallel products} \label{subsec.comon.comp.prop.par}

Before we get into how $\otimes$ interacts with $\tri$, here is a warm-up exercise.

\begin{exercise}
Let $A$ and $B$ be arbitrary sets, and let $p$ be an arbitrary polynomial.
Which of the following isomorphisms always hold?

If the isomorphism does not always hold, is there still a canonical lens in one direction or the other?
\begin{enumerate}
	\item $(A\yon)\otimes(B\yon) \iso^? (A\yon)\tri (B\yon)$.
	\item $\yon^A\otimes\yon^B\iso^?\yon^A\tri\yon^B$.
	\item $A\otimes B\iso^? A\tri B$.
	\item $B\yon\otimes p\iso^? B\yon\tri p$.
	\item $\yon^A\otimes p\iso^? \yon^A\tri p$.
	\item $p\otimes B\yon\iso^? p\tri B\yon$.
	\item $p\otimes \yon^A\iso^? p\tri\yon^A$.
	\qedhere
\end{enumerate}
What do all of the lenses you found in this exercise have in common (whether or not they were isomorphisms)?
\begin{solution}
Here $A$ and $B$ are sets and $p$ is a polynomial.
\begin{enumerate}
	\item The isomorphism always holds: we have that $(A\yon)\otimes(B\yon) \iso AB\yon \iso (A\yon)\tri (B\yon)$.
	\item The isomorphism always holds: we have that $\yon^A\otimes\yon^B \iso \yon^{AB} \iso \yon^A\tri\yon^B$.
	\item The isomorphism does not always hold: while $A\otimes B \iso AB$, we have that $A\tri B \iso A$.
	There is, however, always a canonical projection $AB\to B$; but there is not always a canonical lens $B\to AB$ (for example, take $A=\0\neq B$).
	\item The isomorphism always holds: we have that $B\yon \otimes p \iso \sum_{i \in p(\1)} B\yon \otimes \yon^{p[i]} \iso \sum_{i \in p(\1)} B\yon^{p[i]} \iso Bp \iso B\yon\tri p$.
	\item The isomorphism does not always hold: if, say, $p = B$, then $\yon^A \otimes B \iso B$, while $\yon^A \tri B \iso B^A$.
	If $A=B=\0$, then $B^A\iso\1$, so there is not always a canonical lens from right to left, either.
	There is, however, always a canonical lens from left to right: $\yon^A\otimes p\iso\sum_{i \in p(\1)}\yon^{Ap[i]}$ while $\yon^A\tri p\iso\sum_{\ol{i}\colon A\to p(\1)}\yon^{\sum_{a\in A}p[\ol{i}(a)]}$.
	So there is a lens from left to right whose on-positions function sends $i\in p(\1)$ to the constant function $A\to p(\1)$ that always evaluates to $i$; and whose on-directions function at $i$ is the identity on $Ap[i]$.
	\item The isomorphism does not always hold: if, say, $p = \yon^A$, then $\yon^A \otimes B\yon \iso B\yon^A$, while $\yon^A \otimes B\yon \iso (B\yon)^A \iso B^A\yon^A$.
	If $A=B=\0$, then $B\yon^A\iso\0$ while $B^A\yon^A\iso\0^\0\yon^\0\iso\1$, so there is not always a canonical lens from right to left, either.
	There is, however, always a canonical lens from left to right: $p\otimes B\yon\iso Bp$ while $p\tri B\yon\iso\sum_{i\in p(\1)}\sum_{\ol{b}\colon p[i]\to B}\yon^{\sum_{a\in p[i]}\1}\iso\sum_{i\in p(\1)}B^{p[i]}\yon^{p[i]}$.
	So there is a lens from left to right whose on-positions function sends $(b,i)\in Bp(\1)$ to $(i,c_b)\in\sum_{i\in p(\1)}B^{p[i]}$, where $c_b\colon p[i]\to B$ is the constant function that always evaluates to $b$; and whose on-directions function at $(b,i)$ is the identity on $p[i]$.
	\item The isomorphism always holds: we have that $p \otimes \yon^A \iso \sum_{i \in p(\1)} \yon^{Ap[i]} \iso p \tri \yon^A$.
\end{enumerate}
Every on-directions function of every lens we found in this exercise are isomorphisms, so every lens we found in this exercise is cartesian.
\end{solution}
\end{exercise}

\begin{example}[Lenses from $\otimes$ to $\tri$]
For any $p$ and $q$, there is an interesting cartesian lens $o_{p,q}\colon p\otimes q\to p\tri q$ that, stated informally, ``orders'' the operation, taking the symmetric monoidal product $\otimes$ and reinterprets it as a special case of the asymmetric monoidal product $\tri$.
Defining this lens in the usual way is rather tedious and unilluminating, but written in polyboxes, the lens looks like this (recall that positions of $p\otimes q$ are just pairs of positions of $p$ and $q$, while directions at each such pair are pairs of directions of $p$ and $q$, one at each position in the pair):
\[
\begin{tikzpicture}[polybox, mapstos]
	\node[poly, dom, "$p\otimes q$" left] (p) {$(a,b)$\nodepart{two}$(i,j)$};
	\node[poly, cod, "$p$" right, right= 1.5cm of p.south, yshift=-1ex] (q) {$a$\nodepart{two}$i$};
	\node[poly, cod, "$q$" right, above=of q] (r) {$b$\nodepart{two}$j$};
  	\draw (p_pos) to[first] (q_pos);
  	\draw (q_dir) to[climb] (r_pos);
  	\draw (r_dir) to[last] (p_dir);
\end{tikzpicture}
\]
Usually, the positions box of $q$ is allowed to depend on the directions box of $p$ in the polyboxes for $p\tri q$ on its own.
But in the polyboxes above, $j$ is not allowed to depend on $a$ in $p\otimes q$ on the left, so the arrow from the positions box of $q$ to the directions box of $p$ on the right doesn't actually take $a$ into account at all.
So the lens $o_{p,q}$ is in some sense the inclusion of the order-independent positions of $p\tri q$; when drawn as trees, the positions in its image are the ones whose upper-level corollas are all the same.
And of course we can flip the order using the symmetry $q\otimes p\iso p\otimes q$.
This is, we just as well have a lens $p\otimes q\to q\tri p$.

Both $\otimes$ and $\tri$ have the same monoidal unit, the identity functor $\yon$, whose identity is the unique lens $\yon\to\yon$.
In fact the lenses $o_{p,q}$ constitute a lax monoidal functor $(\poly,\yon,\otimes)\to(\poly,\yon,\tri)$.
In particular, $o_{p,q}$ commutes with associators and unitors. 

This can be used in the following way. Lenses $p\to q\tri r$ into composites are fairly easy to understand (through polyboxes, for example), whereas lenses $q\tri r\to p$ are not so easy to think about. However, given such a lens, one may always compose it with $o_{q,r}$ to obtain a lens $q\otimes r\to p$.
This is quite a bit simpler to think about: they are our familiar interaction patterns from \cref{sec.poly.dyn_sys.interact}.
\end{example}

\begin{proposition}
For any polynomials $p,p',q,q'$ there are natural maps
\begin{align}\label{eqn.plus_duoidal}
	(p\tri p')+(q\tri q')&\to (p+q)\tri(p'+q')\\\label{eqn.otimes_duoidal}
	(p\tri p')\otimes(q\tri q')&\to(p\otimes q)\tri(p'\otimes q')\\\label{eqn.times_duoidal}
	(p\tri p')\times (q\tri q')&\from(p\times q)\tri(p'\times q')
\end{align}
making $(+,\tri)$ and $(\otimes,\tri)$ duoidal structures and $(\times,\tri)$ op-duoidal.
\end{proposition}
\begin{proof}
For \eqref{eqn.plus_duoidal} we have inclusion maps $p\to p+q$ and $p'\to p'+q'$, inducing a map $p\tri p'\to(p+q)\tri(p'+q')$. Similarly we obtain a map $q\tri q'\to(p+q)\tri(p'+q')$, so we get the desired map from the universal property of coproducts. It is straightforward to check that this is duoidal. The result for \eqref{eqn.times_duoidal} is similar. 
\end{proof}

%\begin{exercise}\label{exc.plus_duoidal}
%\begin{enumerate}
%	\item Give maps $0\to 0+0$, $\yon\to\yon\tri\yon$, and $0\to\yon$.
%	\item Check that the following diagrams commute:
%\[ 
%\begin{tikzcd}
%	(p\tri p')+0\ar[r]&
%	(p\tri p)+(0\tri 0)\ar[d]\\
%	p\tri p'&
%	(p+0)\tri (p'+0)\ar[l]
%\end{tikzcd}
%\hspace{1in}
%\begin{tikzcd}
%	((p\tri p')+(q\tri q'))+(r\tri r')\ar[r]\ar[d]&
%	(p\tri p')+((q\tri q')+(r\tri r'))\ar[r]&
%	(p\tri p')+((q+r)\tri(q'+r'))\ar[d]\\
%	((p+ q)\tri(p'+ q'))+(r\tri r')\ar[r]&
%	((p+q)+r)\tri((p'+q')+r')\ar[r]&
%	(p+(q+r))\tri(p'+(q'+r'))
%\end{tikzcd}
%\]
%\qedhere
%\end{enumerate}
%\end{exercise}

\subsection{Interaction with vertical and cartesian lenses} \label{subsec.comon.comp.prop.cart}

We conclude this section by examining how $\tri$ interacts with vertical and cartesian lenses, as defined in \cref{def.vert_cart}.

\begin{proposition}[Preservation of cartesian lenses]\label{prop.comp_pres_cart}
If $\varphi\colon p\to p'$ and $\psi\colon q\to q'$ are cartesian lenses, then so is $\varphi\tri \psi\colon p\tri q \to p'\tri q'$.
\end{proposition}
\begin{proof}
We use the third characterization of cartesian lenses given in \cref{prop.cart_as_nt}, as lenses whose naturality squares are pullbacks.
For any sets $A,B$ and function $h\colon A\to B$, consider the diagram
\[
\begin{tikzcd}[column sep=small]
    p\tri q\tri A\ar[r]\ar[d] & p'\tri q\tri A\ar[r]\ar[d] & p'\tri q'\tri A\ar[d] \\
    p\tri q\tri B\ar[r] & p'\tri q\tri B\ar[r] & p'\tri q'\tri B.
\end{tikzcd}
\]
The square on the left is a pullback because $\varphi\colon p\to p'$ is cartesian.
Meanwhile, the square on the right is a pullback because $\psi\colon q\to q'$ is cartesian and $\tri$ preserves pullbacks by \cref{thm.connected_limits}.
Hence the outer rectangle is a pullback as well, implying that $\varphi\tri \psi\colon p\tri q \to p'\tri q'$ is cartesian.
\end{proof}

\begin{exercise}
Let $\varphi\colon p\to p'$ and $\psi\colon q\to q'$ be lenses.
\begin{enumerate}
	\item Show that if $\varphi$ is an isomorphism and $\psi$ is vertical, then $\varphi\tri \psi$ is vertical.
	\item Find a vertical lens $\varphi$ and a polynomial $q$ for which $\varphi\tri q\colon p\tri q\to p'\tri q$ is not vertical.
\qedhere
\end{enumerate}
\begin{solution}
Here $\varphi\colon p\to p'$ and $\psi\colon q\to q'$ are lenses.
\begin{enumerate}
    \item If $\varphi$ is an isomorphism and $\psi$ is vertical, then $\psi\tri\1\colon q\tri\1\to q'\tri\1$ is an isomorphism, so $\varphi\tri \psi\tri\1\colon p\tri q\tri\1\to p'\tri q'\tri\1$ is an isomorphism as well.
    Thus $\varphi\tri \psi$ is vertical.
    \item If $\varphi$ is the unique lens $\yon\to\1$ and $q=\0$, then $\varphi$ is vertical, but since $\yon\tri\0\iso\0$ and $\1\tri\0\iso\1$, the lens $\varphi\tri\0\colon\0\to\1$ is not.
\end{enumerate}
\end{solution}
\end{exercise}

%-------- Section --------%
\section{Summary and further reading}

In this chapter we introduced the composition (sometimes called ``substitution'') product $\tri$. Given polynomials $p,q$ thought of as functors, their composite is again polynomial and is given by $p\tri q$. We explained how it looks in terms of algebra, e.g.\ how to compute $\yon^\2\tri(\yon+\1)$; in terms of dependent types, e.g.\ as a sum-product-sum-product $\sum\prod\sum\prod$, which can be reduced to a single $\sum\prod$; in terms of trees, by stacking corollas on top of corollas; and in terms of polyboxes. We paid particular attention to maps into a composite $p\to q\tri r$.

This allowed us to explain how to think of dynamical systems $S\yon^S\to p\tri q$ with composite interfaces as multi-step machines: each state produces a $p$-output, and then for every $p$-input produces a $q$-output, and then for every $q$-input returns an updated $S$-state. 

Finally, we discussed some facts of the composition product. For example, we showed that $-\tri q$ has a left adjoint $\lchom{q}{-}$ and that $q\tri -$ has a left multi-adjoint $-\frown q$. We also explained that $p\tri q$ preserves all with limits in the variable $p$ and all connected limits in the variable $q$. We also explained the duoidal interaction between $\otimes$ and $\tri$, i.e.\ the natural map $\tri\otimes\tri\to\otimes\tri\otimes$, and how $\tri$ interacts with cartesian maps.

Polynomial composition is one of the best known aspects of polynomial functors. Again, see \cite{kock2012polynomial} for more on this. We learned of the left coclosure (see \cref{prop.comp_left_coclosed}) from Josh Meyers, though it may have already been known in the containers community. 
%-------- Section --------%
\section{Exercise solutions}
\Closesolutionfile{solutions}
{\footnotesize
\input{solution-file5}}

\Opensolutionfile{solutions}[solution-file6]

%------------ Chapter ------------%
\chapter{Polynomial comonoids and cofunctors}\label{ch.comon.sharp}

\slogan{Imagine a realm where there are various positions you can be in. From every position, there are a number of moves you can make, possibly infinitely many. But whatever move you make, you'll end up in a new position. Well, technically it counts as a move to simply stay where you are, so you might end up in the same position. But wherever you move to, you can move again, and any number of moves from the original position counts as a single move. What sort of realm is this?}

The most surprising aspects of $\poly$ really begin with its comonoids.
In 2018, researchers Daniel Ahman and Tarmo Uustalu presented a characterization of comonoids in $(\poly,\yon,\tri)$ as a surprisingly familiar construct.
For us, this story will emerge naturally as we continue to expand our understanding of the humble state system of a dependent dynamical system.
Let's go through it.

%-------- Section --------%
\section{State systems, categorically}\label{sec.comon.sharp.state}

Since defining dependent dynamical systems in \cref{def.gen_moore}, we have evolved our understanding of their state systems over the course of the last few chapters. 
Let's take this moment to review what we know about these state systems so far. 

Our original definition of a state system was as a monomial $S\yon^S$ for some set $S$.
But in \cref{ex.do_nothing}, we noted that this formulation requires us to discuss the positions and directions of a state system at the level of sets rather than in the language of $\poly$.
Instead, let's take an arbitrary polynomial $\car{s}\in\poly$ and attempt to characterize what it means for $\car{s}$ to be a state system using only the categorical machinery of $\poly$.
We will continue to refer to the positions of $\car{s}$ as \emph{states}, but we will shift from thinking of the directions of $\car{s}$ as states to thinking of them as transitions from one state to another.

\subsection{The do-nothing enclosure}\label{subsec.comon.sharp.state.nothing}

In \cref{ex.do_nothing}, we saw that every state system $\car{s}$ is equipped with a \emph{do-nothing enclosure}: a lens $\epsilon\colon\car{s}\to\yon$ that picks out a direction at each state that we would like to interpret as ``doing nothing'' and remaining at that state.

We drew $\epsilon$ in polyboxes in \cref{ex.do_nothing_polybox}, but that was when we let ourselves assume that the position-set of a state system was equal to each of its direction-sets.
Now all we know is that for each state $s\in\car{s}(\1)$, the do-nothing enclosure chooses an $\car{s}[s]$-direction to signify staying at the same state; it doesn't make sense to say that this direction is literally equal to $s$.
So we need a different name for the $\car{s}[s]$-direction that $\epsilon$ identifies: call it $\id_s$, because it behaves like a sort of identity operation on the state $s$.

So the revised polyboxes for the do-nothing enclosure $\epsilon\colon\car{s}\to\yon$ are as follows:
\begin{equation} \label{eqn.do_nothing_polybox}
\begin{tikzpicture}[polybox, mapstos]
    \node[poly, dom, "$\car{s}$" left] (S) {$\id_s$\at$s$};

    \draw (S_pos) to[climb'] node[right] {$\epsilon$} (S_dir);
\end{tikzpicture}
\end{equation}

\begin{exercise}
Say I have a polynomial $\car{s}\in\poly$, and I tell you that there is a lens $\epsilon\colon\car{s}\to\yon$.
What can you say about the polynomial $\car{s}$?
\begin{solution}
Given a polynomial $\car{s}\in\poly$ equipped with a lens $\epsilon\colon\car{s}\to\yon$, we know that $\epsilon$ picks out a direction at every position of $\car{s}$.
So all we can say about $\car{s}$ is that there is at least one direction at each of its positions.
Equivalently, we could say that $\car{s}$ can be written as the product of $\yon$ and some other polynomial.
\end{solution}
\end{exercise}

\begin{example}[The do-nothing enclosure in tree pictures] \label{ex.nothing_trees}
We have seen the do-nothing enclosure drawn in polyboxes, but let's see what it looks like in our tree pictures.
We'll take $\car{s}\coloneqq\{\bul[red],\bul[dgreen],\bul[blue]\}\yon^{\{\bul[red],\bul[dgreen],\bul[blue]\}}$, drawn as follows:
\[
\begin{tikzpicture}[rounded corners]
\node (p1) [draw, "$\car{s}\coloneqq$" left] {
    \begin{tikzpicture}[trees, sibling distance=4mm]
        \foreach \i/\c in {1/red, 2/dgreen, 3/blue}
        {
            \node[\c] at (1.8*\i,0) {$\bullet$} 
                child [red]
                child [dgreen]
                child [blue]
                ;
        };
    \end{tikzpicture}
};
\end{tikzpicture}
\]
Then the do-nothing enclosure $\epsilon\colon\car{s}\to\yon$ can be drawn like any one of the following three possibilities:
\[
\begin{tikzpicture}[trees, bend right]
    \foreach \i/\c in {1/red, 2/dgreen, 3/blue}
    {
        \node[\c] (\i) at (3*\i, 0) {$\bullet$} 
            child [red] {coordinate (\i1)}
            child [dgreen] {coordinate (\i2)}
            child [blue] {coordinate (\i3)}
            ;
        \node[right=of \i] (y\i) {$\bullet$}
            child{coordinate (y\i')}
            ;
        \draw[|->, shorten <= 3pt, shorten >= 3pt] (\i) -- (y\i);
        \draw[densely dotted, postaction={decorate}] (y\i') to (\i\i);
    };
\end{tikzpicture}
\]
It picks out one direction at each position, namely the one of the same color.
\end{example}


There is not much else we can say about the do-nothing enclosure on its own, so let us revisit the other lens that every state system is equipped with before considering the relationship between the two.

\subsection{The transition lens}\label{subsec.comon.sharp.state.trans}

We saw in \cref{ex.dyn_sys_trans_polyboxes} that $\car{s}$ also comes equipped with a \emph{transition lens}: a lens $\delta\colon\car{s}\to\car{s}\tri\car{s}$, which we can draw as
\[
\begin{tikzpicture}[polybox, mapstos]
	\node[poly, dom, "$\car{s}$" left] (r) {$a_2'$\at$s_0$};
	\node[poly, cod, right=1.8 of r.south, yshift=-2.5ex, "$\car{s}$" below] (p) {$a_1$\at$s_0$};
	\node[poly, cod, above=.8 of p, "$\car{s}$" above] (p') {$a_2$\at$s_1$};

	\draw[double, -] (r_pos) to[first] node[below] {} (p_pos);
	\draw (p_dir) to[climb] node[right] {tgt} (p'_pos);
	\draw (p'_dir) to[last] node[above=.3] {run} (r_dir);
  \end{tikzpicture}
\]
The arrow labeled tgt is the \emph{target function}: given a state $s_0$ and a direction $a_1$ at that state, $\text{tgt}(s_0,a_1)$ tells us the new state $s_1$ that following $a_1$ from $s_0$ will lead to.
We know that when $s_0$ is fixed, the target function on the second component $a_1$ should be an isomorphism $\car{s}[s_0]\to\car{s}(\1)$; that is, there is exactly one direction at $s_0$ that leads to each state of $\car{s}$.
But this property is a little tricky to state in the language of $\poly$; in fact, we won't attempt to do so just yet.
Instead, we'll use it to make a notational choice: given $s,t\in\car{s}$, we will let $s\to t$ denote the unique direction at $s$ that leads to $t$, so that $\text{tgt}(s,s\to t)=t$.
So we can redraw our transition lens as
\begin{equation} \label{eqn.trans_lens_polybox}
\begin{tikzpicture}[polybox, mapstos]
	\node[poly, dom, "$\car{s}$" left] (r) {$s_0\to s_2$\at$s_0$};
	\node[poly, cod, right=2 of r.south, yshift=-2.5ex, "$\car{s}$" right] (p) {$s_0\to s_1$\at$s_0$};
	\node[poly, cod, above=.8 of p, "$\car{s}$" right] (p') {$s_1\to s_2$\at$s_1$};

	\draw[double, -] (r_pos) to[first] node[below] {} (p_pos);
	\draw (p_dir) to[climb] node[right] {tgt} (p'_pos);
	\draw (p'_dir) to[last] node[above=.4] {run} (r_dir);
  \end{tikzpicture}
\end{equation}
In addition to the fact that $\text{tgt}(s_0,s_0\to s_1)=s_1$ as intended, this picture tells us two more properties of $\delta$.

The first is that the bottom arrow is the identity on $\car{s}(\1)$.
This is something we would like to be able to express categorically in the language of $\poly$.
We'll see that this property falls out naturally when we express how the transition lens plays nicely with the do-nothing enclosure in \cref{subsec.comon.sharp.state.cohere}.

The second is that the run arrow, which runs the transition $s_0\to s_1$ and the transition $s_1\to s_2$ together into a transition starting at $s_0$, should have the same target as tfhe second transition it follows: in this case, $s_2$.
Equationally, writing the left and right hand sides only in terms of the contents of the blue boxes, we have that
\begin{equation} \label{eqn.state_run_tgt}
    \text{tgt}(s_0,\text{run}(s_0,s_0\to s_1,s_1\to s_2))=s_2=\text{tgt}(\text{tgt}(s_0,s_0\to s_1),s_1\to s_2).
\end{equation}
We'll see that this property arises naturally when we we generalize the transition lens to more than two steps in \cref{subsec.comon.sharp.state.coassoc}.

\begin{example}[The transition lens in tree pictures] \label{ex.trans_trees}
Continuing from \cref{ex.nothing_trees}, we draw the transition lens $\delta\colon\car{s}\to\car{s}\tri\car{s}$ of $\car{s}\coloneqq\3\yon^\3\iso\{\bul[red],\bul[dgreen],\bul[blue]\}\yon^{\{\bul[red],\bul[dgreen],\bul[blue]\}}$ (where directions are labeled with their targets) in tree pictures as well, recalling that the trees of $\car{s}\tri\car{s}$ are obtained by taking an $\car{s}$-corolla and gluing more $\car{s}$-corollas to each of its leaves:
\[
\begin{tikzpicture}[trees, 
  level 1/.style={sibling distance=5mm},
  level 2/.style={sibling distance=1.5mm},
	bend right=60]
	\foreach \i/\c in {1/red, 2/dgreen, 3/blue}
	{
  	\node[\c] (\i) at (4*\i, 0) {$\bullet$} 
    	child [red] {coordinate (\i1)}
      child [dgreen] {coordinate (\i2)}
      child [blue] {coordinate (\i3)}
     	;
  	\node[right=1.7 of \i, \c] (SS\i) {$\bullet$}
  		child [red] {node (S\i1) {$\bullet$} 
				child [red] {coordinate (\i11)}
				child [dgreen] {coordinate (\i12)} 
				child [blue] {coordinate (\i13)}
				}
  		child [dgreen] {node (S\i2) {$\bullet$} 
				child [red] {coordinate (\i21)}
				child [dgreen] {coordinate (\i22)} 
				child [blue] {coordinate (\i23)}
				}
  		child [blue] {node (S\i3) {$\bullet$} 
				child [red] {coordinate (\i31)}
				child [dgreen] {coordinate (\i32)} 
				child [blue] {coordinate (\i33)}
				}
  		;
	\draw[|->, shorten <= 3pt, shorten >= 3pt] (\i) -- (SS\i);
	\foreach \j in {1,2,3}
	{
		\foreach \k\d in {1/red, 2/dgreen, 3/blue}
		{
			\draw[densely dotted, postaction={decorate}, \d] (\i\j\k) to (\i\k);
		};
	};
	};
\end{tikzpicture}
\]
On positions, the target function of $\delta$ tells us which root of $\car{s}$ to glue to each leaf of $\car{s}$.
Then on directions, the run function of $\delta$ tells us how to collapse the height-$2$ leaves of the trees we obtain in $\car{s}\tri\car{s}$ down to the original height-$1$ leaves of the corollas of $\car{s}$.

We can draw what the target function is doing more compactly by taking the corollas of $\car{s}$ and ``bending the arrows'' so that they point to their targets, like so:
\[
\begin{tikzpicture}
    \node[circle,minimum size=2cm] (b) {};
    \foreach\x/\c in {1/red, 2/dgreen, 3/blue} {
        \node[minimum size=0.1cm,draw,circle,\c,fill=\c] (3-\x) at (b.{360/3*\x}){};
    }
    \foreach\x/\c in {1/red, 2/dgreen, 3/blue} {
        \foreach\y/\d in {1/red, 2/dgreen, 3/blue}{
            \ifnum\x=\y
                \draw[\d,->] (3-\x) to [in=360/3*\x-15,out=360/3*\x+15,loop] ();
                \relax
            \else
                \draw[\d] (3-\x) edge[->,bend right=10] (3-\y);
            \fi
        }
    }
\end{tikzpicture}
\]
So the target function of $\delta$ turns our corolla picture of $\car{s}$ into a complete graph on its roots!
Then the run function takes any two arrows that form a path in the graph and collapses them down to a single arrow that starts (and, according to \eqref{eqn.state_run_tgt}, ends) at the same vertex as the two-arrow path.

If this all sounds suspiciously familiar to you, you're on the right track---hang tight.
\end{example}

\subsection{The do-nothing enclosure coheres with the transition lens}\label{subsec.comon.sharp.state.cohere}

For each state $s\in\car{s}(\1)$, the do-nothing enclosure $\epsilon\colon\car{s}\to\yon$ picks out the $\car{s}[s]$-direction $\id_s$ that ``does nothing'' and keeps the system in the same state $s$.
But it is the transition lens $\delta\colon\car{s}\to\car{s}\tri\car{s}$ that actually sets our state system in motion, specifying the target of each direction and how two directions run together.
Either of these directions could be our do-nothing direction $\id_s$, so let's try to figure out what should happen when we set each one in turn to $\id_s$.

We can draw in polyboxes what happens when we set $\id_s$, as specified by $\epsilon$, to be the first direction that $\delta$ runs together like this:
\[
\begin{tikzpicture}[polybox, mapstos]
	\node[poly, dom, "$\car{s}$" left] (r) {\at$s$};
	\node[poly, right=2 of r.south, yshift=-2.5ex, "$\car{s}$" below] (p) {$\id_s$\at$s$};
	\node[poly, cod, above=.8 of p, xshift=2.5ex, "$\car{s}$" above] (p') {tgt$(s,\id_s)\to t$\at tgt$(s,\id_s)$};

	\draw[double, -] (r_pos) to[first] node[below] {} (p_pos);
	\draw (p_pos) to[climb'] node[right] {$\epsilon$} (p_dir);
	\draw (p_dir) to[climb] node[right] {tgt} (p'_pos);
	\draw (p'_dir) to[last] node[above=.4] {run} (r_dir);
\end{tikzpicture}
\]
Reading this picture from left to right, we see that it depicts the polyboxes of the composite lens $\delta\then(\epsilon\tri\car{s})\colon\car{s}\to\yon\tri\car{s}\iso\car{s}$ (recall that we sometimes denote the identity lens on $\car{s}$ also by $\car{s}$).
To make this interpretation more transparent, we could be a little more verbose with our polybox picture if we wanted to (omitting the contents of the boxes for clarity):
\[
\begin{tikzpicture}
    \node (1) {
        \begin{tikzpicture}[polybox, tos]
        	\node[poly, dom, "$\car{s}$" left] (r) {};
        	\node[poly, right=2 of r.south, yshift=-2.5ex, "$\car{s}$" below] (p) {};
        	\node[poly, cod, above=.8 of p, "$\car{s}$" above] (p') {};
        
        	\draw[double, -] (r_pos) to[first]  (p_pos.west);
        	\draw (p_pos) to[climb'] node[right] {$\epsilon$} (p_dir);
        	\draw (p_dir) to[climb] node[right] {tgt} (p'_pos);
        	\draw (p'_dir) to[last] node[above=.3] {run} (r_dir);
        \end{tikzpicture}
	};
	\node[right=1 of 1] (2) {
	    \begin{tikzpicture}[polybox, tos]
            \node[poly, dom, "$\car{s}$" left] (yX) {};
        	\node[poly, right=2 of yX.south, yshift=-2.5ex, "$\car{s}$" below] (p) {};
            \node[poly, above=.8 of p, "$\car{s}$" above] (p') {};
            \node[poly, cod, identity, right=of p, "$\car{s}$" below] (q) {};
            \node[poly, cod, above=.8 of q, "$\car{s}$" above] (q') {};
            \draw (p_pos) -- node[below] {$\epsilon_\1$} (q_pos);
            \draw (q_dir) -- node[above] {$\epsilon^\sharp$} (p_dir);
            \draw[double, -] (p'_pos) -- (q'_pos);
            \draw[double, -] (q'_dir) -- (p'_dir);
            \draw[double, -] (yX_pos) to[first] node[below] {} (p_pos);
            \draw (p_dir) to[climb] node[right] {tgt} (p'_pos);
            \draw (p'_dir) to[last] node[above=.3] {run} (yX_dir);
        \end{tikzpicture}
	};
	\node at ($(1.east)!.5!(2.west)$) {=};
\end{tikzpicture}
\]
Now what should $\text{tgt}(\id_s)$ be, and what should go in the direction box on the left?

If following the direction $\id_s$ from the state $s$ is really the same as doing nothing, then its target state should be the same state $s$ that it emerged from.
Moreover, running together $\id_s$ with any other direction $s\to t$ from $s$ should be no different from the direction $s\to t$ on its own.
So
\[
    \text{tgt}(s,\id_s)=s \qqand \text{run}(s,\id_s,s\to t)=s\to t.
\]
In fact, $\id_s$ should really just be the direction $s\to s$.
Pictorially, we have the equation
\[
\begin{tikzpicture}
	\node (1) {
        \begin{tikzpicture}[polybox, mapstos]
        	\node[poly, dom, "$\car{s}$" left] (r) {\at$s$};
        	\node[poly, right=2 of r.south, yshift=-2.5ex, "$\car{s}$" below] (p) {$\id_s$\at$s$};
        	\node[poly, cod, above=.8 of p, xshift=2.5ex, "$\car{s}$" above] (p') {tgt$(s,\id_s)\to t$\at tgt$(s,\id_s)$};
        
        	\draw[double, -] (r_pos) to[first] node[below] {} (p_pos);
        	\draw (p_pos) to[climb'] node[right] {$\epsilon$} (p_dir);
        	\draw (p_dir) to[climb] node[right] {tgt} (p'_pos);
        	\draw (p'_dir) to[last] node[above=.4] {run} (r_dir);
        \end{tikzpicture}
	};
	\node[right=1.8 of 1] (2) {
        \begin{tikzpicture}[polybox, mapstos]
          	\node[poly, dom, "$\car{s}$" left] (c) {$s\to t$\at$s$};
          	\node[poly, cod, right=of c, "$\car{s}$" right] (c') {$s\to t$\at$s$};
          	\draw[double, -] (c_pos) -- (c'_pos);
          	\draw[double, -] (c'_dir) -- (c_dir);
	    \end{tikzpicture}
	};
	\node at ($(1.east)!.5!(2.west)$) {=};
\end{tikzpicture}
\]
Or, if you prefer, we might say that $\delta\then(\epsilon\tri\car{s})=\id_{\car{s}}$, or that the following diagram commutes:
\[
\begin{tikzcd}[row sep=large]
    \yon\tri\car{s} & \car{s}\ar[d, "\delta"]\ar[l, equal] \\
    & \car{s}\tri\car{s}\ar[ul, "\epsilon\:\tri\:\car{s}"]
\end{tikzcd}
\]
This commutative diagram captures one way in which $\epsilon$ and $\delta$ always relate---and it's written entirely in the language of $\poly$, without having to talk about individual sets!

What about setting the second direction that $\delta$ runs together to what is specified by $\epsilon$, rather than the first?
To answer this, we should look at the composite lens $\delta\then(\car{s}\tri\epsilon)\colon\car{s}\to\car{s}\tri\yon\iso\car{s}$ instead.
But the do-nothing direction should still do nothing, so here's what the polybox picture should look like:
\[
\begin{tikzpicture}
	\node (1) {
        \begin{tikzpicture}[polybox, mapstos]
        	\node[poly, dom, "$\car{s}$" left] (r) {$s\to t$\at$s$};
        	\node[poly, cod, right=2 of r.south, yshift=-2.5ex, "$\car{s}$" below] (p) {$s\to t$\at$s$};
        	\node[poly, above=.8 of p, "$\car{s}$" above] (p') {$\id_t$\at $t$};
        
        	\draw[double, -] (r_pos) to[first] node[below] {} (p_pos);
        	\draw (p_dir) to[climb] node[right] {tgt} (p'_pos);	\draw (p'_pos) to[climb'] node[right] {$\epsilon$} (p'_dir);
        	\draw (p'_dir) to[last] node[above=.4] {run} (r_dir);
        \end{tikzpicture}
	};
	\node[right=1.8 of 1] (2) {
        \begin{tikzpicture}[polybox, mapstos]
          	\node[poly, dom, "$\car{s}$" left] (c) {$s\to t$\at$s$};
          	\node[poly, cod, right=of c, "$\car{s}$" right] (c') {$s\to t$\at$s$};
          	\draw[double, -] (c_pos) -- (c'_pos);
          	\draw[double, -] (c'_dir) -- (c_dir);
	    \end{tikzpicture}
	};
	\node at ($(1.east)!.5!(2.west)$) {=};
\end{tikzpicture}
\]
The lens depicted on the right hand side of the equation is again the identity lens on $\car{s}$.

If we match up the two white boxes on the right hand side of the equation with the corresponding white boxes on the left, we can actually read two equations off of this polybox picture.
Matching up positions in the codomain tells us that the bottom arrow of $\delta$ on the left must send $s$ to itself: it is the identity function on $\car{s}(\1)$.
Indeed, this is exactly what we wanted to say about that arrow in \cref{subsec.comon.sharp.state.trans}.

Meanwhile, matching up directions in the domain tells us that
\[
    \text{run}(s,s\to t,\id_t)=s\to t,
\]
as we would expect: $\id_t$ is just be the direction $t\to t$.

More concisely, we can express both these facts in $\poly$ via the equation $\delta\then(\car{s}\tri\epsilon)=\id_{\car{s}}$.
The corresponding commutative diagram is as follows:
\[
\begin{tikzcd}[row sep=large]
    \car{s}\ar[d, "\delta"']\ar[r, equal] & \car{s}\tri\yon \\
    \car{s}\tri\car{s}.\ar[ur, "\car{s}\:\tri\:\epsilon"']
\end{tikzcd}
\]
We can combine this with our previous commutative diagram to say that the relationship between the do-nothing enclosure $\epsilon\colon\car{s}\to\yon$ and the transition lens $\delta\colon\car{s}\to\car{s}\tri\car{s}$ of a state system $\car{s}$ is captured in $\poly$ by the following commutative diagram:
\begin{equation}\label{eqn.erasure_law_state}
\begin{tikzcd}[row sep=large]
	\yon\tri\car{s}&\car{s}\ar[d, "\delta" description]\ar[r, equal]\ar[l, equal]&\car{s}\tri\yon\\&
	\car{s}\tri\car{s}.\ar[ul, "\epsilon\:\tri\:\car{s}"]\ar[ur, "\car{s}\:\tri\:\epsilon"']
\end{tikzcd}
\end{equation}

\subsection{The transition lens is coassociative}\label{subsec.comon.sharp.state.coassoc}

Toward the end of \cref{ex.dyn_sys_trans_polyboxes}, we noted that while the transition lens $\delta\colon\car{s}\to\car{s}\tri\car{s}$ gives us a canonical way to model two steps of a dynamical system with state system $\car{s}$, we have a choice of how to model three steps through the same system: we could obtain a lens $\car{s}\to\car{s}\tripow3$ that runs three directions together by taking either one of the composite lenses $\delta\then(\delta\tri\car{s})$ or $\delta\then(\car{s}\tri\delta)$.
That presents a problem for us: which one should we choose?

Happily, it turns out this choice is a false one.
If we write out the two composite lenses in polyboxes, with $\delta\then(\delta\tri\car{s})$ on the left and $\delta\then(\car{s}\tri\delta)$ on the right, we find that they are equal:
\begin{equation}\label{eqn.trans_lens_coassoc_polybox}
\begin{tikzpicture}
    \node (p1) {
        \begin{tikzpicture}[polybox, mapstos, font=\tiny]
            \node[poly, dom, "$\car{s}$" left] (m') {$s_0\to s_3$\at$s_0$};
            \node[poly, right= of m'.south, yshift=-1ex, "$\car{s}$" below] (mm') {$s_0\to s_2$\at$s_0$};
            \node[poly, above=of mm', "$\car{s}$" above] (C') {$s_2\to s_3$\at$s_2$};
            \node[poly, cod, right= of mm'.south, yshift=-1ex, "$\car{s}$" right] (D') {$s_0\to s_1$\at$s_0$};
            \node[poly, cod, above=of D', "$\car{s}$" right] (mmm') {$s_1\to s_2$\at$s_1$};
            \node[poly, cod, above=of mmm', "$\car{s}$" right] (CC') {$s_2\to s_3$\at$s_2$};
            %
            \draw[double, -] (m'_pos) to[first] (mm'_pos);
            \draw (mm'_dir) to[climb] node[right] {tgt} (C'_pos);
            \draw (C'_dir) to[last] node[above, sloped] {run} (m'_dir);
            \draw[double, -] (mm'_pos) to[first] (D'_pos);
            \draw (D'_dir) to[climb] node[right] {tgt} (mmm'_pos);
            \draw (mmm'_dir) to[last] node[above, sloped] {run} (mm'_dir);
            \draw[double, -] (C'_pos) to[first] (CC'_pos);
            \draw[double, -] (CC'_dir) to[last] (C'_dir);
        \end{tikzpicture}
	};
%
	\node (p2) [right=of p1] {
	    \begin{tikzpicture}[polybox, mapstos, font=\tiny]
            \node[poly, dom, "$\car{s}$" left] (m) {$s_0\to s_3$\at$s_0$};
            \node[poly, right= of m.south, yshift=-1ex, "$\car{s}$" below] (D) {$s_0\to s_1$\at$s_0$};
            \node[poly, above=of D, "$\car{s}$" above] (mm) {$s_1\to s_3$\at$s_1$};
            \node[poly, cod, right= of D.south, yshift=-1ex, "$\car{s}$" right] (DD) {$s_0\to s_1$\at$s_0$};
            \node[poly, cod, above=of DD, "$\car{s}$" right] (mmm) {$s_1\to s_2$\at$s_1$};
            \node[poly, cod, above=of mmm, "$\car{s}$" right] (C) {$s_2\to s_3$\at$s_2$};
            %
            \draw[double, -] (m_pos) to[first] (D_pos);
            \draw (D_dir) to[climb] node[right] {tgt} (mm_pos);
            \draw (mm_dir) to[last] node[above, sloped] {run} (m_dir);
            \draw[double, -] (D_pos) to[first] (DD_pos);
            \draw[double, -] (DD_dir) to[last] (D_dir);
            \draw[double, -] (mm_pos) to[first] (mmm_pos);
            \draw (mmm_dir) to[climb] node[right] {tgt} (C_pos);
            \draw (C_dir) to[last] node[above, sloped] {run} (mm_dir);
        \end{tikzpicture}
    };	
	\node at ($(p1.south)!.5!(p2.north)$) {$=$};
\end{tikzpicture}
\end{equation}
Remember: the way to read these polyboxes is to start at the lower blue square on the left and follow the path counter clockwise around the diagram; and if you reach a box with no arrows leading out of it, go up to the blue box above it and continue to follow the arrows from there.

There's a lot going on here, so let's break it down---we'll focus on the run functions first.
On the left hand side, we run together $s_0\to s_1$ and $s_1\to s_2$ to obtain $s_0\to s_2$, before running that together with $s_2\to s_3$ to obtain $s_0\to s_3$, as we see in the upper left box.
Meanwhile, on the right, we run together $s_1\to s_2$ and $s_2\to s_3$ to obtain $s_1\to s_3$, before running $s_0\to s_1$ together with our newly obtained $s_1\to s_3$ to again obtain $s_0\to s_3$ in the upper left box.
We could write this all out equationally, but all this is saying is that ``running together'' the directions of a state system is an associative operation.
When running together three directions, it doesn't matter whether we run the first two together or the last two together to start.
Not only is this guaranteed by the way in which we constructed $\delta$, it also makes intuitive sense.

\begin{exercise}
Using only the contents of the blue boxes and the target and run functions, write down the equation that we can read off of \eqref{eqn.trans_lens_coassoc_polybox} expressing the associativity of the ``running together'' operation.
\begin{solution}
Following the arrows on either side of \eqref{eqn.trans_lens_coassoc_polybox} all the way to the domain's direction box, we obtain an expression for each box's contents that we can then set equal to each other.
The easiest way to actually write down these expressions is probably to start at the end with $s_0\to s_3$ and follow the arrows backward, unpacking each term until only the contents of the blue boxes remain (namely $s_0, s_0\to s_1, s_1\to s_2,$ and $s_2\to s_3$).
Here's what we get when we follow this process for the left hand side of \eqref{eqn.trans_lens_coassoc_polybox} (remember where to look for the three inputs to the run function):
\begin{align*}
    s_0\to s_3&=\text{run}(s_0,s_0\to s_2,s_2\to s_3)\\
    &=\text{run}(s_0,\text{run}(s_0,s_0\to s_1,s_1\to s_2),s_2\to s_3)\\
    &=\text{run}(s_0,\text{run}(s_0,s_0\to s_1,s_1\to s_2),s_2\to s_3);
\end{align*}
and here's what we get for the right (also remember where to look for the two inputs to the target function):
\begin{align*}
    s_0\to s_3&=\text{run}(s_0,s_0\to s_1,s_1\to s_3)\\
    &=\text{run}(s_0,s_0\to s_1,\text{run}(s_1,s_1\to s_2,s_2\to s_3))\\
    &=\text{run}(s_0,s_0\to s_1,\text{run}(\text{tgt}(s_0,s_0\to s_1),s_1\to s_2,s_2\to s_3)).
\end{align*}
Setting these equal yields our desired associativity equation:
\[
    \text{run}(s_0,\text{run}(s_0,s_0\to s_1,s_1\to s_2),s_2\to s_3)=\text{run}(s_0,s_0\to s_1,\text{run}(\text{tgt}(s_0,s_0\to s_1),s_1\to s_2,s_2\to s_3)).
\]
\end{solution}
\end{exercise}

This associative property is what we get by matching up the white direction boxes on each domain side, but there are three more white position boxes on each codomain side that we can match up as well.
The fact that the lower two of these pairs coincide is a consequence of the fact that the bottom arrow of $\delta$ is the identity, which we already knew from \cref{subsec.comon.sharp.state.cohere}; so we don't learn anything new there.
On the other hand, the fact that both the upper position boxes in the codomain contain $s_2$ implies that
\begin{align*}
    \text{tgt}(s_0,\text{run}(s_0,s_0\to s_1,s_1\to s_2))&=\text{tgt}(s_0,s_0\to s_2)\\
    &=s_2\\
    &=\text{tgt}(s_1,s_1\to s_2)\\
    &=\text{tgt}(\text{tgt}(s_0,s_0\to s_1),s_1\to s_2),
\end{align*}
which is exactly what we wanted in \eqref{eqn.state_run_tgt}.
In English, this says that when we run together $s_0\to s_1$ and $s_1\to s_2$, the new direction's target is the same as the direction of $s_1\to s_2$, the latter of the two directions that we ran together.
Again, this coincides with our intuition: if we follow two directions in order, we should end up at wherever the latter direction leads us.

Hence both the associativity of running directions together and the relationship between the target and run functions from \eqref{eqn.state_run_tgt} are captured by the equality of lenses $\delta\then(\delta\tri\car{s})=\delta\then(\car{s}\tri\delta)$.
Equivalently, the following diagram in $\poly$ commutes:
\begin{equation}\label{eqn.coassoc_law_states}
\begin{tikzcd}[row sep=large]
	\car{s}\ar[r, "\delta"]\ar[d, "\delta"']&
	\car{s}\tri\car{s}\ar[d, "\car{s}\:\tri\:\delta"]\\
	\car{s}\tri\car{s}\ar[r, "\delta\:\tri\:\car{s}"']&
	\car{s}\tri\car{s}\tri\car{s}.
\end{tikzcd}
\end{equation}
Another way to say this is that $\delta$ is \emph{coassociative}: while $\delta$ is only a lens $\car{s}\to\car{s}\tripow2$ as defined, the commutativity of \eqref{eqn.coassoc_law_states} tells us that the two ways of getting a lens $\car{s}\to\car{s}\tripow3$ out of $\delta$ are actually the same.
(This is dual to an \emph{associative} operation, which is a binary operation that gives rise to two identical ternary operations.)

So $\delta$ induces a canonical lens $\car{s}\to\car{s}\tripow3$, which we will call $\delta^{(3)}$, as it has $3$ copies of $\car{s}$ in its codomain.
Armed with this new lens, we can model three steps through a system $\varphi\colon\car{s}\to p$ with interface $p\in\poly$ as the composite lens
\[
    \car{s}\To{\delta^{(3)}}\car{s}\tripow3\To{\varphi\tripow3}p\tripow3.
\]

In fact, coassociativity guarantees that $\delta$ induces a canonical lens $\delta^{(n)}\colon\car{s}\to\car{s}\tripow{n}$ for every integer $n\geq2$, starting with $\delta^{(2)}\coloneqq\delta$.%
\footnote{Perhaps this notation seems a little unnatural, but it helps to think of the original $\delta\colon\car{s}\to\car{s}\tri\car{s}$ as the $n=2$ case of a generalized transition lens modeling $n$ steps through the state system.}
For concreteness, we could then define $\delta^{(n)}$ for $n>2$ inductively by $\delta^{(n)}\coloneqq\delta\then(\delta^{(n-1)}\tri\car{s})$, or just as well by $\delta^{(n)}\coloneqq\delta\then(\car{s}\tri\delta^{(n-1)})$ or even $\delta^{(n)}\coloneqq\delta\then(\delta^{(\ell)}\tri\delta^{(m)})$ for some pair of integers $\ell,m>1$ satisfying $\ell+m=n$.
Regardless, the coassociativity of $\delta$ means that it doesn't matter how we build a lens $\car{s}\to\car{s}\tripow{(n+1)}$ out of $\delta,\then,\tri,$ and identity lenses: we'll always end up with the same lens.
We will state this in more generality in \cref{prop.n_duplication}, but here's some practice with the $n=4$ case for a taste of what's to come. 

\begin{exercise}
\begin{enumerate}
    \item Say we know nothing about $\car{s}$ or $\delta$ apart from the fact that $\car{s}\in\poly$ and that $\delta$ is a lens $\car{s}\to\car{s}\tri\car{s}$.
    List all the ways to obtain a lens $\car{s}\to\car{s}\tripow4$ using only copies of $\delta,\id_\car{s}$, $\tri$, and $\then$.
    (You may write $\car{s}$ for $\id_\car{s}$.)

    \item Now assume that \eqref{eqn.coassoc_law_states} commutes.
    Show that all the lenses on your list are equal.
    (Hint: Use the fact that $(f\then g)\tri(h\then k)=(f\tri h)\then(g\tri k)$ for lenses $f,g,h,k$).
    \qedhere
\end{enumerate}
\begin{solution}
\begin{enumerate}
    \item Given $\car{s}\in\poly$ and a lens $\delta\colon\car{s}\to\car{s}\tri\car{s}$, we want all the ways to obtain a lens $\car{s}\to\car{s}\tripow4$ using $\delta,\id_\car{s}$ (i.e.\ $\car{s}$), $\tri,$ and $\then$.
    Starting with $\car{s}$, the only way to get to $\car{s}\tripow2$ is with a single $\delta\colon\car{s}\to\car{s}\tripow2$.
    From there, we can get to $\car{s}\tripow4$ directly by composing with $\delta\tri\delta$ to obtain $\delta\then(\delta\tri\delta)$.
    Alternatively, we can preserve either the first or the second $\car{s}$ using the identity, then get to $\car{s}\tripow3$ from the other $\car{s}$ in one of two ways: either $\delta\then(\delta\tri\car{s})$ or $\delta\then(\car{s}\tri\delta)$.
    This gives us $4$ more ways to write a lens $\car{s}\to\car{s}\tripow4$: either $\delta\then(\car{s}\tri(\delta\then(\delta\tri\car{s})))$ or $\delta\then(\car{s}\tri(\delta\then(\car{s}\tri\delta)))$ if we chose to preserve the first $\car{s}$, and either $\delta\then((\delta\then(\delta\tri\car{s}))\tri\car{s})$ or $\delta\then((\delta\then(\car{s}\tri\delta))\tri\car{s})$ if we chose to preserve the second.
    Here's the full list, sorted roughly by how far to the left we try to apply each $\delta$:
    \begin{enumerate}[label=(\arabic*)]
        \item $\delta\then((\delta\then(\delta\tri\car{s}))\tri\car{s})$
        \item $\delta\then((\delta\then(\car{s}\tri\delta))\tri\car{s})$
        \item $\delta\then(\delta\tri\delta)$
        \item $\delta\then(\car{s}\tri(\delta\then(\delta\tri\car{s})))$
        \item $\delta\then(\car{s}\tri(\delta\then(\car{s}\tri\delta)))$
    \end{enumerate}
    This coincides with the $5$ different ways to parenthesize a $4$-term expression.
    
    \item We wish to show that if \eqref{eqn.coassoc_law_states} commutes, then all the lenses on our list are equal.
    The commutativity of \eqref{eqn.coassoc_law_states} implies that $\delta\then(\delta\tri\car{s})=\delta\then(\car{s}\tri\delta)$; so (1) and (2) from our list are equal, as are (4) and (5).
    Meanwhile, since $\car{s}=\car{s}\then\car{s}$, we can rewrite (1) as
    \[
        \delta\then((\delta\then(\delta\tri\car{s}))\tri(\car{s}\then\car{s}))=\delta\then(\delta\tri\car{s})\then(\delta\tri\car{s}\tri\car{s}),
    \]
    where the associativity of $\tri$ and $\then$ allows us to drop some parentheses.
    Then the commutativity of \eqref{eqn.coassoc_law_states} allows us to further rewrite this as
    \begin{align*}
        \delta\then(\car{s}\tri\delta)\then(\delta\tri\car{s}\tri\car{s})&=\delta\then((\car{s}\then\delta)\tri(\delta\then(\car{s}\tri\car{s})))\\
        &=\delta\then(\delta\tri\delta),
    \end{align*}
    so (1) and (3) are equal.
    Similarly, we can rewrite (5) as
    \begin{align*}
        \delta\then((\car{s}\then\car{s})\tri(\delta\then(\car{s}\tri\delta)))&=\delta\then(\car{s}\tri\delta)\then(\car{s}\tri\car{s}\tri\delta)\\
        &=\delta\then(\delta\tri\car{s})\then(\car{s}\tri\car{s}\tri\delta)\\
        &=\delta\then((\delta\then(\car{s}\tri\car{s}))\tri(\car{s}\then\delta))\\
        &=\delta\then(\delta\tri\delta)
    \end{align*}
    so (3) and (5) are equal.
    Hence all the lenses on our list are equal.
\end{enumerate}
\end{solution}
\end{exercise}

\subsection{Running dynamical systems}\label{subsec.comon.sharp.state.run}

Finally, we are ready to fulfill our promise from way back in \cref{ex.do_nothing} by using the language of $\poly$ to describe stepping through a dynamical system $n$ times for arbitrary $n\in\nn$.
Given a dynamical system $\varphi\colon\car{s}\to p$ with interface $p\in\poly$, we can construct a new dynamical system that we call $\text{Run}_n(\varphi)$, with the same state system $\car{s}$ but a new interface $p\tripow{n}$, by defining $\text{Run}_n(\varphi)\coloneqq\delta^{(n)}\then\varphi\tripow{n}$.
Visually, we define $\text{Run}_n(\varphi)$ so that the following diagram commutes:
\begin{equation}\label{eqn.speedup}
\begin{tikzcd}
	\car{s}\ar[r, "\delta^{(n)}"]\ar[rr, bend right, "{\text{Run}_n(\varphi)}"']&
	\car{s}\tripow{n}\ar[r, "\varphi\tripow{n}"]&
	p\tripow n
\end{tikzcd}
\end{equation}
One way to think of this is that $\text{Run}_n(\varphi)$ is a sped-up version of $\varphi$: one step through $\text{Run}_n(\varphi)$ is equivalent to $n$ steps through $\varphi$.
But this is just because a single interaction with the interface $p\tripow{n}$ models a sequence of $n$ interactions with the interface $p$, as detailed in \cref{subsec.comon.comp.def.dyn_sys,ex.dyn_sys_comp_polyboxes}.
So $\text{Run}_n(\varphi)$ repackages $n$ cycles through $\varphi$ into a single step.
Crucially, $\delta^{(n)}$ is what tells us how to sequence all $n$ of these steps together on the state system side.
We illustrated how $\delta$ does this for the $n=2$ case in \cref{ex.dyn_sys_trans_polyboxes}, and here's a polybox picture for the $n=3$ case:
\[
\begin{tikzpicture}
	\node (given) {
	\begin{tikzpicture}[polybox, tos]
		\node[poly, dom, blue, "$\car{s}$" left] (S) {};
		\node[poly, cod, dgreen, right=of S, "$p$" right] (p) {};
		\draw (S_pos) to[first] (p_pos);
		\draw (p_dir) to[last]  (S_dir);
		\node at ($(S.east)!.5!(p.west)$) {$\varphi$};
	\end{tikzpicture}
	};
	\node[right=of given] (obtain) {
	\begin{tikzpicture}[polybox, tos]
		\node[poly, dom, blue, "$\car{s}$" left] (S) {};
		\node[poly, blue, right=of S] (S2) {};
		\node[poly, blue, below=of S2] (S1) {};
		\node[poly, blue, above=of S2] (S3) {};
		\node[poly, dgreen, cod, right=of S1, "$p$" right] (p1) {};
		\node[poly, dgreen, cod, right=of S2, "$p$" right] (p2) {};
		\node[poly, dgreen, cod, right=of S3, "$p$" right] (p3) {};
%
		\draw (S1_pos) to[first] (p1_pos);
		\draw (p1_dir) to[last] (S1_dir);		
		\draw (S2_pos) to[first] (p2_pos);
		\draw (p2_dir) to[last]  (S2_dir);		
		\draw (S3_pos) to[first] (p3_pos);
		\draw (p3_dir) to[last]  (S3_dir);
		\draw[blue] (S_pos) to[first] (S1_pos);
		\draw[blue] (S1_dir) to[climb] (S2_pos);
		\draw[blue] (S2_dir) to[climb] (S3_pos);
		\draw[blue] (S3_dir) to[last] (S_dir);
		\node[blue] at ($(S.east)!.33!(S2.west)$) {$\delta^{(3)}$};
		\node at ($(S1.east)!.33!(p1.west)$) {$\varphi$};
		\node at ($(S2.east)!.33!(p2.west)$) {$\varphi$};
		\node at ($(S3.east)!.33!(p3.west)$) {$\varphi$};		
  \end{tikzpicture}	
	};
	\node[above] at (obtain.north) (obtain_lab) {obtain $\text{Run}_3(\varphi)$:};
	\node at (given|-obtain_lab) {Given $\varphi\colon \car{s}\to p$,};
\end{tikzpicture}
\]
Notice that we have only defined $\delta^{(n)}$, and thus $\text{Run}_n(\varphi)$, for integers $n\geq2$.
But $n=0$ runs through $n$ is doing nothing, modeled by the do-nothing enclosure $\epsilon\colon\car{s}\to\yon$, while $n=1$ run through $\varphi$ is modeled by $\varphi\colon\car{s}\to\car{s}$ itself.
So we want $\text{Run}_0(\varphi)=\epsilon$ and $\text{Run}_1(\varphi)=\varphi$; we can achieve this by setting $\delta^{(0)}\coloneqq\epsilon$ and $\delta^{(1)}\coloneqq\id_\car{s}$.
Here we should think of the do-nothing enclosure $\delta^{(0)}$ as the transition lens modeling $0$ steps through our state system, and the identity $\delta^{(1)}$ as the transition lens modeling a single step.

\begin{exercise}
Verify that when $\delta^{(0)}=\epsilon$ and $\delta^{(1)}=\id_\car{s}$, if $\text{Run}_n(\varphi)$ is defined as $\delta^{(n)}\then\varphi\tripow{n}$ for all $n\in\nn$, then $\text{Run}_0(\varphi)=\epsilon$ and $\text{Run}_1(\varphi)=\id_\car{s}$.
\begin{solution}
We have $\text{Run}_n(\varphi)=\delta^{(n)}\then\varphi\tripow{n}$ for all $n\in\nn$, as well as $\delta^{(0)}=\epsilon$ and $\delta^{(1)}=\id_\car{s}$.
Then $\text{Run}_0(\varphi)=\epsilon\then\varphi\tripow0=\epsilon\then\id_\yon=\epsilon$ and $\text{Run}_1(\varphi)=\id_\car{s}\then\varphi\tripow1=\varphi\tripow1=\varphi$.
\end{solution}
\end{exercise}

One drawback of the $\text{Run}_n(-)$ operation is that we need to keep track of a separate morphism $S\yon^S\to p\tripow{n}$ for every $n\in\nn$, as well as various ways to relate these morphisms for different values of $n$.
Is there a way to package all this information into a single morphism that can model arbitrarily long runs through the system?
We will answer this question in \cref{ch.comon.cofree}; but for now, let us investigate what's really going on with our state systems algebraically.

\subsection{State systems as comonoids}

It turns out that objects equipped with morphisms like those in \cref{subsec.comon.sharp.state.nothing,subsec.comon.sharp.state.trans} that satisfy the commutative diagrams from \cref{subsec.comon.sharp.state.cohere,subsec.comon.sharp.state.coassoc} are well-known to category theorists.

\begin{definition}[Comonoid]\label{def.comonoid}
In a monoidal category $(\Cat{C},\yon,\tri)$, a \emph{comonoid} $\com{C}\coloneqq(\car{c},\epsilon,\delta)$ consists of
\begin{itemize}
    \item an object $\car{c}\in\Cat{C}$, called the \emph{carrier};
    \item a morphism $\epsilon\colon\car{c}\to\yon$ in $\Cat{C}$, called the \emph{eraser} (or the \emph{counit}); and
    \item a morphism $\delta\colon\car{c}\to\car{c}\tri\car{c}$ in $\Cat{C}$, called the \emph{duplicator} (or the \emph{comultiplication});
\end{itemize}
such that the following diagrams, collectively known as the \emph{comonoid laws}, commute: 
\begin{equation}\label{eqn.erasure_law}
\begin{tikzcd}[background color=definitioncolor, row sep=large]
	\yon\tri \car{c}&\car{c}\ar[d, "\delta" description]\ar[r, equal]\ar[l, equal]&\car{c}\tri\yon\\&
	\car{c}\tri\car{c},\ar[ul, "\epsilon\:\tri\:\car{c}"]\ar[ur, "\car{c}\:\tri\:\epsilon"']
\end{tikzcd}
\end{equation}
where the left triangle is known as the \emph{left erasure} (or \emph{counit}) \emph{law} and the right triangle is known as the \emph{right erasure} (or \emph{counit}) \emph{law}; and
\begin{equation}\label{eqn.coassoc_law}
\begin{tikzcd}[row sep=large]
	\car{c}\ar[r, "\delta"]\ar[d, "\delta"']&
	\car{c}\tri\car{c}\ar[d, "\car{c}\:\tri\:\delta"]\\
	\car{c}\tri \car{c}\ar[r, "\delta\:\tri\:\car{c}"']&
	\car{c}\tri\car{c}\tri\car{c},
\end{tikzcd}
\end{equation}
known as the \emph{coassociative law}.

We may also say that the eraser and duplicator morphisms comprise a \emph{comonoid structure} on the carrier, or we may identify a comonoid with its carrier if the eraser and duplicator can be inferred from context.

We refer to a comonoid $\com{C}$ in $(\poly,\yon,\tri)$ as a \emph{polynomial comonoid}.
\end{definition}

\begin{remark}
The concept of a \emph{comonoid} in a monoidal category is dual to that of a \emph{monoid}, which may be more familiar.
Monoids come with \emph{unit} and \emph{multiplication} morphisms that point the other way, so named because they generalize the unit and multiplication operations of a monoid in $\smset$.
(We'll talk more about monoids in $\smset$ in \cref{ex.monoids}.)
Prepending `co-' to each term yields the corresponding terms for comonoids.

The alternative names \emph{eraser} for the \emph{counit} and \emph{duplicator} for the \emph{comultiplication} are less standard, but we will favor them to avoid confusion between the counit of a \emph{comonoid} and the counit of an \emph{adjunction}---and so that their names match up with the Greek letters $\epsilon$ and $\delta$ that we will so often use to label them.
The word ``duplicator'' comes from the fact that $\delta\colon\car{c}\to\car{c}\tri\car{c}$ effectively turns one $\car{c}$ into two, while the ``eraser'' $\epsilon\colon\car{c}\to\yon$ erases the $\car{c}$ altogether, leaving only the monoidal unit $\yon$.
Still, it can be helpful to think of comonoids as having a \emph{coassociative} comultiplication along with a counit satisfying \emph{left and right counit laws}.
\end{remark}

\begin{remark}
Comonoids in a functor category with respect to the composition product are generally known as \emph{comonads}.
So it would be a little more precise and familiar to refer to our polynomial comonoids as \emph{polynomial comonads}.
But since we think of our polynomials more often as arenas than as functors, well favor the term comonoid over comonad.
\end{remark}

\begin{example}[State systems are polynomial comonoids]
Nearly all our work on state systems up until now can be summarized thusly:
\slogan{
    every state system is a polynomial comonoid,\\
    whose eraser is the do-nothing enclosure\\
    and whose duplicator is the transition lens.
}
The comonoid structure on a state system $\car{s}$ is what allows us to write canonical lenses $\car{s}\to\car{s}\tripow{n}$ for any $n\in\nn$.
We can then model $n$ steps through a dynamical system $\varphi\colon\car{s}\to p$ with interface $p\in\poly$ by composing this canonical lens with $\varphi\tripow{n}$ to obtain a ``sped-up'' dynamical system $\text{Run}_n(\varphi)$.
This new system has the same state system $\car{s}$, but its interface is now $p\tripow{n}$.

The canonicity of $\car{s}\to\car{s}\tripow{n}$ is due to the following standard result about comonoids, which can be proved inductively. 
\end{example}

\begin{proposition}[Defining $\delta^{(n)}$] \label{prop.n_duplication}
Given a comonoid $(\car{c},\epsilon,\delta)$, let $\delta^{(n)}\colon\car{c}\to\car{c}\tripow{n}$ be given as follows. Let $\delta^{(0)}\coloneqq\epsilon$ and inductively define $\delta^{(n+1)}\coloneqq\delta\then\left(\delta^{(n)}\tri\car{c}\right)$ for all $n\in\nn$.
Then we have the following:
\begin{enumerate}[label=(\alph*)]
    \item $\delta^{(n)}$ is a morphism $\car{c}\to\car{c}\tripow{n}$ for all $n\in\nn$;
    \item $\delta^{(1)}=\car{c}=\id_\car{c}$;
    \item $\delta^{(2)}=\delta$; and
    \item $\delta^{(n)}=\delta\then\left(\delta^{(k)}\tri\delta^{(n-k)}\right)$ for all $k,n\in\nn$ with $k\leq n$, so our choice of morphism $\car{c}\to\car{c}\tripow{(n+1)}$ is canonical. % More generally: $\delta^{(n)}=\delta^{(m)}\then\left(\delta^{(k_1)}\tri\cdots\tri\delta^{(k_m)}\right)$ for $m,n\in\nn$ and each $k_i\in\nn$ such that $k_1+\cdots+k_m=n$.
\end{enumerate}
\end{proposition}
 \begin{proof}
 We leave parts (a), (b), and (c) for \cref{exc.n_duplication}. Part (d) amounts to coassociativity.
\end{proof}

We'll continue to use the notation introduced here throughout for general comonoids.

\begin{exercise} \label{exc.n_duplication}
Prove the first three parts of \cref{prop.n_duplication}. %Finish the proof of \cref{prop.n_duplication} as follows.
\begin{enumerate}
    \item Prove part (a).
    \item Prove part (b).
    \item Prove part (c).\qedhere
\end{enumerate}
\begin{solution}
We complete the proof of \cref{prop.n_duplication}, where we are given a comonoid $(\car{c},\epsilon,\delta)$ along with $\delta^{(0)}\coloneqq\epsilon$ and $\delta^{(n+1)}\coloneqq\delta\then\left(\delta^{(n)}\tri\car{c}\right)$ for all $n\in\nn$.
\begin{enumerate}
    \item We will show that $\delta^{(n)}$ is a map $\car{c}\to\car{c}\tripow{n}$ for every $n\in\nn$ by induction on $n$.
    We know $\delta^{(0)}=\epsilon$ is a map $\car{c}\to\yon=\car{c}\tripow0$, and for each $n\in\nn$, if $\delta^{(n)}$ is a map $\car{c}\to\car{c}\tripow{n}$, then the composite $\delta^{(n+1)}=\delta\then\left(\delta^{(n)}\tri\car{c}\right)$ is a map
    \[
        \car{c}\To\delta\car{c}\tri\car{c}\To{\delta^{(n)}\:\tri\:\car{c}}\car{c}\tripow{n}\tri\car{c}\iso\car{c}\tripow{(n+1)}
    \]
    Hence the result follows by induction.
    
    \item We have $\delta^{(1)}=\delta\then(\delta^{(0)}\tri\car{c})=\delta\then(\epsilon\tri\car{c})=\id_\car{c}$ by the left erasure law from \eqref{eqn.erasure_law}.
    
    \item By the previous part, we have $\delta^{(2)}=\delta\then(\delta^{(1)}\tri\car{c})=\delta\then(\car{c}\tri\car{c})=\delta$.
\end{enumerate}
\end{solution}
\end{exercise}

\begin{example}[Not all polynomial comonoids are state systems] \label{ex.not_all_com_state}
At this point, a natural question to ask is whether everything we know about a state system $\car{s}$ is captured by the fact that state systems are polynomial comonoids.
In other words, are state systems the only polynomial comonoids there are?

The answer turns out to be no.
After all, there is one fact about state systems from \cref{subsec.comon.sharp.state.trans} that we did not encode in $\poly$: for a fixed state $s\in\car{s}(\1)$, the target function $\car{s}[s]\to\car{s}(\1)$ assigning directions at $s$ to their target states is a bijection.

Nothing in our comonoid laws guarantees this bijectivity.
An arbitrary polynomial comonoid might assign different directions at $s$ to the same target---given a second state $t$, there may be multiple ways to get from $s$ to $t$.
It might even assign \emph{no} directions at $s$ to a target $t$, making it impossible to get from $s$ to $t$.
(We'll give an explicit example of a comonoid that is not a state system in \cref{ex.walking_arrow_com}.)
State systems as we have defined them are just the polynomial comonoids that do not allow either of these variations, for which the bijective property holds.

We consider this a feature, not a bug.
After all, it is an abstraction to say that there is exactly one way to get from any one state in a system to another.
It is perfectly plausible that the inner workings of a state system do not permit traveling between some states and differentiate ways of traveling between others.
We won't formally introduce this idea into our theory of dependent dynamical systems,
but we will often think of polynomial comonoids as a sort of generalized state system throughout the rest of the book.
\end{example}

\begin{example}[A comonoid that is not a state system]\label{ex.walking_arrow_com}
The polynomial $\yon^\2+\yon$ is not a state system: one of its direction-sets has one fewer element than its position-set.
But it can still be given a comonoid structure.
We describe that structure here, but we will go a little quickly, because we'll soon discover a much more familiar way to think about comonoids.

Define $\car{a}\coloneqq\{s\}\yon^{\{\id_s,a\}}+\{t\}\yon^{\{\id_t\}}\iso\yon^\2+\yon$.
Here is its tree picture:
\[
\begin{tikzpicture}[rounded corners]
	\node (p1) [draw, "$\car{a}\coloneqq$" left] {
	\begin{tikzpicture}[trees, sibling distance=5mm]
    \node["\tiny $s$" below, red] (1) {$\bullet$} 
      child  {coordinate (is) \idchild}
      child {coordinate (a)};
    \node[right=.8 of 1,"\tiny $t$" below, blue] (2) {$\bullet$} 
      child  {coordinate (it) \idchild};
    \node[below left=0 of is, font=\tiny] {$\id_s$};
    \node[below left=.1 of it, font=\tiny] {$\id_t$};
    \node[below right=.1 of a, font=\tiny] {$a$};
  \end{tikzpicture}
  };
\end{tikzpicture}
\]
Notice that we have drawn one direction out of each position---$\id_s$ and $\id_t$---with a double bar.
We let these be the directions that the eraser $\epsilon\colon\car{a}\to\yon$ picks out.
The double bar is meant to evoke an equals sign from the root position to the eventual target position, which is appropriate, as these two positions should be equal for every direction that the eraser selects.
We can draw the selections that $\epsilon$ makes like so:
\[
\begin{tikzpicture}[trees, bend right=60]
  \node[red] (1) {$\bullet$} 
  	child  {coordinate (11) \idchild}
    child {coordinate (12)};
  \node[right=1.5 of 1] (1y) {$\bullet$}
  	child {coordinate (1y1)};
%
  \node[right=2 of 1y, blue] (2) {$\bullet$} 
  	child  {coordinate (21) \idchild};
  \node[right=1.5 of 2] (2y) {$\bullet$}
  	child {coordinate (2y1)};
	\draw[|->, shorten <= 3pt, shorten >= 3pt] (1) -- (1y);
	\draw[|->, shorten <= 3pt, shorten >= 3pt] (2) -- (2y);
	\draw[densely dotted, postaction={decorate}] (1y1) to (11);
	\draw[densely dotted, postaction={decorate}] (2y1) to (21);
\end{tikzpicture}
\]

Now we need a duplicator $\delta\colon\car{a}\to\car{a}\tri\car{a}$.
Before we define it, let's draw out $\car{a}\tri\car{a}$ to see what it looks like.
Remember that we need to glue corollas of $\car{a}$ to leaves of $\car{a}$ in every possible way:
\[
\begin{tikzpicture}[rounded corners]
	\node (p1) [draw, "$\car{a}\tri\car{a}=$" left] {
	\begin{tikzpicture}[trees,
	  level 1/.style={sibling distance=5mm},
  	level 2/.style={sibling distance=2.5mm}]
    \node[red] (1) {$\bullet$} 
      child  {
        node [red] {$\bullet$} 
 		    child  {\idchild}
      	child {}
			\idchild
			}
      child  {
        node [red] {$\bullet$} 
 		    child  {\idchild}
      	child {}
			};
    \node[right=1 of 1, red] (2) {$\bullet$} 
      child  {
        node [red]{$\bullet$} 
 		    child  {\idchild}
      	child {}
			\idchild
			}
      child {node [blue] {$\bullet$} 
      	child  {\idchild}
			};
    \node[right=1 of 2, red] (3) {$\bullet$} 
      child {node [blue] {$\bullet$} 
      	child  {\idchild}
				\idchild
			}
      child  {
        node [red] {$\bullet$} 
 		    child {\idchild}
      	child {}
			};
    \node[right=1 of 3, red] (4) {$\bullet$} 
      child {node [blue] {$\bullet$} 
      	child  {\idchild}
			\idchild
			}
      child {node [blue] {$\bullet$} 
      	child  {\idchild}
			};
    \node[right=.8 of 4, blue] (5) {$\bullet$} 
      child  {
        node [red] {$\bullet$} 
 		    child  {\idchild}
      	child {}
			\idchild
			};
    \node[right=.6 of 5, blue] (6) {$\bullet$} 
      child {node [blue] {$\bullet$} 
      	child  {\idchild}
			\idchild
			};
  \end{tikzpicture}
  };
\end{tikzpicture}
\]
Each of these trees gives a way to match directions out of one position to positions they could lead to.
On positions, $\delta$ will decide which matchings to pick by sending the red $s$ to one of the four positions on the left and the blue $t$ to one of the two positions on the right.
We want the double-barred directions that the eraser picked out to have the same position on either end (in fact, the erasure laws guarantee this).
So the only choice to be made is whether we want the other direction $a$ at $s$ to point to $s$ or to $t$.
Let's pick $t$ for the time being, so that on positions, $\delta$ looks like this:
\[
\begin{tikzpicture}[trees, sibling distance=5mm,	bend right=60]
	\node (1A) [red] {$\bullet$} 
  	child  {coordinate (1A1) \idchild}
    child {coordinate (1A2)};
  \node (2A) [right=1.5 of 1A, red] {$\bullet$} 
      child  {
        node [red] {$\bullet$} 
 		    child  {coordinate (2A1) \idchild}
      	child {coordinate (2A2)}
			\idchild
			}
      child {node [blue] {$\bullet$} 
      	child  {coordinate (2A3) \idchild}
			};
	\draw[|->, shorten <= 3pt, shorten >= 3pt] (1A) -- (2A);
% 	\draw[densely dotted, postaction={decorate}] (2A1) to (1A1);
% 	\draw[densely dotted, postaction={decorate}] (2A2) to (1A2);
% 	\draw[densely dotted, postaction={decorate}] (2A3) to (1A2);
%
  \node[right=2 of 2A, blue] (1B) {$\bullet$} 
  	child  {coordinate (1B1) \idchild};
  \node[right=1.5 of 1B, blue] (2B) {$\bullet$} 
  	child {node [blue] {$\bullet$} 
    child  {coordinate (2B1) \idchild}
		\idchild
	};
	\draw[|->, shorten <= 3pt, shorten >= 3pt] (1B) -- (2B);
% 	\draw[densely dotted, postaction={decorate}] (2B1) to (1B1);
\end{tikzpicture}
\]
As in \cref{ex.trans_trees}, we can interpret this as telling us how to ``bend'' the arrows of $\car{a}$ so that they point to other positions:
\begin{equation} \label{eqn.walking_arrow_bent_cor}
\begin{tikzpicture}[baseline=(b)]
    \node[circle,minimum size=2cm] (b) {};
    \foreach\x/\c in {1/red, 2/blue} {
        \node[minimum size=0.1cm,draw,circle,\c,fill=\c] (2-\x) at (b.{360/2*\x}){};
        \draw[double, -] (2-\x) to [in=360/2*\x-30,out=360/2*\x+30,loop] ();
        \relax
    }
    \draw (2-1) edge[->] (2-2);
\end{tikzpicture}
\end{equation}

Meanwhile, on directions, $\delta$ should tell us how to run two directions together into one.
Fortunately, there's not much for us to do here---we know that if one of the two directions $\delta$ runs together is one of the double-barred directions that the eraser picked out, then $\delta$ should ignore that ``do-nothing'' direction and yield the other direction (again, the erasure laws ensure this).
Here's what that looks like:
\begin{equation}\label{eqn.my_comonoid_delta}
\begin{tikzpicture}[trees, sibling distance=5mm,	bend right=60]
	\node (1A) [red] {$\bullet$} 
  	child  {coordinate (1A1) \idchild}
    child {coordinate (1A2)};
  \node (2A) [right=1.5 of 1A, red] {$\bullet$} 
      child  {
        node [red] {$\bullet$} 
 		    child  {coordinate (2A1) \idchild}
      	child {coordinate (2A2)}
			\idchild
			}
      child {node [blue] {$\bullet$} 
      	child  {coordinate (2A3) \idchild}
			};
	\draw[|->, shorten <= 3pt, shorten >= 3pt] (1A) -- (2A);
	\draw[densely dotted, postaction={decorate}] (2A1) to (1A1);
	\draw[densely dotted, postaction={decorate}] (2A2) to (1A2);
	\draw[densely dotted, postaction={decorate}] (2A3) to (1A2);
%
  \node[right=2 of 2A, blue] (1B) {$\bullet$} 
  	child  {coordinate (1B1) \idchild};
  \node[right=1.5 of 1B, blue] (2B) {$\bullet$} 
  	child {node [blue] {$\bullet$} 
    child  {coordinate (2B1) \idchild}
		\idchild
	};
	\draw[|->, shorten <= 3pt, shorten >= 3pt] (1B) -- (2B);
	\draw[densely dotted, postaction={decorate}] (2B1) to (1B1);
\end{tikzpicture}
\end{equation}
And that's all we need to specify the triple $(\car{a},\epsilon,\delta)$.

Here are $\epsilon\colon\car{a}\to\yon$ and $\delta\colon\car{a}\to\car{a}\tri\car{a}$ again, in terms of polyboxes.
\[
\begin{tikzpicture}
	\node (p1) {
	    \begin{tikzpicture}[polybox, mapstos]
            \node[poly, dom, "$\car{a}$" left] (S) {$\id_s$\at$s$};

            \draw (S_pos) to[climb'] node[right] {$\epsilon$} (S_dir);
        \end{tikzpicture}  
	};
    \node[right=1 of p1] (p2) {
        \begin{tikzpicture}[polybox, mapstos]
            \node[poly, dom, "$\car{a}$" left] (S) {$\id_t$\at$t$};

            \draw (S_pos) to[climb'] node[right] {$\epsilon$} (S_dir);
        \end{tikzpicture}  
	};
\end{tikzpicture}
\]
\[
\begin{tikzpicture}
	\node (p1) {
	  \begin{tikzpicture}[polybox, mapstos]
  	\node[poly, dom, "$\car{a}$" left] (p) {$\id_s$\at$s$};
  	\node[poly, cod, right=of p.south, yshift=-1ex, "$\car{a}$" below] (q) {$\id_s$\at$s$};
  	\node[poly, cod, above=of q, "$\car{a}$" above] (r) {$\id_s$\at$s$};
  	\draw (p_pos) to[first] (q_pos);
  	\draw (q_dir) to[climb, "$\delta$" left] (r_pos);
  	\draw (r_dir) to[last] (p_dir);
  \end{tikzpicture}  
	};
	\node[right=.3 of p1] (p2) {
	  \begin{tikzpicture}[polybox, mapstos]
  	\node[poly, dom, "$\car{a}$" left] (p) {$a$\at$s$};
  	\node[poly, cod, right= of p.south, yshift=-1ex, "$\car{a}$" below] (q) {$\id_s$\at$s$};
  	\node[poly, cod, above=of q, "$\car{a}$" above] (r) {$a$\at$s$};
  	\draw (p_pos) to[first] (q_pos);
  	\draw (q_dir) to[climb, "$\delta$" left] (r_pos);
  	\draw (r_dir) to[last] (p_dir);
  \end{tikzpicture}  
	};
	\node[right=.3 of p2] (p3) {
	  \begin{tikzpicture}[polybox, mapstos]
  	\node[poly, dom, "$\car{a}$" left] (p) {$a$\at$s$};
  	\node[poly, cod, right= of p.south, yshift=-1ex, "$\car{a}$" below] (q) {$a$\at$s$};
  	\node[poly, cod, above=of q, "$\car{a}$" above] (r) {$\id_t$\at$t$};
  	\draw (p_pos) to[first] (q_pos);
  	\draw (q_dir) to[climb, "$\delta$" left] (r_pos);
  	\draw (r_dir) to[last] (p_dir);
  \end{tikzpicture}  
	};
	\node[right=.3 of p3] (p4) {
	  \begin{tikzpicture}[polybox, mapstos]
  	\node[poly, dom, "$\car{a}$" left] (p) {$\id_t$\at$t$};
  	\node[poly, cod, right= of p.south, yshift=-1ex, "$\car{a}$" below] (q) {$\id_t$\at$t$};
  	\node[poly, cod, above=of q, "$\car{a}$" above] (r) {$\id_t$\at$t$};
  	\draw (p_pos) to[first] (q_pos);
  	\draw (q_dir) to[climb, "$\delta$" left] (r_pos);
  	\draw (r_dir) to[last] (p_dir);
  \end{tikzpicture}  
	};
\end{tikzpicture}
\]

Of course, we have yet to check that $(\car{a},\epsilon,\delta)$ really is a comonoid, i.e.\ that the diagrams in \eqref{eqn.erasure_law} and \eqref{eqn.coassoc_law} commute.
We leave that for \cref{exc.walking_arrow_com}.
\end{example}

\begin{exercise} \label{exc.walking_arrow_com}
Verify that $(\car{a},\epsilon,\delta)$ as defined in \cref{ex.walking_arrow_com} obeys the erasure laws in \eqref{eqn.erasure_law} and the coassociative law in \eqref{eqn.coassoc_law}.
\begin{solution}
We will eventually see that comonoids in $\poly$ are categories; this gives us intuition for what is going on here. In fact the category corresponding to the comonoid in this exercise is the walking arrow, depicted in \eqref{eqn.walking_arrow_bent_cor}. The erasure (counit) laws are verified by looking at the picture of $\delta$ in \eqref{eqn.my_comonoid_delta} and noting that it sends the double (do-nothing) lines (the identities) back to the double lines.
\end{solution}
\end{exercise}

\begin{exercise}\label{exc.linear_poly_comon}
Show that if $B$ is a set, then there exists a unique comonoid structure on the linear polynomial $B\yon$.
\begin{solution}
Given a set $B$, we wish to give a comonoid structure on $B\yon$ and show that it is unique.
There is only one way to define an eraser lens $\epsilon\colon B\yon\to\yon$: the on-position function is the unique map $!\colon B\to\1$, while every on-directions function $\1\to\1$ must be the identity.
Meanwhile $B\yon\tri B\yon\iso B^\2\yon$, so to specify a duplicator lens $\delta\colon B\yon\to B^\2\yon$, it suffices to specify an on-positions function $\delta_\1\colon B\to B^\2$, and every on-directions function will again be the identity.

All the comonoid laws should then hold trivially on directions, so it suffices to consider each law on positions.
The erasure laws imply that the composite functions
\[
    B\To{\delta_\1}B\times B\To{B\:\times\:!}B\times\1\iso B,
\]
where the second map is just the canonical left projection, and
\[
    B\To{\delta_\1}B\times B\To{!\:\times\:B}\1\times B\iso B,
\]
where the second nap is just the canonical right projection, are both the identity on $B$.
The only function $\delta_\1\colon B\to B\times B$ that satisfies this condition is the diagonal $a\mapsto(a,a)$.
It is easy to verify that the diagonal is coassociative, so this does define a unique comonoid structure on $B\yon$.
(It turns out that this is equivalent to the well-known result that there is a unique comonoid structure on every set in $(\smset,\1,\times)$.)
\end{solution}
\end{exercise}

Once you know that state systems are comonoids in $\poly$, but not the only ones, the natural question to ask is ``what are all the other comonoids in $\poly$?''
Or perhaps, as we led you through this case study of $\car{s}$, you have already suspected the truth (or simply remembered what we told you back in \cref{prop.ahman_uustalu1}): a polynomial comonoid---what with its directions leading from one position to another, directions that can be run together associatively among which there are directions at every position that do nothing---is just another name for a category.

%-------- Section --------%
\section{Polynomial comonoids are categories}

What Ahman and Uustalu showed was that polynomial comonoids can be identified with categories.
Every category in the usual sense is a comonoid in $\poly$, and every comonoid in $\poly$ is a category. 
We find their revelation to be truly shocking, and it suggests some very different ways to think about categories.
But let's go over their result first.

\begin{theorem}[Ahman-Uustalu]\label{thm.ahman_uustalu}
There is a one-to-one isomorphism-preserving correspondence between polynomial comonoids and (small) categories.
\end{theorem}

Our goal is to spell out this correspondence so that we can justly proclaim:

\slogan{Comonoids in $\poly$ are precisely categories!}

\subsection{Translating between polynomial comonoids and categories}

First, we describe how to translate between the carrier $\car{c}$ of a comonoid $\com{C}\coloneqq(\car{c},\delta,\epsilon)$ and the objects and morphisms of the corresponding category $\cat{C}$.
The idea is pretty simple, and you may have already guessed it: positions are objects and directions are morphisms.

\subsubsection{Positions as objects, directions as morphisms}

More precisely, the positions of $\car{c}$ are the objects of $\cat{C}$:
\begin{equation} \label{eqn.pos_obj}
    \car{c}(\1)=\Ob\cat{C}.
\end{equation}
Then for each such position or object $i$, the $\car{c}[i]$-directions are the morphisms of $\cat{C}$ with domain $i$:
\begin{equation} \label{eqn.dir_mor}
    \car{c}[i]=\sum_{j\in\Ob\cat{C}}\cat{C}(i,j).
\end{equation}
The right hand side above is a little clumsier than the left; this is because while we are used to thinking of hom-sets of categories such as $\cat{C}(i,j)$, consisting of all morphisms in $\cat{C}$ with a fixed domain and codomain, we aren't used to thinking about the collection of all morphisms in $\cat{C}$ with a fixed domain and an arbitrary codomain quite as often.%
\footnote{Except, perhaps, in the context of coslice categories.}
On the other hand, the carrier \emph{only} encodes which morphisms have each object as its domain, i.e.\ which directions are at each position.
Codomains will be encoded in the data of the comonoid elsewhere.

This is the key difference in perspective between the polynomial comonoid perspective of categories, in contrast to our usual hom-set perspective: the polynomial perspective is in a sense domain-centric, as highlighted by the following definition.

\begin{definition}[Polynomial carrier]
Let $\cat{C}$ be a category.
For every object $i$ in $\cat{C}$, denote the morphisms in $\cat{C}$ with domain $i$ by $\cat{C}[i]$, so that\tablefootnote{We may also write $f\colon i\to\_$ to denote an arbitrary morphism $f\in\cat{C}[i]$, i.e.\ a morphism $f$ in $\cat{C}$ with domain $i$ and an unspecified codomain.}
\[
    \cat{C}[i]\coloneqq\sum_{j\in\Ob\cat{C}}\cat{C}(i,j).
\]
Then the \emph{polynomial carrier}, or simply \emph{carrier}, of $\cat{C}$ is the polynomial
\[
    \sum_{i\in\Ob\cat{C}}\yon^{\cat{C}[i]}.
\]
\end{definition}

So everything we have said so far about the correspondence from \cref{thm.ahman_uustalu} can be summarized by saying that it preserves carriers: the carrier of the category $\cat{C}$ is the carrier $\car{c}$ of the comonoid $\com{C}$, so that $\Ob\cat{C}=\car{c}(\1)$ and $\cat{C}[i]=\car{c}[i]$.

\begin{remark}
If we take the perspective that categories are equal if and only if their objects and morphisms are equal and obey the same laws, and similarly that polynomials are equal if and only if their position-sets and direction-sets are equal sets, then \eqref{eqn.pos_obj} and \eqref{eqn.dir_mor} really can be just strict equalities.
This is why we are comfortable naming a ``one-to-one correspondence'' in \cref{thm.ahman_uustalu} rather than just, say, some form of equivalence.
Since the positions and directions of our polynomials always form \emph{sets}, however, the categories we obtain under this correspondence are also necessarily \emph{small}: their objects form a set, as do all of their morphisms.
But we won't worry too much about size issues beyond this.
\end{remark}

\begin{exercise} \label{exc.ema_polys}
What is the carrier of each of the following categories (up to isomorphism)?
\begin{enumerate}
	\item The category
	\begin{center}
	    \boxCD{exercisecolor}{$A\Too{f}B$}
	\end{center}
	where we have drawn every morphism except for the identity morphisms.
	\item The category
	\begin{center}
	    \boxCD{exercisecolor}{$B\To{g}A\From{h}C$}
	\end{center}
	where we have drawn every morphism except for the identity morphisms.
	\item The empty category.
	\item \label{exc.ema_polys.nat_monoid} A category with exactly $1$ object and a morphism $i$, for which every morphism can be written uniquely as the $n$-fold composite of $i$ for some $n\in\nn$.
	\item \label{exc.ema_polys.nat_poset} The category
	\begin{center}
	    \boxCD{exercisecolor}{$0\to1\to2\to3\to\cdots$}
	\end{center}
	where there is a unique morphism $m\to n$ if $m\leq n$ (and no other morphisms).
	\item The category
	\begin{center}
	    \boxCD{exercisecolor}{$0\from1\from2\from3\from\cdots$}
	\end{center}
	where there is a unique morphism $m\from n$ if $m\leq n$ (and no other morphisms).\qedhere
\end{enumerate}
\begin{solution}
\begin{enumerate}
	\item The category \boxCD{white}{$A\Too{f}B$} has $2$ morphisms out of $A$, namely $\id_A$ and $f$; and $1$ morphism out of $B$, namely $\id_B$.
	So its carrier is $\{A\}\yon^{\{\id_A,f\}}+\{B\}\yon^{\{\id_B\}}\iso\yon^\2+\yon$.
	\item The category \boxCD{white}{$B\To{g}A\From{h}C$} has $1$ morphism out of $A$, namely $\id_A$; $2$ morphisms out of $B$, namely $\id_B$ and $g$; and $2$ morphisms out of $C$, namely $\id_C$ and $h$.
	So its carrier is $\{A\}\yon^{\{\id_A\}}+\{B\}\yon^{\{\id_B,g\}}+\{C\}\yon^{\{\id_C,h\}}\iso\2\yon^\2+\yon$.
	\item The empty category has no objects or morphisms, so its carrier is just $\0$.
	\item The category in question has $1$ object, and its set of morphisms is in bijection with $\nn$, so its carrier is isomorphic to $\yon^\nn$.
	(This category is the monoid $(\nn,0,+)$ viewed as a $1$-object category; see \cref{ex.monoids} for the general case.)
	\item The category in question has $\nn$ as its set of objects, and for each $m\in\nn$, the morphisms out of $m$ are determined by their codomains: there is exactly $1$ morphism $m\to n$ for every $n\in\nn$ satisfying $m\leq n$, and no other morphisms out of $m$.
	So the carrier of the category is isomorphic to
	\[
	    \sum_{m\in\nn}\yon^{\{n\in\nn\mid m\leq n\}}\iso\nn\yon^\nn,
	\]
	as $\{n\in\nn\mid m\leq n\}\iso\nn$ under the bijection $n\mapsto n-m$.
	(This category is the poset $(\nn,\leq)$.)
	\item The category in question has $\nn$ as its set of objects, and for each $n\in\nn$, the morphisms out of $n$ are again determined by their codomains: there is exactly $1$ morphism $n\to m$ for every $m\in\nn$ satisfying $m\leq n$, and no other morphisms out of $n$.
	So the carrier of the category is isomorphic to
	\[
	    \sum_{n\in\nn}\yon^{\{m\in\nn\mid m\leq n\}}\iso\sum_{n\in\nn}\yon^{\ord{n+1}}\iso\yon^\1+\yon^\2+\yon^\3+\cdots.
	\]
    (This category is the poset $(\nn,\geq)$.)
\end{enumerate}
\end{solution}
\end{exercise}

But a category $\cat{C}$ is more than its carrier polynomial, just as a comonoid $\com{C}$ is more than its carrier $\car{c}$.
In particular, we have said nothing about the codomains of morphisms in $\cat{C}$, nor anything about identity morphisms, composition, or how the laws of a category are satisfied.
Similarly, we have said nothing about the eraser $\epsilon$ or the duplicator $\delta$ of $\com{C}$, nor anything about how the comonoid laws are satisfied.
It turns out that all of these constituents and laws correspond to one another, as summarized by the following table.
Here each item in the comonoid column---either a polynomial, a lens, or a lens equation---spans two rows, with the top row corresponding to positions and the bottom row corresponding to directions.
\begin{center}
\begin{tabular}{cc|cc}
  \textbf{Comonoid} & $\com{C}=(\car{c},\epsilon,\delta)$ & \textbf{Category} & $\cat{C}$ \\ 
  \hline
  \multirow{2}{*}{carrier} & $i\in\car{c}(\1)$ & objects & $i\in\Ob\cat{C}$ \\
  & $f\in\cat{c}[i]$ & morphisms & $f\colon i\to\_$ \\
  \hline
  \multirow{2}{*}{eraser} & $\epsilon_\1\colon\car{c}(\1)\to\1$ & --- & --- \\
  & $\epsilon_i^\sharp\colon\1\to\car{c}[i]$ & identities & $\id_i\colon i\to\_$ \\
  \hline
  \multirow{2}{*}{duplicator} & $\delta_\1\colon\car{c}(\1)\to(\car{c}\tri\car{c})(\1)$ & codomains* & $\cod\colon\cat{C}[i]\to\Ob\cat{C}$ \\
  & 
  $\delta_i^\sharp\colon(\car{c}\tri\car{c})[\delta_\1(i)]\to\car{c}[i]$ & composition* & $\then$ \\ %$\displaystyle\comp\colon\sum_{f\in\cat{C}[i]}\cat{C}[\cod(f)]\to\cat{C}[i]$
  \hline
  \multicolumn2{c|}{\multirow{2}{*}{right erasure law}} & \multicolumn2{c}{$\ast$} \\
  \multicolumn2{c|}{} & \multicolumn2{c}{right identity law} \\
  \hline
  \multicolumn2{c|}{\multirow{2}{*}{left erasure law}} & codomains of identities & $\cod\id_i=i$ \\
  \multicolumn2{c|}{} & \multicolumn2{c}{left identity law} \\
  \hline
  \multicolumn2{c|}{\multirow{2}{*}{coassociative law}} & codomains of composites & $\cod(f\then g)=\cod g$ \\
  \multicolumn2{c|}{} & \multicolumn2{c}{associative law of composition}
\end{tabular}
\end{center}
Note that the on-positions function of $\epsilon$, being a function into the terminal set, encodes no actual data.
The asterisk $\ast$ indicates that the right erasure law on positions works together with the duplicator to ensure that codomains and composites are properly specified.

We have already covered the correspondence between the first two rows, so let us consider each of the following rows in turn.
In some sense, we have already seen each piece of this correspondence in action for state systems in \cref{sec.comon.sharp.state}, so we'll go through it a little faster this time for the general case.

\subsubsection{The eraser assigns identities}

We know that the eraser $\epsilon\colon\car{c}\to\yon$ can be identified with a dependent function $(i\in\car{c}(\1))\to\com{c}[i]$, sending each position $i\in\com{c}(\1)$ to a $\com{c}[i]$-direction.
In terms of our category $\cat{C}$, the eraser sends each object $i\in\Ob\cat{C}$ to a morphism $i\to\_$.
But this is exactly what we need to specify identity morphisms---a morphism out of each object.
So the eraser of $\car{c}$ specifies the identity morphisms of the corresponding category $\cat{C}$.
We can interpret the polybox picture for $\epsilon$ like so:
\[
 \begin{tikzpicture}[polybox, mapstos]
  	\node[poly, dom, "$\car{c}$" left] (c) {$\id_i$\at$i$};
  	\draw (c_pos) to[climb'] node[right] {$\idy$} (c_dir);
	\end{tikzpicture}
\]
Here we have given the label $\idy$ to the arrow sending objects to their identity morphisms.

Keep in mind that from the domain-centric polynomial perspective, we have not yet specified that the codomain of an identity morphism is equal to its domain; that comes later.

\subsubsection{The right erasure law on positions: a bit of bookkeeping}

Keeping our label $\idy$ for the arrow in $\epsilon$, the right erasure law $\delta\then(\car{c}\tri\epsilon)=\id_\car{c}$ from \eqref{eqn.erasure_law} can be drawn in polyboxes like so:
\[
\begin{tikzpicture}
	\node (1) {
        \begin{tikzpicture}[polybox, mapstos]
        	\node[poly, dom, "$\car{c}$" left] (r) {\at$i$};
        	\node[poly, cod, right=2 of r.south, yshift=-2.5ex, "$\car{c}$" below] (p) {\at$i$};
        	\node[poly, above=.8 of p, "$\car{c}$" above] (p') {};
        	
        	\draw (r_pos) to[first] node[below] {} (p_pos);
        	\draw (p_dir) to[climb] node[left=.1] {$\delta$} (p'_pos);
        	\draw (p'_pos) to[climb'] node[right] {$\idy$} (p'_dir);
        	\draw (p'_dir) to[last] node[above=.4] {} (r_dir);
        \end{tikzpicture}
	};
	\node[right=1.8 of 1] (2) {
        \begin{tikzpicture}[polybox, mapstos]
          	\node[poly, dom, "$\car{c}$" left] (c) {\at$i$};
          	\node[poly, cod, right=of c, "$\car{c}$" right] (c') {\at$i$};
          	\draw[double] (c_pos) -- (c'_pos);
          	\draw[double] (c'_dir) -- (c_dir);
	    \end{tikzpicture}
	};
	\node at ($(1.east)!.5!(2.west)$) (3) {=};
\end{tikzpicture}
\]
We have only filled in a few of the boxes, but that is enough to interpret what the right erasure law tells us on positions: that the bottom arrow of the duplicator must be the identity function on $\car{c}(\1)$.
Equipped with this knowledge, we can focus our attention on the other two arrows of $\delta$.

\subsubsection{The duplicator assigns codomains and composites}

In fact, in the polybox picture for $\delta\colon\car{c}\to\car{c}\tri\car{c}$, the middle arrow specifies codomains, and the top arrow specifies composition.
We therefore label these arrows as follows:\footnote{Compare these labels to the names ``target'' and ``run'' that we gave to the arrows of a state system's transition lens.}
\[
\begin{tikzpicture}[polybox, tos]
    \node[poly, dom, "$\car{c}$" left] (yX) {};
    \node[poly, cod, right=1.8 of yX.south, yshift=-2.5ex, "$\car{c}$" right] (p) {};
    \node[poly, cod, above=.8 of p, "$\car{c}$" right] (p') {};
    
    \draw[double, -] (yX_pos) to[first] node[below] {} (p_pos);
    \draw (p_dir) to[climb] node[right] {$\cod$} (p'_pos);
    \draw (p'_dir) to[last] node[above] {$\then$} (yX_dir);
\end{tikzpicture}
\]
To check that this makes sense, we fill in the boxes:
\[
\begin{tikzpicture}[polybox, mapstos]
    \node[poly, dom, "$\car{c}$" left] (yX) {$f\then g$\at$i$};
    \node[poly, cod, right=2 of yX.south, yshift=-2.5ex, "$\car{c}$" right] (p) {$f$\at$i$};
    \node[poly, cod, above=.8 of p, "$\car{c}$" right] (p') {$g$\at$\cod f$};
    
    \draw[double, -] (yX_pos) to[first] node[below] {} (p_pos);
    \draw (p_dir) to[climb] node[right] {$\cod$} (p'_pos);
    \draw (p'_dir) to[last] node[above] {$\then$} (yX_dir);
\end{tikzpicture}
\]
Remember: each position box contains an object of $\cat{C}$, while each direction box contains a morphism of $\cat{C}$ emanating from the object below.
So $\delta$ takes an object $i\in\Ob\cat{C}$ and a morphism $f\colon i\to\_$ in $\cat{C}$ and assigns another object $\cod f\in\Ob\cat{C}$ to be the codomain of $f$.
It then takes another morphism $g\colon\cod f\to\_$ in $\cat{C}$ and assigns a morphism $f\then g\colon i\to\_$ to be the composite of $f$ and $g$.
In this way, every morphism gets a codomain, and every pair of morphisms that can be composed (i.e.\ the codomain of one matches the domain of the other) is assigned a composite.
As with the identity morphism, we don't know what the codomain of this composite morphism is yet; but we do know that the domain of $f\then g$ matches the domain of $f$, as it should.

\subsubsection{The left erasure law on positions: codomains of identities}

As with the right erasure law, we can partially fill in the polyboxes for the left erasure law $\delta\then(\epsilon\tri\car{c})=\id_\car{c}$ from \eqref{eqn.erasure_law} to read what it says on positions:
\[
\begin{tikzpicture}
	\node (1) {
        \begin{tikzpicture}[polybox, mapstos]
        	\node[poly, dom, "$\car{c}$" left] (r) {\at$i$};
        	\node[poly, right=2 of r.south, yshift=-2.5ex, "$\car{c}$" below] (p) {$\id_i$\at$i$};
        	\node[poly, cod, above=.8 of p, "$\car{c}$" above] (p') {\at$\cod\id_i$};
        	
        	\draw[double, -] (r_pos) to[first] node[below] {} (p_pos);
        	\draw (p_pos) to[climb'] node[right] {$\idy$} (p_dir);
        	\draw (p_dir) to[climb] node[right] {$\cod$} (p'_pos);
        	\draw (p'_dir) to[last] node[above] {$\then$} (r_dir);
        \end{tikzpicture}
	};
	\node[right=1.8 of 1] (2) {
        \begin{tikzpicture}[polybox, mapstos]
          	\node[poly, dom, "$\car{c}$" left] (c) {\at$i$};
          	\node[poly, cod, right=of c, "$\car{c}$" right] (c') {\at$i$};
          	\draw[double] (c_pos) -- (c'_pos);
          	\draw[double] (c'_dir) -- (c_dir);
	    \end{tikzpicture}
	};
	\node at ($(1.east)!.5!(2.west)$) (3) {=};
\end{tikzpicture}
\]
So the left erasure law on positions guarantees that $\cod\id_i=i$ for all $i\in\Ob\cat{C}$.
It makes sense that we would find this here: the eraser assigns identities, while the duplicator assigns codomains, so a statement about codomains of identities is a coherence condition between the eraser and the duplicator.

\subsubsection{The erasure laws on directions are the identity laws}

Let us finish filling in the polyboxes for the left and right erasure laws to see what they have to say on directions.
In the picture below, the left equality depicts the left erasure law (to conserve space, we'll substitute $i$ for $\cod\id_i$ on the left, which we now know we can do), while the right equality depicts the right erasure law:
\[
\begin{tikzpicture}
	\node (1) {
        \begin{tikzpicture}[polybox, mapstos]
        	\node[poly, dom, "$\car{c}$" left] (r) {$\id_i\then f$\at$i$};
        	\node[poly, right=2 of r.south, yshift=-2.5ex, "$\car{c}$" below] (p) {$\id_i$\at$i$};
        	\node[poly, cod, above=.8 of p, "$\car{c}$" above] (p') {$f$\at$i$};
        	
        	\draw[double, -] (r_pos) to[first] node[below] {} (p_pos);
        	\draw (p_pos) to[climb'] node[right] {$\idy$} (p_dir);
        	\draw (p_dir) to[climb] node[right] {$\cod$} (p'_pos);
        	\draw (p'_dir) to[last] node[above] {$\then$} (r_dir);
        \end{tikzpicture}
	};
	\node[right=.1 of 1] (2) {
        \begin{tikzpicture}[polybox, mapstos]
          	\node[poly, dom, "$\car{c}$" left] (c) {$f$\at$i$};
          	\node[poly, cod, right=of c, "$\car{c}$" right] (c') {$f$\at$i$};
          	\draw[double] (c_pos) -- (c'_pos);
          	\draw[double] (c'_dir) -- (c_dir);
	    \end{tikzpicture}
	};
	\node[right=.25 of 2] (3) {
        \begin{tikzpicture}[polybox, mapstos]
        	\node[poly, dom, "$\car{c}$" left] (r) {$f\then\id_{\cod f}$\at$i$};
        	\node[poly, cod, right=2.1 of r.south, yshift=-2.5ex, "$\car{c}$" below] (p) {$f$\at$i$};
        	\node[poly, above=.8 of p, xshift=1.5ex, "$\car{c}$" above] (p') {$\id_{\cod f}$\at$\cod f$};
        	
        	\draw (r_pos) to[first] node[below] {} (p_pos);
        	\draw (p_dir) to[climb] node[right] {$\cod$} (p'_pos);
        	\draw (p'_pos) to[climb'] node[right] {$\idy$} (p'_dir);
        	\draw (p'_dir) to[last] node[above] {$\then$} (r_dir);
        \end{tikzpicture}
	};
    \node at ($(1.east)!.2!(2.west)$) {=};
    \node at ($(2.east)!.5!(3.west)$) {=};
\end{tikzpicture}
\]
We find that on directions, the erasure laws state that for every object $i\in\Ob\cat{C}$ and morphism $f\colon i\to\_$ in $\cat{C}$,
\[
    \id_i\then f=f=f\then\id_{\cod f}.
\]
But these are precisely the identity laws of the category $\cat{C}$.

\subsubsection{The coassociative law on positions: codomains of composites}

It remains to consider the comonoid's coassociative law \eqref{eqn.coassoc_law}, $\delta\then(\delta\tri\car{s})=\delta\then(\car{s}\tri\delta)$.
To read what it says on positions, we draw the polyboxes and fill them in, stopping just short of the uppermost direction box of the codomain:
\[
\begin{tikzpicture}
    \node (p1) {
        \begin{tikzpicture}[polybox, tos]
            \node[poly, dom, "$\car{s}$" left] (m') {\at$i$};
            \node[poly, right=1.8 of m'.south, yshift=-1ex, "$\car{s}$" below] (mm') {$f\then g$\at$i$};
            \node[poly, above=of mm', "$\car{s}$" above] (C') {\at$\cod(f\then g)$};
            \node[poly, cod, right=2.3 of mm'.south, yshift=-1ex, "$\car{s}$" right] (D') {$f$\at$i$};
            \node[poly, cod, above=of D', "$\car{s}$" right] (mmm') {$g$\at$\cod f$};
            \node[poly, cod, above=of mmm', "$\car{s}$" right] (CC') {\at$\cod(f\then g)$};
            %
            \draw[double, -] (m'_pos) to[first] (mm'_pos);
            \draw (mm'_dir) to[climb] node[right] {$\cod$} (C'_pos);
            \draw (C'_dir) to[last] node[above] {$\then$} (m'_dir);
            \draw[double, -] (mm'_pos) to[first] (D'_pos);
            \draw (D'_dir) to[climb] node[right] {$\cod$} (mmm'_pos);
            \draw (mmm'_dir) to[last] node[above] {$\then$} (mm'_dir);
            \draw[double, -] (C'_pos) to[first] (CC'_pos);
            \draw[double, -] (CC'_dir) to[last] (C'_dir);
        \end{tikzpicture}
	};
%
	\node (p2) [right=of p1] {
	    \begin{tikzpicture}[polybox, tos]
            \node[poly, dom, "$\car{s}$" left] (m) {\at$i$};
            \node[poly, right=1.8 of m.south, yshift=-1ex, "$\car{s}$" below] (D) {$f$\at$i$};
            \node[poly, above=of D, "$\car{s}$" above] (mm) {\at$\cod f$};
            \node[poly, cod, right=2.1 of D.south, yshift=-1ex, "$\car{s}$" right] (DD) {$f$\at$i$};
            \node[poly, cod, above=of DD, "$\car{s}$" right] (mmm) {$g$\at$\cod f$};
            \node[poly, cod, above=of mmm, "$\car{s}$" right] (C) {\at$\cod g$};
            %
            \draw[double, -] (m_pos) to[first] (D_pos);
            \draw (D_dir) to[climb] node[right] {$\cod$} (mm_pos);
            \draw (mm_dir) to[last] node[above] {$\then$} (m_dir);
            \draw[double, -] (D_pos) to[first] (DD_pos);
            \draw[double, -] (DD_dir) to[last] (D_dir);
            \draw[double, -] (mm_pos) to[first] (mmm_pos);
            \draw (mmm_dir) to[climb] node[right] {$\cod$} (C_pos);
            \draw (C_dir) to[last] node[above] {$\then$} (mm_dir);
        \end{tikzpicture}
    };	
	\node at ($(p1.south)!.5!(p2.north)$) {$=$};
\end{tikzpicture}
\]
So on positions, the coassociative law states that given an object $i\in\Ob\cat C$ and morphisms $f\colon i\to\_$ and $g\colon\cod f\to\_$ in $\cat C$,
\[
    \cod(f\then g)=\cod g.
\]
Hence composites are assigned the proper codomains.

\subsubsection{The coassociative law on directions is the associative law of composition}

Finally, let us fill in the remaining polyboxes for the coassociative law (we'll substitute $\cod g$ for $\cod(f\then g)$ on the left, which we now know we can do):
\[
\begin{tikzpicture}
    \node (p1) {
        \begin{tikzpicture}[polybox, tos]
            \node[poly, dom, "$\car{s}$" left] (m') {$(f\then g)\then h$\at$i$};
            \node[poly, right=1.8 of m'.south, yshift=-1ex, "$\car{s}$" below] (mm') {$f\then g$\at$i$};
            \node[poly, above=of mm', "$\car{s}$" above] (C') {$h$\at$\cod g$};
            \node[poly, cod, right=2 of mm'.south, yshift=-1ex, "$\car{s}$" right] (D') {$f$\at$i$};
            \node[poly, cod, above=of D', "$\car{s}$" right] (mmm') {$g$\at$\cod f$};
            \node[poly, cod, above=of mmm', "$\car{s}$" right] (CC') {$h$\at$\cod g$};
            %
            \draw[double, -] (m'_pos) to[first] (mm'_pos);
            \draw (mm'_dir) to[climb] node[right] {$\cod$} (C'_pos);
            \draw (C'_dir) to[last] node[above] {$\then$} (m'_dir);
            \draw[double, -] (mm'_pos) to[first] (D'_pos);
            \draw (D'_dir) to[climb] node[right] {$\cod$} (mmm'_pos);
            \draw (mmm'_dir) to[last] node[above] {$\then$} (mm'_dir);
            \draw[double, -] (C'_pos) to[first] (CC'_pos);
            \draw[double, -] (CC'_dir) to[last] (C'_dir);
        \end{tikzpicture}
	};
%
	\node (p2) [right=.8 of p1] {
	    \begin{tikzpicture}[polybox, tos]
            \node[poly, dom, "$\car{s}$" left] (m) {$f\then(g\then h)$\at$i$};
            \node[poly, right=2.2 of m.south, yshift=-1ex, "$\car{s}$" below] (D) {$f$\at$i$};
            \node[poly, above=of D, "$\car{s}$" above] (mm) {$g\then h$\at$\cod f$};
            \node[poly, cod, right=2 of D.south, yshift=-1ex, "$\car{s}$" right] (DD) {$f$\at$i$};
            \node[poly, cod, above=of DD, "$\car{s}$" right] (mmm) {$g$\at$\cod f$};
            \node[poly, cod, above=of mmm, "$\car{s}$" right] (C) {$h$\at$\cod g$};
            %
            \draw[double, -] (m_pos) to[first] (D_pos);
            \draw (D_dir) to[climb] node[right] {$\cod$} (mm_pos);
            \draw (mm_dir) to[last] node[above] {$\then$} (m_dir);
            \draw[double, -] (D_pos) to[first] (DD_pos);
            \draw[double, -] (DD_dir) to[last] (D_dir);
            \draw[double, -] (mm_pos) to[first] (mmm_pos);
            \draw (mmm_dir) to[climb] node[right] {$\cod$} (C_pos);
            \draw (C_dir) to[last] node[above] {$\then$} (mm_dir);
        \end{tikzpicture}
    };	
	\node at ($(p1.south)!.5!(p2.north)$) {$=$};
\end{tikzpicture}
\]
Thus, on directions, the coassociative law states that given an object $i\in\Ob\cat C$ and morphisms $f\colon i\to\_, g\colon\cod f\to\_,$ and $h\colon\cod g\to\_$ in $\cat C$,
\[
    (f\then g)\then h = f\then(g\then h).
\]
But this is precisely the associative law of composition in a category.

We've seen that the data and equations of polynomial comonoids correspond exactly to the data and equations of categories.
This proves \cref{thm.ahman_uustalu}.

\subsubsection{Generalized duplicators as unbiased composition}

Before we move onto examples, one more note about the theory: notice that both sides of our coassociative law are given by $\delta^{(3)}\colon\car{c}\to\car{c}\tripow3$, as defined in \cref{prop.n_duplication}.
On directions, $\delta^{(3)}$ tells us how to compose three morphisms $i\To{f}\_\To{g}\_\To{h}\_$ in $\cat{C}$ all at once to obtain $i\To{f\:\then\:g\:\then\:h}\_$, and (co)associativity ensures this is well-defined.

In general, $\delta^{(n)}\colon\car{c}\to\car{c}\tripow{n}$ on directions tells us how to compose $n$ morphisms in $\cat{C}$ for each $n\in\nn$.
After all, we have already seen that $\delta^{(2)}=\delta$ performs binary composition, that $\delta^{(1)}=\id_\car{c}$ performs ``unary'' composition (the ``unary composite'' of a single morphism $f$ is just $f$ itself), and that $\delta^{(0)}=\epsilon$ performs ``nullary'' composition (the ``nullary composite'' at any object is just its identity).
The directions of $\car{c}\tripow{n}$ at positions in the image of $\delta^{(n)}$ are exactly the sequences of composable morphisms of length $n$, and $\delta^{(n)}$ sends each sequence to the single direction that is its composite.

%---- Subsection ----%
\subsection{Examples of categories as comonoids}
Now that we know that polynomial comonoids are just categories, let's review some simple examples of categories and see how they may be interpreted as comonoids.
As we go through these examples, pay attention to how the polynomial perspective causes us to view these familiar categories somewhat differently than usual. 

\subsubsection{Preorders}

A \emph{preorder} (or \emph{thin category}) is a category in which every morphism $f\colon c\to d$ is the \emph{only} morphism $c\to d$.%
\footnote{Sometimes these are also called \emph{posets}, short for \emph{partially ordered sets}, but strictly speaking the only isomorphisms in a poset are its identities, while a preorder allows objects to be isomorphic without being equal.}
Composition in preorders is easy to describe, because the composite of $c\to d$ and $d\to e$ is always just the unique arrow $c\to e$.
As such, preorders are some of the simplest examples of categories to consider---we already saw several in \cref{exc.ema_polys}---so let us interpret these as comonoids first.

\begin{example}\label{ex.walking_arrow_cat}
Let us revisit \cref{ex.walking_arrow_com}, where we first wrote down a comonoid that was not a state system.
We defined $\car{a}\coloneqq\{s\}\yon^{\{\id_s,a\}}+\{t\}\yon^{\{\id_t\}}\iso\yon^\2+\yon$ and gave it a comonoid structure, with eraser $\epsilon\colon\car{a}\to\yon$ specifying directions $\id_s$ and $\id_t$ and duplicator $\delta\colon\car{a}\to\car{a}\tri\car{a}$ pointing the direction $a$ at $t$.

Looking at the picture we drew of the comonoid in \eqref{eqn.walking_arrow_bent_cor}, it should come as no surprise that the corresponding category $\cat{A}$ is the \emph{walking arrow category}, which is a preorder with two objects and one morphism between them:
\begin{center}
    $\cat{A}\coloneqq\:$\boxCD{examplecolor}{
    $s\Too{a}t$}
\end{center}
Here we omit the identity morphisms from our picture, but we know that they exist.

The category $\cat{A}$ has two objects, the $\car{a}$-positions $s$ and $t$.
It has two morphisms with domain $s$, the $\car{a}[s]$-directions $\id_s$ and $a$; and one morphism with domain $t$, the $\car{a}[t]$-direction $\id_t$.
The morphisms $\id_s$ and $\id_t$ picked out by the erasure are the identity morphisms, and the duplicator assigns them codomains that are equal to their domains.
The duplicator also assigns $a$ the codomain $t$; and as $\cat{A}$ is then a preorder, composites are determined automatically.
\end{example}

\begin{exercise}
Let $(\car{c},\epsilon,\delta)$ be the comonoid corresponding to the preorder depicted as follows (identity morphisms omitted):
\begin{center}
    \boxCD{exercisecolor}{$B\From{f}A\To{g}C$}
\end{center}
\begin{enumerate}
    \item What is the carrier $\car{c}$?
    \item Characterize the eraser $\epsilon$.
    \item Characterize the duplicator $\delta$.\qedhere
\end{enumerate}
\begin{solution}
We are given a comonoid $(\car{c},\epsilon,\delta)$ corresponding to the preorder \boxCD{white}{$B\From{f}A\To{g}C$}.
\begin{enumerate}
    \item There are three morphisms with domain $A$, namely $\id_A,f,$ and $g$; the only other morphisms are the identity morphisms on $B$ and $C$.
    So the carrier is $\car{c}=\{A\}\yon^{\{\id_A,f,g\}}+\{B\}\yon^{\{\id_B\}}+\{C\}\yon^{\{\id_C\}}$.
    \item It suffices to specify the eraser $\epsilon\colon\car{c}\to\yon$ on directions: as always, $\epsilon_i^\sharp\colon\1\to\car{c}[i]$ picks out $\id_i$ for each $i\in\car{c}(\1)=\{A,B,C\}$.
    \item The duplicator $\delta\colon\car{c}\to\car{c}\tri\car{c}$ tells us the codomain of each morphism, as well as how every pair of composable morphisms compose (which in the case of a preorder can be deduced automatically).
    So we can completely characterize the behavior of $\delta$ using polyboxes as follows:
\[
\begin{tikzpicture}[polybox, mapstos, node distance=2ex and 1.4cm, font=\tiny]
  \node (a) {
  \begin{tikzpicture}
  	\node[poly, dom] (p) {$\id_A$\at$A$};
  	\node[poly, cod, right=of p.south, yshift=-1ex] (q) {$\id_A$\at$A$};
  	\node[poly, cod, above=of q] (r) {$\id_A$\at$A$};
  	\draw[double, -] (p_pos) to[first] (q_pos);
  	\draw (q_dir) to[climb] (r_pos);
  	\draw (r_dir) to[last] (p_dir);
  \end{tikzpicture}
  };
  \node[right=.6 of a] (b) {
  \begin{tikzpicture}
  	\node[poly, dom] (p) {$f$\at$A$};
  	\node[poly, cod, right=of p.south, yshift=-1ex] (q) {$\id_A$\at$A$};
  	\node[poly, cod, above=of q] (r) {$f$\at$A$};
  	\draw[double, -] (p_pos) to[first] (q_pos);
  	\draw (q_dir) to[climb] (r_pos);
  	\draw (r_dir) to[last] (p_dir);
  \end{tikzpicture}
  };
  \node[right=.6of b] (c) {
  \begin{tikzpicture}
  	\node[poly, dom] (p) {$g$\at$A$};
  	\node[poly, cod, right=of p.south, yshift=-1ex] (q) {$\id_A$\at$A$};
  	\node[poly, cod, above=of q] (r) {$g$\at$A$};
  	\draw[double, -] (p_pos) to[first] (q_pos);
  	\draw (q_dir) to[climb] (r_pos);
  	\draw (r_dir) to[last] (p_dir);
  \end{tikzpicture}
  };
  \node[right=.6 of c] (d) {
  \begin{tikzpicture}
  	\node[poly, dom] (p) {$f$\at$A$};
  	\node[poly, cod, right=of p.south, yshift=-1ex] (q) {$f$\at$A$};
  	\node[poly, cod, above=of q] (r) {$\id_B$\at$B$};
  	\draw[double, -] (p_pos) to[first] (q_pos);
  	\draw (q_dir) to[climb] (r_pos);
  	\draw (r_dir) to[last] (p_dir);
  \end{tikzpicture}
  };
  \node[below=.6 of a] (e) {
  \begin{tikzpicture}
  	\node[poly, dom] (p) {$g$\at$A$};
  	\node[poly, cod, right=of p.south, yshift=-1ex] (q) {$g$\at$A$};
  	\node[poly, cod, above=of q] (r) {$\id_C$\at$C$};
  	\draw[double, -] (p_pos) to[first] (q_pos);
  	\draw (q_dir) to[climb] (r_pos);
  	\draw (r_dir) to[last] (p_dir);
  \end{tikzpicture}
  };
  \node[below=.6 of b] (f) {
  \begin{tikzpicture}
  	\node[poly, dom] (p) {$\id_B$\at$B$};
  	\node[poly, cod, right=of p.south, yshift=-1ex] (q) {$\id_B$\at$B$};
  	\node[poly, cod, above=of q] (r) {$\id_B$\at$B$};
  	\draw[double, -] (p_pos) to[first] (q_pos);
  	\draw (q_dir) to[climb] (r_pos);
  	\draw (r_dir) to[last] (p_dir);
  \end{tikzpicture}
	};
  \node[below=.6 of c] (g) {
  \begin{tikzpicture}
  	\node[poly, dom] (p) {$\id_C$\at$C$};
  	\node[poly, cod, right=of p.south, yshift=-1ex] (q) {$\id_C$\at$C$};
  	\node[poly, cod, above=of q] (r) {$\id_C$\at$C$};
  	\draw[double, -] (p_pos) to[first] (q_pos);
  	\draw (q_dir) to[climb] (r_pos);
  	\draw (r_dir) to[last] (p_dir);
  \end{tikzpicture}
	};
\end{tikzpicture}
\]
\end{enumerate}
\end{solution}
\end{exercise}

\begin{exercise} \label{exc.linear_poly_cat}
We showed in \cref{exc.linear_poly_comon} that for any set $B$, the linear polynomial $B\yon$ has a unique comonoid structure.
To what category does this comonoid correspond?
\begin{solution}
The linear polynomial $B\yon$ corresponds to a category whose objects form the set $B$ and whose only morphisms are identities: in other words, it is the discrete category on $B$.
\end{solution}
\end{exercise}

\begin{exercise}\label{ex.star_shaped}
\begin{enumerate}
	\item Find a comonoid structure for the polynomial $p\coloneqq{\yon}^{\ord{n}+\1}+\ord{n}\yon$ whose corresponding category is a preorder.
	(It is enough to fully describe the category that it corresponds to.)
	\item Would you call your category ``star-shaped''?
\qedhere
\end{enumerate}
\begin{solution}
\begin{enumerate}
    \item The polynomial $p\coloneqq{\yon}^{\ord{n}+\1}+\ord{n}\yon$ has $n+1$ positions: $1$ with $n+1$ directions and the rest with $1$ direction each.
    So any category carried by $p$ has $n+1$ objects, of which only $1$ has any nonidentity morphisms coming out of it: in fact, it has $n$ nonidentity morphisms coming out of it.
    But if the category is to be a preorder, each of these $n$ nonidentity morphisms must have a distinct codomain.
    As there are exactly $n$ other objects, this completely characterizes the category.
    Equivalently, it is the discrete category on $\ord{n}$ adjoined with a unique initial object, so that the only nonidentity morphisms are the morphisms out of that initial object to each of the other objects exactly once.
    \item This category can be thought of as ``star-shaped'' if we picture the initial object in the center with morphisms leading out to the other $n$ objects like spokes.
\end{enumerate}
\end{solution}
\end{exercise}


\begin{example}[State systems as categories] \label{ex.state_cat}
We know that every state system $\car{s}\iso S\yon^S$ with its do-nothing enclosure $\epsilon\colon\car{s}\to\yon$ and its transition lens $\delta\colon\car{s}\to\car{s}\tri\car{s}$ is a comonoid, so what category $\cat{S}$ does $(\car{s},\epsilon,\delta)$ correspond to?

Recall from \cref{ex.not_all_com_state} that state systems are exactly those comonoids whose codomain (i.e.\ ``target'') functions $\cod\colon\car{s}[s]\to\car{s}(\1)$ for $s\in\car{s}(\1)$ are bijections.
That is, from every object $s\in\Ob\cat S=\car{s}(\1)$, there is exactly $1$ morphism to every object $t\in\Ob\cat S$.
So not only is $\cat S$ a preorder, it is the \emph{codiscrete preorder} on $\car{s}(\1)$, where there is always a morphism between every pair of objects.

Let's redraw the polyboxes for the do-nothing enclosure of $\car{s}$ from \eqref{eqn.do_nothing_polybox} and the transition lens of $\car{s}$ from \eqref{eqn.trans_lens_polybox}, this time with our new arrow labels, as a sanity check:
\[
\begin{tikzpicture}
\node (erase) {

\begin{tikzpicture}[polybox, mapstos]
    \node[poly, dom, "$\car{s}$" left] (S) {$\id_s$\at$s$};

    \draw (S_pos) to[climb'] node[right] {$\idy$} (S_dir);
\end{tikzpicture}

};
\node[right=of erase] (dupl) {

\begin{tikzpicture}[polybox, mapstos]
	\node[poly, dom, "$\car{s}$" left] (r) {$s_0\to s_2$\at$s_0$};
	\node[poly, cod, right=2 of r.south, yshift=-2.5ex, "$\car{s}$" right] (p) {$s_0\to s_1$\at$s_0$};
	\node[poly, cod, above=.8 of p, "$\car{s}$" right] (p') {$s_1\to s_2$\at$s_1$};

	\draw[double, -] (r_pos) to[first] node[below] {} (p_pos);
	\draw (p_dir) to[climb] node[right] {$\cod$} (p'_pos);
	\draw (p'_dir) to[last] node[above] {$\then$} (r_dir);
  \end{tikzpicture}

};
\end{tikzpicture}
\]
Indeed, we had already been writing the directions of $\car{s}$ as arrows $s\to t$, knowing that each was uniquely specified by its source $s$ and its target $t$ in $\car{s}(\1)$.
And in \cref{subsec.comon.sharp.state.cohere}, we had already noted that $\id_s$ was just the arrow $s\to s$.
So state systems have been categories with exactly one morphism between every pair of objects all along.

Other names for this category include the \emph{indiscrete preorder} and the \emph{codiscrete} or \emph{indiscrete category}.
These names highlight the fact that every object of this category is isomorphic to every other object: in fact, every arrow $s\to t$ is an isomorphism with inverse $t\to s$, for these compose as $\id_s\colon s\to s$ in one direction and $\id_t\colon t\to t$ in the other.
Thus this category is also a \emph{groupoid}, and it may be called the \emph{codiscrete}, \emph{indiscrete}, or \emph{contractible groupoid}\dots but we will call it the \emph{state category on} $S$, where $S$ is the set of positions of $\car{s}$ or objects of $\cat S$. 

Here are the state categories on $\3$ and on $\1\5$, with all maps (even identities) drawn:
\[
\begin{tikzpicture}
\def\n{3}% how many nodes
\def\size{2cm}
\node[circle,minimum size=\size] (b) {};
\foreach\x in{1,...,\n}{
  \node[minimum size=0.75cm,draw,circle] (n-\x) at (b.{360/\n*\x}){\x};
}
\foreach\x in{1,...,\n}{
  \foreach\y in{1,...,\n}{
    \ifnum\x=\y\draw[->] (n-\x) to [in=360/\n*\x-15,out=360/\n*\x+15,loop] ();\relax\else
      \draw (n-\x) edge[->,bend right=10] (n-\y);
    \fi
  }
}
\def\n{15}% how many nodes
\def\size{4cm}
\node[circle,minimum size=\size, right=4 of b] (b) {};
\foreach\x in{1,...,\n}{
  \node[minimum size=0.75cm,draw,circle] (n-\x) at (b.{360/\n*\x}){\x};
}
\foreach\x in{1,...,\n}{
  \foreach\y in{1,...,\n}{
    \ifnum\x=\y\draw[->] (n-\x) to [in=360/\n*\x-15,out=360/\n*\x+15,loop] ();\relax\else
      \draw (n-\x) edge[->,bend right=3] (n-\y);
    \fi
  }
}
% Source: Asterix: https://tex.stackexchange.com/questions/390647/understanding-complete-graph-example-in-tikz
\end{tikzpicture}
\]
The picture on the left should look familiar: it's what we drew in \cref{ex.trans_trees} when took the corolla picture for $\3\yon^\3$ and bent the arrows to point at their targets according to its transition lens.
Notice that the graphs we obtain in this way are always complete.
\end{example}

\begin{exercise} \label{exc.not_state_cat_but_same_carrier}
Let $S$ be a set. Is there any comonoid structure on $S\yon^S$ other than that of the state category?
\begin{solution}
In the case of $S\coloneqq\0$, the only comonoid structure on $S\yon^S\iso\0$ is given by the empty category, the only category with no objects; and in the case of $S\coloneqq\1$, the only comonoid structure on $S\yon^S\iso\yon$ is given by the category with $1$ object and no nonidentity morphisms, again the only such category.
So in those cases, the comonoid structure on $S\yon^S$ is unique.

Now assume $|S|\geq2$.
The state category is always connected, but we can always find a comonoid structure on $S\yon^S$ given by a category that is not connected---and thus not isomorphic to the state category---as follows.
Consider a category whose object set is $S$ that has no morphisms between distinct objects, so that it is certainly not connected.
Then to specify the category, it suffices to specify a monoid associated with each object that will give the morphisms whose domain and codomain are equal to that object.
But there is always a monoid structure on a given set $S$.
If $S$ is finite, we can take the cyclic group $\zz/|S|\zz$ of order $|S|$, so that the resulting category has carrier $S\yon^{\zz/|S|\zz}\iso S\yon^S$.
On the other hand, if $S$ is infinite, we can take the free monoid on $S$, which has cardinality $\sum_{n\in\nn}|S|^\ord{n}=|\nn||S|=|S|$.
So the resulting category will again have carrier $S\yon^S$.
\end{solution}
\end{exercise}

Not only does \cref{ex.state_cat} finally explain what our state systems really are (they're just special categories!), it illustrates two important features of our story.
One is that on positions, the duplicator $\delta\colon\car{c}\to\car{c}\tri\car{c}$ of a comonoid takes the corolla picture of $\car{c}$ and ``bends the arrows'' so that they point to other roots, yielding the underlying graph of a category.
Then $\delta$ on directions collapses two-arrow paths in the graph down to individual arrows, while the eraser $\epsilon\colon\car{c}\to\yon$ identifies empty paths with identity arrows.

Another important point is that we can view any category as a \emph{generalized state system}: its objects as \emph{states}, and its morphisms as \emph{transitions} between states.
The polynomial comonoid perspective is particularly suited for thinking about categories in this way: each object is a position that we could be in, and each morphism out of that object is a direction that we might take.
What is special about a comonoid is that each direction will always have another position at the end of it, making it reasonable to think of these directions as transitions between different states; and any sequence of transitions that we can follow is itself a transition.

Comparing these ideas, we see that they say the same thing: the first from the perspective of trees and graphs, the second from the perspective of arenas and dynamics.
We might say that
\slogan{
    a comonoid structure on a corolla forest turns\\
    roots into vertices and\\
    leaves into composable arrows between vertices;
}
or that
\slogan{
    a comonoid structure on an arena turns\\
    positions into states and\\
    directions into composable transitions between states.
}

\subsubsection{Monoids and monoid actions}

Here we use \emph{monoid} to refer to a monoid in the monoidal category $(\smset,\1,\times)$.
We denote such a monoid by $(M,e,*)$, where $M$ is the underlying set, $e\in M$ is the unit, and $*\colon M\times M\to M$ is the binary operation.

\begin{example}[Monoids as representable comonoids]\label{ex.monoids}
Recall that every monoid $(M,e,*)$ can be identified with a $1$-object category $\cat{M}$ with a single hom-set $M$, a single identity morphism $e$, and composition given by $*$.
Now we know that a $1$-object category $\cat{M}$ is also a polynomial comonoid $(\car{m},\epsilon,\delta)$ whose carrier has $1$ position, with all of the morphisms of $\cat{M}$ becoming its directions.
So the carrier of $\cat{M}$ is the representable polynomial $\yon^M$.

Then the eraser $\epsilon\colon\yon^M\to\yon$ picks out the identity morphism $e\in M$ on directions, while the duplicator $\delta\colon\yon^M\to\yon^M\tri\yon^M\iso\yon^{M\times M}$ can be identified with the binary operation $*\colon M\times M\to M$.
(We don't have to worry about codomains, since there's only one possible codomain to choose from.)
In this way, every monoid $(M,e,*)$ in $\smset$ gives rise to a representable comonoid $(\yon^M,\epsilon,\delta)$ in $\poly$.
We can just as easily invert this construction, obtaining a monoid for every representable comonoid by taking the underlying set to be the carrier's set of directions, the unit to be the direction picked out by the erasure, and the binary operation to be the duplicator's on-directions function.

% Let $(M,e,*)$ be a monoid.
% Recall that a 

% Then we can construct a comonoid structure on the representable $\yon^M$. A morphism $\yon^M\to\yon$ can be identified with an element of $M$; under that identification we take $\epsilon\coloneqq e$. Similarly, $\yon^M\tri\yon^M\cong\yon^{M^\2}$ and a morphism $\yon^M\to\yon^{M^\2}$ can be identified with a function $M^\2\to M$; under that identification we take $\delta\coloneqq *$.
\end{example}

\begin{exercise}
Verify \cref{ex.monoids} by showing that $(M,e,*)$ satisfies the unitality and associativity requirements of a monoid in $(\smset,\1,\times)$ if and only if $(\yon^M,\epsilon,\delta)$ satisfies the erasure and coassociativity requirements of a comonoid in $(\poly,\yon,\tri)$.
\begin{solution} %
The fact that monoids $(M,e,*)$ in $(\smset,\1,\times)$ are just comonoids $(\yon^M,\epsilon,\delta)$ in $(\poly,\yon,\tri)$, following the construction of \cref{ex.monoids}, is a direct consequence of the fully faithful Yoneda embedding $\smset\op\to\poly$ sending $A\mapsto\yon^A$ that maps $\1\mapsto\yon, A\times B\mapsto\yon^{A\times B}\iso\yon^A\tri\yon^B$ naturally, and $M\mapsto\yon^M$.

We can also state the laws and the correspondences between them explicitly, keeping in mind that $e$ and $*$ are just the on-directions functinos of $\epsilon$ and $\delta$.
The monoid's unitality condition states that $e$ is a $2$-sided unit for $*$, or that
\[
\begin{tikzcd}[row sep=large]
	\1\times M & M\ar[from=d, "*" description]\ar[from=r, equal]\ar[from=l, equal]&M\times\1\\&
	M\times M,\ar[from=ul, "e\:\times\:M"']\ar[from=ur, "M\:\times\:e"]
\end{tikzcd}
\]
commutes---equivalent to the comonoid's erasure laws, which state that 
\[
\begin{tikzcd}[row sep=large]
	\yon\tri \yon^{M}&\yon^{M}\ar[d, "\delta" description]\ar[r, equal]\ar[l, equal]&\yon^{M}\tri\yon\\&
	\yon^{M}\tri\yon^{M},\ar[ul, "\epsilon\:\tri\:\yon^{M}"]\ar[ur, "\yon^{M}\:\tri\:\epsilon"']
\end{tikzcd}
\]
commutes (trivial on positions, equivalent to the monoid's unitality condition on directions).

Similarly, the monoid's associativity condition states that $*$ is associative, or that
\[
\begin{tikzcd}[row sep=large]
	M \ar[from=r, "*"']\ar[from=d, "*"]&
	M \times M \ar[from=d, "M\:\times\:*"']\\
	M \times M \ar[from=r, "*\:\times\:M"]&
	M \times M \times M,
\end{tikzcd}
\]
commutes---equivalent to the comonoid's coassociative law, which state that 
\[
\begin{tikzcd}[row sep=large]
	\yon^{M}\ar[r, "\delta"]\ar[d, "\delta"']&
	\yon^{M}\tri\yon^{M}\ar[d, "\yon^{M}\:\tri\:\delta"]\\
	\yon^{M}\tri \yon^{M}\ar[r, "\delta\:\tri\:\yon^{M}"']&
	\yon^{M}\tri\yon^{M}\tri\yon^{M},
\end{tikzcd}
\]
commutes (trivial on positions, equivalent to the monoid's associativity condition on directions).
\end{solution}
\end{exercise}

\begin{example}[Cyclic lists]
For any $n\in\nn$, consider $\zz/n\zz$, the cyclic group of order $n$, viewed as a monoid or, equivalently, a $1$-object category.
Its carrier is $\yon^{\zz/n\zz}$.

As a polynomial functor, $\yon^{\zz/n\zz}$ sends each set $X$ to the set of length-$n$ tuples in $X$.
But the comonoid structure lets us think of these tuples as \emph{cyclic lists}: once we reach the last element, we can loop back around to the first element.
Indeed, as a natural transformation, $\epsilon\colon\yon^{\zz/n\zz}\to\yon$ picks out the ``current'' element via its $X$-component $\epsilon\tri X\colon\yon^{\zz/n\zz}\tri X\to\yon\tri X$, which is just a function $\epsilon_X\colon X^{\zz/n\zz}\to X$; and $\delta$ lets us move around the list.

We will see later that comonoids are closed under coproducts, so $\sum_{n\in\nn}\yon^{\zz/n\zz}$ is also a comonoid.
\end{example}

\begin{example}[Monoid actions]\label{ex.monoid_action}
Suppose that $(M,e,*)$ is a monoid, $S$ is a set, and $\alpha\colon S\times M\to S$ is a \emph{(right) monoid action}.
That is, for all $s\in S$ we have $\alpha(s,e)=s$ and $\alpha(s,m*n)=\alpha(\alpha(s,m),n)$ for $m,n\in M$; equivalently, the diagrams
\[
\begin{tikzcd}
	S\times\1\ar[rd,equals]\ar[r,"S\:\times\:e"] & S\times M\ar[d,"\alpha"]\\
	& S
\end{tikzcd}
\qqand
\begin{tikzcd}[row sep=large]
    S\times M\times M\ar[r,"S\:\times\:*"]\ar[d,"\alpha\:\times\:M"] & S\times M\ar[d,"\alpha"]\\
    S\times M\ar[r,"\alpha"] & S
\end{tikzcd}
\]
commute.

Then there is an associated category $\cat{M\!A}$ with objects in $S$ and morphisms $s\To{m}\alpha(s,m)$ for each $s\in S$ and $m\in M$.
This, in turn, corresponds to a comonoid $(S\yon^M,\epsilon,\delta)$, as we will see in the next exercise.
\end{example}

\begin{exercise}
With notation as in \cref{ex.monoid_action}, characterize the comonoid structure on $S\yon^M$.
\begin{enumerate}
    \item How can we define the erasure $\epsilon$?
    \item How can we define the duplicator $\delta$?
    \item Verify that the erasure laws hold.
    \item Verify that the coassociative law holds.
    \item Describe the corresponding category $\cat{M\!A}$.
    In particular, what are the morphisms between any fixed pair of objects, what are the identity morphisms, and how do morphisms compose?
	\item $M$ always acts on itself by multiplication. Is the associated comonoid structure on $M\yon^M$ the same or different from the one coming from \cref{ex.state_cat}?
\qedhere
\end{enumerate}
\begin{solution}
Here $(M,e,*)$ is a monoid, $S$ is a set, $\alpha\colon S\times M\to S$ is a monoid action, and $\cat{M\!A}$ is the associated category, whose corresponding comonoid is $(S\yon^M,\epsilon,\delta)$.
We also know that for each $s\in S$ and $m\in M$, there is a morphism $s\To{m} \alpha(s,m)$ in $\cat{M\!A}$.
\begin{enumerate}
    \item The erasure $\epsilon\colon S\yon^M\to\yon$ picks out an element of $m\in M$ for every element $s\in S$ that will play the role of an identity, which in particular should also have $s$ as its codomain.
    Since we want the codomain of the morphism $m$ out of $s$ to be $\alpha(s,m)$, we can take $m=e$ to guarantee that its codomain will be $\alpha(s,e)=s$.
    So we let $\epsilon$ be the lens whose on-directions function at each $s\in S$ is $\epsilon^\sharp_s\colon\1\to M$ always maps to $e$.
    \item The duplicator $\delta\colon S\yon^M\to S\yon^M\tri S\yon^M$ is determined by what we want the codomain of each morphism to be and how we want the morphisms to compose.
    We already know that we want the morphism $m\in M$ out of each $s\in S$ to have the codomain $\alpha(s,m)$.
    If we then have another morphism $n\in M$ out of $\alpha(s,m)$, its codomain will be $\alpha(\alpha(s,m),n)=\alpha(s,m*n)$, the same as the codomain of the morphism $m*n$ out of $s$.
    So it makes sense for the composite $s\To{m}\alpha(s,m)\To{n} \alpha(\alpha(s,m),n)$ to be the morphism $s\To{m*n}\alpha(s,m*n)$.
    Thus, we can define $\delta$ in polyboxes as
    \[
    \begin{tikzpicture}[polybox, mapstos, font=\tiny]
        \node[poly, dom] (p) {$m*n$\at$s$};
        \node[poly, cod, right=1.5 of p.south, yshift=-1ex] (q) {$m$\at$s$};
        \node[poly, cod, above=of q, xshift=3] (r) {$n$\at$\alpha(s,m)$};
        \draw[double, -] (p_pos) to[first] (q_pos);
        \draw (q_dir) to[climb] node[right] {$\cod$} (r_pos);
        \draw (r_dir) to[last] node[above] {$\then$} (p_dir);
    \end{tikzpicture}
    \]
    \item We constructed $\delta$ above so that its bottom arrow is an identity function, so verifying the erasure laws amounts to checking that the direction $e\in M$ that $\epsilon$ picks out at each position $s\in S$ really does function as an identity morphism $s\To{e}\alpha(s,e)$ under the codomain and composition operations specified by $\delta$.
    We have already ensured that the codomain of $e$ at $s$ is $\alpha(s,e)=s$; meanwhile, given $m\in M$ we have that the composite of $s\To{m}\alpha(s,m)\To{e}\alpha(s,m)$ is $m*e=m$ and that the composite of $s\To{e}s\To{m}\alpha(s,m)$ is $e*m=m$ by the monoid's own unit laws.
    So the erasure laws hold.
    \item Verifying the coassociativity of $\delta$ amounts to checking that composition plays nicely with codomains and is associative.
    We already checked the former when defining $\delta$, and the latter follows from the monoid's own associativity laws: given $m,n,p\in M$, we have $(m*n)*p=m*(n*p)$.
    \item The associated category $\cat{M\!A}$ is a category whose objects are the elements of the set $S$ being acted on, and whose morphisms $s\to t$ for each $s,t\in S$ are the elements of the monoid $m\in M$ that send $s$ to $t$, i.e.\ $\alpha(s,m)=t$.
    The identity morphism on each object is just the unit $e\in M$, while morphisms compose via the multiplication $*$.
    
    \item It is the same iff $M$ is a group, i.e.\ if every $m\in M$ has an inverse. Indeed, the comonoid structure on $M\yon^M$ from \cref{ex.state_cat} corresponds to a category in which every map is an isomorphism, so for each $m\in M$, the left-action $\alpha(m,-)\colon M\to M$ would need to be a bijection, and this is the case iff $M$ is a group. 
\end{enumerate}
\end{solution}
\end{exercise}

\begin{example}[The category of $B$-streams]\label{ex.streams_category}
Fix a set $B$.
The set $B^\nn$ consists of countable sequences of elements in $B$, which we will call \emph{$B$-streams}.
We can write an $B$-stream $\ol{b}\in B^\nn$ as
\[
    \ol{b}\coloneqq(b_0\to b_1\to b_2\to b_3\to\cdots),
\]
with $b_n\in B$ for each $n\in\nn$.

Then there is a monoid action $\tau\colon B^\nn\times\nn\to B^\nn$ for which
\[
    \tau(\ol{b},n)\coloneqq(b_n\to b_{n+1}\to b_{n+2}\to b_{n+3}\to\cdots).
\]
Roughly speaking, $\nn$ acts on $B$-streams by shifting them forward by a natural number of steps.
We can check that this is a monoid action by observing that $\tau(\ol{b},0)=\ol{b}$ and that $\tau(\ol{b},m+n)=\tau(\tau(\ol{b},m),n)$.

So by \cref{ex.monoid_action}, the corresponding comonoid is carried by $B^\nn\yon^\nn$.
Each $B$-stream $\ol{b}$ is a position, and each $n\in\nn$ is a direction at $\ol{b}$ that can be visualized as the sequence of $n$ arrows starting from $b_0$ and ending at $b_n$.
Then at the end of the direction $n$ is a new $B$-stream: the rest of $\ol{b}$ starting at $b_n$.
Indeed, this $B$-stream is exactly $\tau(\ol{b},n)$, the codomain assigned to the direction $n$ at $\ol{b}$.

Alternatively, if we shift from the domain-centric perspective to the usual hom-set perspective, this comonoid corresponds to a category whose objects are $B$-streams and whose morphisms $\ol{b}\to\ol{b'}$ consist of every way in which $\ol{b'}$ can be viewed as a continguous substream of $\ol{b}$: that is, there is a morphism $n\colon\ol{b}\to\ol{b'}$ for each $n\in\nn$ satisfying
\[
    (b_n\to b_{n+1}\to\cdots)=(b'_0\to b'_1\to\cdots).
\]
The identity on $\ol{b}$ is given by $0\colon\ol{b}\to\ol{b}$; and the composite of two morphisms is the sum of the corresponding natural numbers, as a substream of a substream of $\ol{b}$ is just a substream of $\ol{b}$ shifted by the appropriate amount.

We will see this category again in \cref{ex.streams_cofree}.
\end{example}

\begin{exercise}
Let $\rr/\zz\iso[0,1)$ be the quotient of $\rr$ by the $\zz$-action sending $(r,n)\mapsto r+n$. 
More concretely, it is the set of real numbers between 0 and 1, including 0 but not 1.
\begin{enumerate}
	\item Find a comonoid structure on $(\rr/\zz)\yon^\rr$.
	\item Is the corresponding category a groupoid?
\qedhere
\end{enumerate}
\begin{solution}
\begin{enumerate}
    \item Since $\rr$ acts on $\rr/\zz$ by addition modulo 1, (e.g.\ $\alpha(.7,5.4)=.1$), we obtain a comonoid structure on $(\rr/\zz)\yon^\rr$ by \cref{ex.monoid_action}. For example, the erasure $(\rr/\zz)\yon^\rr\to\yon$ sends everything to $0\in\rr$, because $0$ is the identity in $\rr$. 
    \item Yes it is a groupoid because $\rr$ is a group: every element is invertible.
\end{enumerate}
\end{solution}
\end{exercise}


\subsubsection{The degree of an object}

We could continue to list examples of polynomial comonoids, but of course any list of small categories is already a list of such comonoids.
So instead, we conclude this section with some terminology that the polynomial perspective on a category affords.

\begin{definition}[Degree, linear]
Let $\cat{C}$ be a category and $c\in\Ob\cat{C}$ an object. The \emph{degree of $c$}, denoted $\deg(c)$, is the set of arrows in $\cat{C}$ that emanate from $c$.

If $\deg(c)\iso\1$, we say that $c$ is \emph{linear}.
If $\deg(c)\iso\ord{n}$ for $n\in\nn$, we say $c$ has \emph{degree $n$}.
\end{definition}

\begin{exercise}
\begin{enumerate}
	\item If every object in $\cat{C}$ is linear, what can we say about $\cat{C}$?
	\item Is it possible for an object in $\cat{C}$ to have degree $0$?
	\item Find a category that has an object of degree $\nn$.
	\item Up to isomorphism, how many categories are there that have just one linear and one quadratic (degree 2) object?
	\item Is the above the same as asking how many comonoid structures on $\yon^\2+\yon$ there are?\qedhere
\end{enumerate}
\begin{solution}
\begin{enumerate}
    \item If every object in $\cat{C}$ is linear, then the only morphisms in $\cat{C}$ are the identity morphisms, so $\cat{C}$ must be a discrete category.
    \item It is not possible for an object in $\cat{C}$ to have degree $0$, as every object must have at least an identity morphism emanating from it.
    \item Some possible examples of categories with objects of degree $\nn$ are the monoid $(\nn, 0, +)$ (see \cref{exc.ema_polys} \cref{exc.ema_polys.nat_monoid}), the poset $(\nn, \leq)$ (see \cref{exc.ema_polys} \cref{exc.ema_polys.nat_poset}), and the state category on $\nn$ (see \cref{ex.state_cat}).
    \item Up to isomorphism, there are $3$ categories with just one linear and one quadratic object.
    They can be distinguished by the behavior of the single nonidentity morphism.
    Either its domain and its codomain are distinct, in which case we have the walking arrow category; or its domain and its codomain are the same, in which case it can be composed with itself to obtain either itself or the identity.
    So there are $3$ possible categories in total.
    \item Yes: since (isomorphic) categories correspond to (isomorphic) comonoids, there are as many categories with one linear and one quadratic object up to isomorphism as there are comonoid structures on $\yon^\2+\yon$.
\end{enumerate}
\end{solution}
\end{exercise}


%-------- Section --------%
\section{Morphisms of polynomial comonoids are cofunctors} \label{sec.comon.sharp.cof}

Now that we have characterized the comonoids of $\poly$, let us consider the morphisms between them.
These turn out to correspond to a rather odd kind of map between categories known as a \emph{cofunctor}.

%---- Subsection ----%
\subsection{Introducing comonoid morphisms and cofunctors}

First, let us define morphisms of comonoids in the most general setting.
If you've seen the definition of a monoid homomorphism (or even a group homomorphism), then this definition may look familiar.

\begin{definition}[Comonoid morphism]\label{def.morphism_comonoids}
Given a monoidal category $(\cat{C},\yon,\tri)$ with comonoids $\com{C}\coloneqq(\car{c},\epsilon,\delta)$ and $\com{C}'\coloneqq(\car{c'},\epsilon',\delta')$, a \emph{comonoid morphism} (or \emph{morphism of comonoids}) $\com{C}\to\com{C}'$ is a morphism $F\colon \car{c}\to\car{c'}$ in $\cat{C}$ for which the following diagrams commute:
\begin{equation}\label{eqn.pres_era}
\begin{tikzcd}
    \car{c}\ar[r, "F"]\ar[d, "\epsilon"']&
    \car{c'}\ar[d, "\epsilon'"]\\
    \yon\ar[r, equal]&
    \yon,
\end{tikzcd}
\end{equation}
called the \emph{eraser preservation law} (we say $F$ \emph{preserves erasure}); and
\begin{equation}\label{eqn.pres_dup}
\begin{tikzcd}
    \car{c}\ar[r, "F"]\ar[d, "\delta"']&
    \car{c'}\ar[d, "\delta'"]\\
    \car{c}\tri\car{c}\ar[r, "F\:\tri\:F"']&
    \car{c'}\tri\car{c'}
\end{tikzcd}
\end{equation}
called the \emph{duplicator preservation law} (we say $F$ \emph{preserves duplication}).
We may also say that $F$ \emph{preserves the comonoid structure}.

When the monoidal structure on $\cat{C}$ can be inferred, we let $\comon(\cat{C})$ denote the subcategory of $\cat{C}$ whose objects are comonoids in $\cat{C}$ and whose morphisms are comonoid morphisms.
\end{definition}

So when our monoidal category of interest is $(\poly,\yon,\tri)$, a morphism between polynomial comonoids is just a special kind of lens between their carriers that preserves erasure and duplication.

\begin{exercise}
There is something to be proved in the definition above: that comonoids and comonoid morphisms really do form a category.
Using the notation from \cref{def.morphism_comonoids}, verify the following:
\begin{enumerate}
    \item The identity morphism on a comonoid is a comonoid morphism.
    \item The composite of two comonoid morphisms is a comonoid morphism.
\end{enumerate}
This will show that $\comon(\cat{C})$ is indeed a subcategory of $\cat{C}$.
\begin{solution}
As in \cref{def.morphism_comonoids}, we have a monoidal category $(\cat{C},\yon,\tri)$ with comonoids $\com{C}\coloneqq(\car{c},\epsilon,\delta)$ and $\com{C}'\coloneqq(\car{c'},\epsilon',\delta')$ and a comonoid morphism $F\colon\com{C}\to\com{C'}$ (really a morphism $F\colon\car{c}\to\car{c'}$ in $\cat{C}$).
Let's throw in another comonoid $\com{C}''\coloneqq(\car{c''},\epsilon'',\delta'')$ and another comonoid morphism $G\colon\com{C'}\to\com{C''}$ (really a morphism $G\colon\car{c'}\to\car{c''}$ in $\cat{C}$).
\begin{enumerate}
    \item To show that the identity morphism $\id_\car{c}\colon\car{c}\to\car{c}$ is a comonoid morphism $\com{C}\to\com{C}$, we must check that it preserves erasure by showing that \eqref{eqn.pres_era} commutes, then check that it preserves duplication by showing that \eqref{eqn.pres_era} commutes:
    \[
    \begin{tikzcd}
        \car{c}\ar[r, "\id_\car{c}", equal]\ar[d, "\epsilon"']&
        \car{c}\ar[d, "\epsilon"]\\
        \yon\ar[r, equal]&
        \yon
    \end{tikzcd}
    \hspace{.5in}
    \begin{tikzcd}[column sep=large]
        \car{c}\ar[r, "\id_\car{c}", equal]\ar[d, "\delta"']&
        \car{c}\ar[d, "\delta"]\\
        \car{c}\tri\car{c}\ar[r, "\id_\car{c}\:\tri\:\id_\car{c}", equal]&
        \car{c}\tri\car{c}.
    \end{tikzcd}
    \]
    But they do commute, since $\id_\car{c}$ is the identity on $\car{c}$ and $\id_\car{c}\tri\id_\car{c}$ is the identity on $\car{c}\tri\car{c}$.
    
    \item To show that the composite $F\then G\colon\car{c}\to\car{c''}$ of the two comonoid morphisms $F$ and $G$ is itself a comonoid morphism $\com{C}\to\com{C''}$, we check that it preserves erasure by showing that \eqref{eqn.pres_era} commutes, then check that it preserves duplication by showing that \eqref{eqn.pres_era} commutes:
    \[
    \begin{tikzcd}
        \car{c}\ar[r, "F\:\then\:G"]\ar[d, "\epsilon"']&
        \car{c''}\ar[d, "\epsilon''"]\\
        \yon\ar[r, equal]&
        \yon
    \end{tikzcd}
    \hspace{.5in}
    \begin{tikzcd}[column sep=huge]
        \car{c}\ar[r, "F\:\then\:G"]\ar[d, "\delta"']&
        \car{c''}\ar[d, "\delta''"]\\
        \car{c}\tri\car{c}\ar[r, "(F\:\then\:G)\:\tri\:(F\:\then\:G)"]&
        \car{c''}\tri\car{c''}.
    \end{tikzcd}
    \]
    But we can rewrite these squares like so, using the fact that $(F\then G)\tri(F\then G)=(F\tri F)\then(G\tri G)$ on the right:
    \[
    \begin{tikzcd}
        \car{c}\ar[r, "F"]\ar[d, "\epsilon"']&
        \car{c}\ar[r, "G"]\ar[d, "\epsilon'"']&
        \car{c''}\ar[d, "\epsilon''"]\\
        \yon\ar[r, equal]&
        \yon\ar[r, equal]&
        \yon
    \end{tikzcd}
    \hspace{.5in}
    \begin{tikzcd}
        \car{c}\ar[r, "F"]\ar[d, "\delta"']&
        \car{c'}\ar[r, "G"]\ar[d, "\delta"']&
        \car{c''}\ar[d, "\delta'"]\\
        \car{c}\tri\car{c}\ar[r, "F\:\tri\:F"]&
        \car{c'}\tri\car{c'}\ar[r, "G\:\tri\:G"]&
        \car{c''}\tri\car{c''}.
    \end{tikzcd}
    \]
    Then the left square in each diagram commutes because $F$ is a comonoid morphism, while the right square in each diagram commutes because $G$ is a comonoid morphism.
    So both diagrams commute.
\end{enumerate}
\end{solution}
\end{exercise}

Notice that we were very careful in how we stated \cref{thm.ahman_uustalu}: while we asserted the existence of an isomorphism-preserving one-to-one correspondence between the objects of $\comon(\poly)$ and $\smcat$, we never claimed that these two categories are isomorphic or even equivalent.
The strange truth of the matter is that they are not: polynomial comonoid morphisms correspond not to functors, but to different maps of categories called \emph{cofunctors}.

How exactly do these maps behave?
If we specify \cref{def.morphism_comonoids} to the case of $(\poly,\yon,\tri)$, we can write the eraser preservation law \eqref{eqn.pres_era} in polyboxes as
\begin{equation}\label{eqn.pres_era_draw}
\begin{tikzpicture}
	\node (id1) {
	\begin{tikzpicture}[polybox, mapstos]
		\node[poly, dom, blue, "$\car{c}\vphantom{\car{c'}}$" above] (p) {\at$c$};
		\draw[blue,double,-] (p_pos) to[climb'] node[right] {$\idy$} (p_dir);
	\end{tikzpicture}	
	};
	\node[right=of id1] (id2) {
	\begin{tikzpicture}[polybox, mapstos]
		\node[poly, dom, blue, "$\car{c}$" above] (p) {\at$c$};
		\node[poly, red, right=1 of p, "$\car{c'}$" above] (q) {};
		\draw (p_pos) to[first] (q_pos);
		\draw (q_dir) to[last] (p_dir);
		\draw[red] (q_pos) to[climb'] node[right] {$\idy$} (q_dir);
		\node at ($(p.east)!.3!(q.west)$) {$F$};
	\end{tikzpicture}
	};
	\node at ($(id1.east)!.3!(id2.west)-(0,6pt)$) {$=$};
\end{tikzpicture}
\end{equation}
and the duplicator preservation law \eqref{eqn.pres_dup} in polyboxes as
\begin{equation}\label{eqn.pres_dup_draw}
\begin{tikzpicture}
	\node (sp1) {
	\begin{tikzpicture}[polybox, mapstos]
		\node[poly, dom, blue, "$\car{c}$" above] (c) {\at$c$};
		\node[poly, blue, right=2 of c.south, yshift=-1ex, "$\car{c}$" below] (c1) {};
		\node[poly, blue, above=of c1, "$\car{c}$" above] (c2) {};
		\node[poly, cod, red, right=1 of c1, "$\car{c'}$" below] (c'1) {$g$};
		\node[poly, cod, red, right=1 of c2, "$\car{c'}$" above] (c'2) {$h$};
		\node at ($(c1.east)!.5!(c'1.west)$) {$F$};
		\node at ($(c2.east)!.5!(c'2.west)$) {$F$};
	%
		\draw[blue,double,-] (c_pos) to[first] (c1_pos);
		\draw[blue] (c1_dir) to[climb] node[right] {$\cod$} (c2_pos);
		\draw[blue] (c2_dir) to[last] node[above] {$\then$} (c_dir);
		\draw (c1_pos) to[first] (c'1_pos);
		\draw (c'1_dir) to[last] (c1_dir);
		\draw (c2_pos) to[first] (c'2_pos);
		\draw (c'2_dir) to[last] (c2_dir);
    \end{tikzpicture}	
	};
	\node[right=of sp1] (sp2) {
	\begin{tikzpicture}[polybox, mapstos]
		\node[poly, dom, blue, "$\car{c}$" above] (c) {\at$c$};
		\node[poly, red, right=1 of c, "$\car{c'}$" above] (c') {};
		\node[poly, cod, red, right=2 of c'.south, yshift=-1ex, "$\car{c'}$" below] (c'1) {$g$};
		\node[poly, cod, red, above=of c'1, "$\car{c'}$" above] (c'2) {$h$};
		\node at ($(c.east)!.3!(c'.west)$) {$F$};
	%
		\draw (c_pos) to[first] (c'_pos);
		\draw (c'_dir) to[last] (c_dir);
		\draw[red,double,-] (c'_pos) to[first] (c'1_pos);
		\draw[red] (c'1_dir) to[climb] node[right] {$\cod$} (c'2_pos);
		\draw[red] (c'2_dir) to[last] node[above] {$\then$} (c'_dir);
	\end{tikzpicture}
	};
	\node at ($(sp1.east)!.5!(sp2.west)-(0,4pt)$) {$=$};
\end{tikzpicture}
\end{equation}
If we read off the equations from these polyboxes, interpreting polynomial comonoids as categories, we derive the following definition of a cofunctor.
(Here \eqref{eqn.pres_id} is equivalent to \eqref{eqn.pres_era_draw}, while \eqref{eqn.pres_cod} and \eqref{eqn.pres_comp} are together equivalent to \eqref{eqn.pres_dup_draw}.)

\begin{definition}[Cofunctor]\label{def.cofunctor}
Let $\cat{C}$ and $\cat{C'}$ be (small) categories.
A \emph{cofunctor} $F\colon\cat{C}\cof\cat{C'}$ consists of
\begin{itemize}
    \item a function $F\colon\Ob\cat{C}\to\Ob\cat{C'}$ \emph{forward on objects}\tablefootnote{In keeping with standard functor notation, we omit the usual subscript $\1$ that we include for on-positions (in this case, on-objects) functions. We often omit parentheses when applying these functions as well.} and
    \item a function $F^\sharp_c\colon\cat{C'}[Fc]\to\cat{C}[c]$ \emph{backward on morphisms} for each $c\in\Ob\cat{C}$,
\end{itemize}
satisfying the following conditions, collectively known as the \emph{cofunctor laws}:
\begin{enumerate}[itemsep=0pt, label=\roman*.]
	\item $F$ \emph{preserves identities}:
	\begin{equation} \label{eqn.pres_id}
	    F^\sharp_c\,\id_{Fc}=\id_c
	\end{equation}
	for each $c\in\Ob\cat{C}$;
	\item $F$ \emph{preserves codomains}:
	\begin{equation} \label{eqn.pres_cod}
	    F\cod F^\sharp_c g=\cod g
	\end{equation}
	for each $c\in\Ob\cat{C}$ and $g\in\cat{C'}[Fc]$;
	\item $F$ \emph{preserves composites}:%
	\tablefootnote{In particular, the codomains of either side of \eqref{eqn.pres_comp} are equal.
	This isn't actually guaranteed by the other laws, so it is worth noting on its own; see for example the proof of \cref{prop.cofunctors_isos}.}
	\begin{equation} \label{eqn.pres_comp}
	    F^\sharp_c g\then F^\sharp_{\cod F^\sharp_c g} h=F^\sharp_c\left(g\then h\right)
	\end{equation}
	for each $c\in\Ob\cat{C}, g\in\cat{C'}[Fc],$ and $h\in\cat{C'}[\cod g]$.
\end{enumerate}
We let $\smcat^\sharp\iso\comon(\poly)$ denote the category of (small) categories and cofunctors.
\end{definition}

Henceforth we will identify the category $\smcat^\sharp$ with the isomorphic category $\comon(\poly)$, eliding the difference between comonoids in $\poly$ and categories.

Since each cofunctor includes a lens between its carrier polynomials, cofunctors compose the way lenses do.

\begin{exercise}
Let $\cat{C},\cat{D},\cat{E}$ be categories, and let $F\colon\cat{C}\cof\cat{D}$ and $G\colon\cat{D}\cof\cat{E}$ be cofunctors between them.
\begin{enumerate}
    \item Characterize the behavior of the identity cofunctor $\id_\cat{D}$ on $\cat{D}$.
    Where does it send each object?
    Where does it send each morphism?
    \item Characterize the behavior of the composite cofunctor $F\then G$.
    Where does it send each object and morphism?\qedhere
\end{enumerate}
\begin{solution}
Here $F\colon\cat{C}\cof\cat{D}$ and $G\colon\cat{D}\cof\cat{E}$ are cofunctors in $\smcat^\sharp$.
\begin{enumerate}
    \item The identity cofunctor $\id_\cat{D}$ on $\cat{D}$ should correspond to the identity lens on the carrier of $\cat{D}$, which is the identity on both positions (objects) and directions (morphisms).
    So $\id_\cat{D}$ sends each object $d\in\Ob\cat{D}$ to itself, while $\left(\id_\cat{D}\right)^\sharp_d\colon\cat{D}[d]\to\cat{D}[d]$ sends each morphism out of $d$ to itself as well.
    \item The composite cofunctor $F\then G\colon\cat{C}\cof\cat{D}$ should correspond to the composite of $F$ as a lens between the carriers of $\cat{C}$ and $\cat{D}$ with $G$ as a lens between the carriers of $\cat{D}$ and $\cat{E}$.
    So on objects, $F\then G$ sends each $c\in\Ob\cat{C}$ to $G(Fc)\in\Ob\cat{E}$.
    Then given $c\in\Ob\cat{C}$, the on-morphisms function $(F\then G)^\sharp_c\colon\cat{E}[G(Fc)]\to\cat{C}[c]$ is the composite of on-directions functions
    \[
        \cat{E}[G(Fc)]\To{G^\sharp_{Fc}}\cat{D}[Fc]\To{F^\sharp_c}\cat{C}[c],
    \]
    sending each morphism $h$ with domain $G(Fc)$ to $F^\sharp_c\left(G^\sharp_{Fc}h\right)$.
\end{enumerate}
\end{solution}
\end{exercise}

On the surface, functors and cofunctors have much in common: both send objects to objects and morphisms to morphisms in a way that preserves domains and codomains as well as identities and composites.
The main difference is that functors send morphisms \emph{forward}, while cofunctors send morphisms \emph{backward}.
As we work with cofunctors, it will be helpful to remember the following:
\slogan{
    A cofunctor $F$ goes forward on objects and backward on morphisms.\\
    Codomains are objects, so $F$ preserves them going forward.\\
    Identities and composites are morphisms, so $F$ preserves them going backward.
}

Before we explore just how different functors and cofunctors can be, let us note a few more similarities that these two kinds of maps between categories share.
For example, cofunctors, like functors, preserve isomorphisms.

\begin{proposition}\label{prop.cofunctors_isos}
Let $F\colon\cat{C}\cof\cat{D}$ be a cofunctor, $c\in\cat{C}$ be an object, and $g\colon Fc\to\_$ be an isomorphism in $\cat{D}$.
Then $F^\sharp_c g$ is also an isomorphism in $\cat{C}$.
\end{proposition}
\begin{proof}
Let $c'\coloneqq\cod F^\sharp_c g$, so that $Fc'=\cod g$ by \eqref{eqn.pres_cod}, and let $g^{-1}\colon Fc'\to Fc$ be the inverse of $g$.
Then
\begin{align*}
	\id_c&=
	F^\sharp_c\,\id_{Fc} \tag*{\eqref{eqn.pres_id}}\\&=
	F^\sharp_c\left(g\then g^{-1}\right)\\&=
	F^\sharp_c g\then F^\sharp_{c'}\left(g^{-1}\right), \tag*{\eqref{eqn.pres_comp}}
\end{align*}
so in particular $c=\cod\id_c=\cod F^\sharp_{c'}\left(g^{-1}\right)$, and
\begin{align*}
	\id_{c'}&=
	F^\sharp_{c'}\,\id_{Fc'} \tag*{\eqref{eqn.pres_id}}\\&=
	F^\sharp_{c'}\left(g^{-1}\then g\right)\\&=
	F^\sharp_{c'}\left(g^{-1}\right)\then F^\sharp_{\cod F^\sharp_{c'}\left(g^{-1}\right)}g \tag*{\eqref{eqn.pres_comp}}\\&=
	F^\sharp_{c'}\left(g^{-1}\right)\then F^\sharp_c g.
\end{align*}
Hence $F^\sharp_c g$ and $F^\sharp_{c'}\left(g^{-1}\right)$ are inverses, and the result follows.
\end{proof}


Moreover, isomorphisms in $\smcat$ correspond to isomorphisms in $\smcat^\sharp$.

\begin{exercise}
We've justified the ``isomorphism-preserving'' part of \cref{thm.ahman_uustalu} implicitly, but let's make it explicit.

Recall that two categories $\cat{C}$ and $\cat{D}$ are isomorphic in $\smcat$ if there exist functors $F\colon\cat{C}\to\cat{D}$ and $G\colon\cat{D}\to\cat{C}$ that are mutually inverse, i.e.\ $F\then G$ and $G\then F$ are identity functors on $\cat{C}$ and $\cat{D}$.
Similarly, $\cat{C}$ and $\cat{D}$ are isomorphic in $\smcat^\sharp$ if there exist cofunctors $H\colon\cat{C}\cof\cat{D}$ and $K\colon\cat{D}\cof\cat{C}$ that are mutually inverse, i.e.\ $H\then K$ and $K\then H$ are identity cofunctors on $\cat{C}$ and $\cat{D}$.
Show that $\cat{C}$ and $\cat{D}$ are isomorphic in $\smcat$ if and only if they are isomorphic in $\smcat^\sharp$.
\begin{solution}
We want to show that categories $\cat{C}$ and $\cat{D}$ are isomorphic in $\smcat$ if and only if they are isomorphic in $\smcat^\sharp$.
First, assume that $\cat{C}$ and $\cat{D}$ are isomorphic in $\smcat$, so that there exist mutually inverse functors $F\colon\cat{C}\to\cat{D}$ and $G\colon\cat{D}\to\cat{C}$.
Then we can define a cofunctor $H\colon\cat{C}\cof\cat{D}$ such that for each $c\in\cat{C}$ we have $Hc\coloneqq Fc\in\cat{D}$, and for each $g\in\cat{D}[Fc]$ we have $H^\sharp_c g\coloneqq Gg\in\cat{C}[GFc]=\cat{C}[c]$.
We can verify that $H$ really is a cofunctor: it preserves identities and composition because $G$ does, and it preserves codomains because $H\cod H^\sharp_c g=F\cod Gg=FG\cod g=\cod g$.
Analogously, we can define a cofunctor $K\colon\cat{D}\cof\cat{C}$ with $Kd\coloneqq Gd$ and $K^\sharp_d f\coloneqq Ff$ for each $d\in\cat{D}$ and $f\in\cat{C}[Gd]$.
Then $H\then K$ is equal to $F\then G$ both on objects and on morphisms, so it is the identity cofunctor on $\cat{C}$; analogously, $K\then H$ is the identity cofunctor on $\cat{D}$.
Thus $\cat{C}$ and $\cat{D}$ are isomorphic in $\smcat^\sharp$.

Conversely, assume $\cat{C}$ and $\cat{D}$ are isomorphic in $\smcat^\sharp$, so that there exist mutually inverse cofunctors $H\colon\cat{C}\cof\cat{D}$ and $K\colon\cat{D}\cof\cat{C}$.
Given objects $c,c'$ and a morphism $f\colon c\to c'$ in $\cat{C}$, we have that $KHc=c$, so $K^\sharp_{Hc}$ is a function $\cat{C}[c]\to\cat{D}[Hc]$.
In particular, $K^\sharp_{Hc}f$ is a morphism in $\cat{D}$ whose domain is $Hc$ and whose codomain satisfies $K\cod K^\sharp_{Hc}f=\cod f=c'$, and thus $\cod K^\sharp_{Hc}f=Hc'$.
Hence we can define a functor $F\colon\cat{C}\to\cat{D}$ such that for each $c\in\cat{C}$ we have $Fc\coloneqq Hc\in\cat{D}$, and for each morphism $f\colon c\to c'$ in $\cat{C}$ we have $Ff\coloneqq K^\sharp_{Hc}f\colon Hc\to Hc'$.
Functoriality follows from the fact that $K$ preserves identities and composition.
Analogously, we can define a functor $G\colon\cat{D}\to\cat{C}$ with $Gd\coloneqq Kd$ for each $d\in\cat{D}$ and $Gg\coloneqq H^\sharp_{Kd}g$ for each $g\colon d\to d'$ in $\cat{D}$.
Then $F\then G$ is equal to $H\then K$ on objects; on morphisms, it sends each $f\colon c\to c'$ in $\cat{C}$ to $H^\sharp_{KHc}\left(K^\sharp_{Hc}f\right)=H^\sharp_c\left(K^\sharp_{Hc}f\right)=(K\then H)^\sharp_cf=f$ itself.
So $F\then G$ is the identity cofunctor on $\cat{C}$.
Analogously, $G\then F$ is the identity functor on $\cat{D}$.
Thus $\cat{C}$ and $\cat{D}$ are isomorphic in $\smcat$.
\end{solution}
\end{exercise}
But while isomorphisms in $\smcat^\sharp$ are the same as those in $\smcat$, the non-isomorphisms can be very different.
We'll see this in the examples to come.

%---- Subsection ----%
\subsection{Examples of cofunctors}

From a realm where functors reign supreme, the back-and-forth behavior of cofunctors can seem foreign and  counterintuitive.
Whereas a functor $\cat{C}\to\cat{D}$ can be thought of as a \emph{diagram}---a picture in the shape of $\cat{C}$, drawn with the objects and arrows of $\cat{D}$---cofunctors are much more like the dynamical systems of \cref{ch.poly.dyn_sys}.\footnote{In fact, we will see in \cref{ch.comon.cofree} that cofunctors generalize our dynamical systems.}

That is, a cofunctor $F\colon\cat{C}\cof\cat{D}$ is a way of interacting with the states (objects) and transitions (morphisms) within $\cat{C}$ by way of $\cat{D}$.
Imagine the cofunctor as a box, with $\cat{C}$ on the inside and $\cat{D}$ on the outside.
Some $c\in\cat{C}$ may be the current state inside the box, but all anyone outside the box can see is the object $Fc\in\cat{D}$ that the box chooses to display in lieu of $c$.
Still, any transition $g$ out of $Fc$ can be selected from the outside; the box guarantees that whatever $c$ is on the inside, there is a corresponding transition $F^\sharp_c g$ out of that $c$.
As $g$ is followed from $Fc$ to $\cod g$ on the outside, $F^\sharp_c g$ is followed from $c$ to $\cod F^\sharp_c g$ on the inside.
But codomain preservation guarantees that the new state $\cod g$ on the outside is equal to what the box would want to display in lieu of the new state $\cod F^\sharp_c g$ on the inside, as $\cod g=F\cod F^\sharp_c g$,
Then the process repeats in a manner compatible with identities and composition.

Here we give a variety of examples of cofunctors to get a better handle on them.
Often we will denote a category by its carrier when its comonoid structure can be inferred from context, and $\cat{C}$ will be a category throughout with carrier $\car{c}$.

\subsubsection{Cofunctors to preorders}

Given a cofunctor from $\cat{C}$ to a preorder $\cat{P}$, we can think of $\cat{P}$ as providing a simplified model or abstraction of the states and transitions possible in $\cat{C}$, picking canonical transitions in $\cat{C}$ along the way to exhibit the model.
While the transitions in a general category may be more complex, all that a preorder tells you is whether you can get from one state to another or not.
Let's see some examples.

\begin{example}[Cofunctors to discrete categories] \label{ex.cof_to_discrete}
The discrete category on a set $S$ is the category with objects in $S$ and only identity morphisms; its carrier is $S\yon$.
So a cofunctor $F\colon\cat C\cof S\yon$ is completely determined by its behavior on objects: to preserve identities, it can only send the morphisms in $S\yon$ back to the identity morphisms in $\cat C$.
We can identify $F$ with a function $\Ob\cat C\to S$, assigning each state in $\cat C$ a label in $S$ without revealing anything about the transitions between them.
\end{example}

\begin{exercise}
\begin{enumerate}
	\item Show that $\yon$ has a unique comonoid structure.
	\item Show that $\yon$ with its comonoid structure is terminal in $\smcat^\sharp$.
	\item Explain why $\yon$ is terminal using the language of states and transitions.
\qedhere
\end{enumerate}
\begin{solution}
\begin{enumerate}
    \item We actually already showed that $\yon$ has a unique comonoid structure, corresponding to the category with $1$ object and no nonidentity morphisms (which we will also denote by $\yon$), in \cref{exc.not_state_cat_but_same_carrier}, for the case of $S\coloneqq\1$.
    \item For any category $\cat{C}$, there is a unique cofunctor $\cat{C}\cof\yon$: it sends every object in $\cat{C}$ to the only object in $\yon$, and it sends the only morphism in $\yon$, an identity morphism, to each identity morphism in $\cat{C}$.
    \item By \cref{ex.cof_to_discrete}, a cofunctor from a category $\cat C$ to the discrete category on $S\in\smset$ is a way of assigning each state in $\cat C$ a label in $S$.
    In this case, $\yon$ is the discrete category on $\1$, so there is only $1$ label to choose from; hence there is always just $1$ way to assign the labels.
\end{enumerate}
\end{solution}
\end{exercise}

\begin{example}[Cofunctors to the walking arrow] \label{ex.cof_to_walking_arrow}
Consider a cofunctor $F\colon\cat{C}\cof\cat{A}$, where $\cat{A}$ is the walking arrow category
\begin{center}
    $\cat{A}\coloneqq\:$\boxCD{examplecolor}{
    $s\Too{a}t$}
\end{center}
from \cref{ex.walking_arrow_cat}.
On objects, $F$ is a function $\Ob\cat{C}\to\{s,t\}$, so each object of $\cat{C}$ lies in either $\cat{C}_s\coloneqq F^{-1}s$ or $\cat{C}_t\coloneqq F^{-1}t$ (but not both).
Then on morphisms, preservation of identities determines where $F^\sharp$ sends $\id_s$ and $\id_t$, while preservation of codomains ensures that for each $c\in\cat{C}_s$, the morphism $F^\sharp_c a\colon a\to\_$ that $F^\sharp$ sends $a$ back to must satisfy
\[
    F\cod F^\sharp_c a=\cod a=t
\]
and thus $\cod F^\sharp_c a\in\cat{C}_t$.
In particular, for every object $c\in\cat{C}$ that $F$ sends to $s$, there must be at least one morphism from $c$ to an object that $F$ sends to $t$, so that one of those morphisms can be $F^\sharp_c a$.
As there are no nontrivial composites in $\cat{A}$, the cofunctor $F$ automatically preserves composites.

In summary, a cofunctor $F\colon\cat{C}\cof\cat{A}$ divides the objects of $\cat{C}$ between $\cat{C}_s$ and $\cat{C}_t$ and fixes a morphism from each object in $\cat{C}_s$ to some object in $\cat{C}_t$.
We can think of $F$ as separating the states of $\cat{C}$ into source states and target states, modeled by the $s$ state and the $t$ state in $\cat{A}$, respectively; then every source state is assigned a target state and a way of getting to that target state via a transition in $\cat{C}$.
\end{example}

Given a cofunctor $F\colon\cat{C}\cof\cat{D}$ and an object $d\in\cat{D}$, we will continue to use the notation $\cat{C}_d\coloneqq F^{-1}d$ to denote the set of objects in $\cat{C}$ that $F$ sends to $d$.

\begin{exercise}
Let $F\colon\cat{C}\cof\cat{A}$ be a cofunctor from $\cat{C}$ to the walking arrow category $\cat{A}$, as in \cref{ex.cof_to_walking_arrow}.
If $Fc=s$ for all $c\in\cat{C}$, what can we say about $\cat{C}$?
\begin{solution}
Given a cofunctor $F\colon\cat{C}\cof\cat{A}$, where $\cat{A}$ is the walking arrow category as in \cref{ex.cof_to_walking_arrow}, assume $Fc=s$ for all $c\in\cat{C}$.
By \cref{ex.cof_to_walking_arrow}, if $Fc=s$ for $c\in\cat{C}$, then there must be a morphism from $c$ to an object in $\cat{C}$ that $F$ sends to $t$ for $a\colon s\to t$ in $\cat{A}$ to be sent back to via $F^\sharp$.
But there are no objects in $\cat{C}$ that $F$ sends to $t$.
So the only way such a cofunctor could be defined is if there are no objects in $\cat{C}$ that it sends to $s$, either: we conclude that $\cat{C}$ is the empty category.
\end{solution}
\end{exercise}

\begin{exercise}
\begin{enumerate}
	\item Recall the star-shaped category ${\yon}^{\ord{n}+\1}+\ord{n}\yon$ from \cref{ex.star_shaped}. Describe cofunctors to it.
	\item Describe cofunctors to the preorder $(\nn,\leq)$, viewed as a category: its objects are natural numbers, and there is a morphism $m\to n$ if and only if $m\leq n$.
	\item Describe cofunctors to the preorder $(\nn,\geq)$: its objects are natural numbers, and there is a morphism $n\to m$ if and only if $n\geq m$.
\qedhere
\end{enumerate}
\begin{solution}
The star-shaped category has $n+1$ objects, one of which is ``central'' in the sense that it maps uniquely to every object; the other objects have only identity maps.
\begin{enumerate}
    \item A cofunctor $\cat{C}\cof\yon^{\ord{n}+\1}+\ord{n}\yon$ comprises an assignment of a label to each object in $\cat{C}$: either it assigns ``center'' or it assigns an element of $\{1,2,\ldots,n\}$. If it assigns ``center'', the object is equipped with $n$-many morphisms, with the $i$th one having as its codomain an object labeled $i$. 
    \item A cofunctor $\cat{C}\to(\nn,\leq)$ comprises an assignment of a natural number label to each object in $\cat{C}$, as well as a choice of morphism in $\cat{C}$ from each object labeled $n$ to some object labeled $n+1$.
    \item A cofunctor $\cat{C}\to(\nn,\leq)$ comprises an assignment of a natural number label to each object in $\cat{C}$, as well as a choice of morphism in $\cat{C}$ from each object labeled $n+1$ to some object labeled $n$.
\end{enumerate}
\end{solution}
\end{exercise}

\begin{example}[Cofunctors to the walking commutative square] \label{ex.cof_to_comm_sq}
Consider a cofunctor $F\colon\cat{C}\cof\cat{C\!S}$, where $\cat{C\!S}$ is the \emph{walking commutative square category}
\begin{center}
    $\cat{C\!S}\coloneqq\:$\boxCD{examplecolor}{\[
    \begin{tikzcd}[ampersand replacement=\&]
        w\ar[d,"f"']\ar[r,"h"] \& y\ar[d,"k"] \\
        x\ar[r,"g"'] \& z
    \end{tikzcd}
    \]
    $f\then g=h\then k$}
\end{center}
On objects, $F$ is a function $\Ob\cat{C}\to\{w,x,y,z\}$, so each object of $\cat{C}$ lies in exactly one of $\cat{C}_w,\cat{C}_x,\cat{C}_y,$ and $\cat{C}_z$.
Then on morphisms, out of every object $X\in\cat{C}_x$ there is a morphism $F^\sharp_Xg\colon X\to\_$ to an object in $\cat{C}_z$, and out of every object $Y\in\cat{C}_y$ there is a morphism $F^\sharp_Yk\colon Y\to\_$ also to an object in $\cat{C}_z$.
Finally, out of every object $W\in\cat{C}_w$ there is a morphism $F^\sharp_Wf\colon W\to X_W$ to an object $X_W\in\cat{C}_x$ and a morphism $F^\sharp_Wh\colon W\to Y_W$ to an object in $Y_W\in\cat{C}_y$.
As $F$ preserves composites, these must all then satisfy
\[
    F^\sharp_Wf\then F^\sharp_{X_W}g=F^\sharp(f\then g)=F^\sharp(h\then k)=F^\sharp_Wh\then F^\sharp_{Y_W}k;
\]
in particular, $F^\sharp_{X_W}g$ and $F^\sharp_{Y_W}k$ must share a common codomain $Z_W\in\cat{C}_z$, yielding the following commutative square in $\cat{C}$:
\[
\begin{tikzcd}[ampersand replacement=\&]
    W\ar[d,"F^\sharp_Wf"']\ar[r,"F^\sharp_Wh"] \& Y_W\ar[d,"F^\sharp_{Y_W}k"] \\
    X_W\ar[r,"F^\sharp_{X_W}g"'] \& Z_W.
\end{tikzcd}
\]
\end{example}

\begin{exercise}
Let $\cat{A}$ denote the walking arrow category, as in \cref{ex.cof_to_walking_arrow}, and let $\cat{C\!S}$ denote the walking commutative square category, as in \cref{ex.cof_to_comm_sq}.
\begin{enumerate}
    \item List the cofunctors $\cat{C\!S}\cof\cat{A}$.
    \item List the cofunctors $\cat{A}\cof\cat{C\!S}$.\qedhere
\end{enumerate}
\begin{solution}
\begin{enumerate}
    \item Every object $c\in \cat{C\!S}$ in the commutative square must be labeled $s$ or $t$. If it's labeled $t$, there are no further requirements, since the only arrow emanating from $t$ is the identity. If it's labeled $s$ then we must choose an outgoing arrow $c\to ?$ where the label on $?$ is $t$. So the solutions are
\[
    \begin{tikzcd}[sep=5pt]
    	t&t\\
			t&t
    \end{tikzcd}
	\quad\;
   \begin{tikzcd}[sep=5pt]
    	s\ar[r]&t\\
			t&t
    \end{tikzcd}
	\quad\;
   \begin{tikzcd}[sep=5pt]
    	s\ar[d]&t\\
			t&t
    \end{tikzcd}
	\quad\;
   \begin{tikzcd}[sep=5pt]
    	s\ar[dr]&t\\
			t&t
    \end{tikzcd}
	\quad\;
   \begin{tikzcd}[sep=5pt]
    	s\ar[d]&s\ar[d]\\
			t&t
    \end{tikzcd}
	\quad\;
   \begin{tikzcd}[sep=5pt]
    	s\ar[dr]&s\ar[d]\\
			t&t
    \end{tikzcd}
	\quad\;
   \begin{tikzcd}[sep=5pt]
    	s\ar[r]&t\\
			s\ar[r]&t
    \end{tikzcd}
	\quad\;
   \begin{tikzcd}[sep=5pt]
    	s\ar[dr]&t\\
			s\ar[r]&t
    \end{tikzcd}
	\quad\;
   \begin{tikzcd}[sep=5pt]
    	s\ar[dr]&s\ar[d]\\
			s\ar[r]&t
    \end{tikzcd}
\]
    \item Each object in the walking arrow $\cat{A}$ must be labeled with an element of $\{w,x,y,z\}$. If it is labeled with $z$, there are no further requirements. If it is labeled with $x$ or $y$, it must have a map to an element labeled $z$; in particular this implies that it must be the source object. It cannot be labeled with $w$ because then it would need too many outgoing arrows. So the valid solutions are
 \[
    \begin{tikzcd}[sep=5pt]
    	z&z
    \end{tikzcd}   
	\qquad\;
    \begin{tikzcd}[sep=5pt]
    	x\ar[r]&z
    \end{tikzcd}   
	\qquad\;	
    \begin{tikzcd}[sep=5pt]
    	y\ar[r]&z
    \end{tikzcd}   
	\qquad\;
\]
\end{enumerate}
\end{solution}
\end{exercise}

\begin{exercise}
\begin{enumerate}
	\item What does a cofunctor from $\yon$ to a poset represent?
	\item Consider the chain poset $[n]\cong\sum_{i=0}^n\yon^{i+1}$.
	How many cofunctors are there from $[m]\to[n]$ for all $m\leq n$?
\qedhere
\end{enumerate}
\begin{solution}
\begin{enumerate}
    \item Let $\cat{P}$ be a poset. A cofunctor $\yon\cof\cat{P}$ represents an maximal element $p\in\cat{P}$. Indeed, if there were some $p\leq p'$ with $p'\neq p$, then the cofunctor would have to send the map $p\to p'$ to some morphism in $\yon$ whose codomain is sent to $p'$; this is impossible. But if $p$ is maximal, then there is no obstruction to sending the unique object of $\yon$ to $p$.
   \item Let $m=\fbox{$\bullet^0\to\cdots\to\bullet^{m-2}\to\bullet^{m-1}$}$. By the same reasoning as above, a map $[m]\to[n]$ must send the final object of $[m]$ to the final object of $[n]$. It can send the penultimate object $m-2$ to either the penultimate object $n-2$ or to the final object $n-1$ in $[n]$. Repeating in this way, we see that there $2^m$ many cofunctors. For example, the cofunctors $[2]\to[2]$ are those labeled by $(2,2,2)$, $(1,2,2)$, $(1,1,2)$, and $(0,1,2)$.
 \end{enumerate}
\end{solution}
\end{exercise}

\subsubsection{Cofunctors to monoids}

When a monoid $(M,e,*)$, viewed as a $1$-object category $\yon^M$, is the codomain of a cofunctor $\cat{C}\cof\yon^M$, it plays the role of a joystick: an ``input device'' that ``reports its\dots direction to the device it is controlling.''%
\footnote{Description from Wikipedia.} % https://en.wikipedia.org/wiki/Joystick
Like a joystick, $\yon^M$ stays in one ``place''---a single state---but has a number of directions it can take that are reported back to $\cat{C}$, controlling the way it moves through its transitions.
As we string together a sequence of directions in $M$, we chart a course through the transitions of $\cat C$.
We make this analogy concrete in the following examples.

\begin{example}[Arrow fields]\label{ex.arrow_field}
Consider the monoid $(\nn,0,+)$ viewed as a category $\yon^\nn$.
Cofunctors $\cat{C}\cof\yon^\nn$ have been called \emph{admissible sections} \cite{aguiar1997internal}.
We prefer to call them \emph{arrow fields} (on $\cat{C}$), for they turn out to resemble vector fields---but with arrows in $\cat{C}$ instead of vectors.%
\tablefootnote{After all, a vector field is a section of a vector bundle.
Our arrow fields will be sections of $\cat{C}$'s carrier, viewed as a bundle of directions over positions.}
We'll have more to say about these in \cref{thm.catsharp_to_mon}, but our goal here is simply to unpack the definition.

To specify a cofunctor $A\colon\cat{C}\cof\yon^\nn$, we first say what it does on objects, but this is already decided: there is only one object in $\yon^\nn$, so every object of $\cat{C}$ is sent to it.
This also means that codomains are automatically preserved.
So as will be the case for all cofunctors to monoids, $A$ is characterized by its behavior on morphisms: for each object $c\in\cat{C}$, the cofunctor assigns each $n\in\nn$ a morphism $A^\sharp_c n$ of $\cat{C}$ emanating from $c$.
That's a lot of data, but we still have two cofunctor laws to pare it down:
\[
    A^\sharp_c0=\id_c
        \qqand
    A^\sharp_c(m+n)=A^\sharp_c m\then A^\sharp_{\cod A^\sharp_c m}n.
\]
Then for each $c\in\cat{C}$, since every $n\in\nn$ is a sum of 1's, the morphism $A^\sharp_i n$ can be decomposed into $n$ copies of $A^\sharp_{c_j}1$ for objects $c_0\coloneqq c,c_1,\ldots,c_n\in\cat{C}$, as follows:
\begin{equation} \label{eqn.arrow_field_composite}
    c=c_0\To{A^\sharp_{c_0}1}c_1\To{A^\sharp_{c_1}1}\cdots\To{A^\sharp_{c_{n-1}}1}c_n.
\end{equation}
Here each $c_{j+1}\coloneqq\cod A^\sharp_{c_j}1$.

Thus an arrow field of $\cat{C}$ is given by independently choosing a morphism emanting from each $c\in\cat{C}$ to be $A^\sharp_i1$: an arrow (morphism) out of each object, like how a vector field has a vector out of each point.
Indeed, any such choice uniquely determines the cofunctor $A\colon\cat{C}\cof\yon^\nn$: as every object is assigned an arrow coming out of it, we can follow the arrow out of $c$ to an object $c_1$, then following the arrow out of $c_1$ to an object $c_2$, and so on until we have followed the $n$ arrows in \eqref{eqn.arrow_field_composite}, which then compose to yield $A^\sharp_cn$.
With our joystick analogy, a single flick sends us from a state $c\in\cat{C}$ along its assigned arrow $A^\sharp_c1$, while $n$ flicks send us through $n$ arrows along the arrow field.

Here is an example of an arrow field on the product of preorders $(\nn,\leq)\times(\nn,\leq)$:
\[
\begin{tikzpicture}[shorten <=4pt, shorten >=4pt, tips=proper]
	\foreach \i in {0,1,2,3} 
	{
		\foreach \j in {0,1,2}
		{
			\node (\i\j) at (\i,\j) {$\bullet$};
			\draw[->] (\i,\j) -- (\i+1,\j);
			\draw[->] (\i,\j) -- (\i,\j+1);
		};
	};
	\begin{scope}[blue, thick]
		\draw[->] (0,0) -- (0,1);
		\draw[->] (0,1) -- (1,3);
		\draw[->] (0,2) -- (1,2);
		\draw[->] (1,0) -- (2,1);
		\draw[->] (1,1) edge[in=75, out=15, distance=10mm] (1,1);
		\draw[->] (1,2) -- (3,3);
		\draw[->] (2,0) to[bend right] (2,2);
		\draw[->] (2,1) -- (2,2);
		\draw[->] (2,2) -- (3,2);
		\draw[->] (3,0) -- (3,1);
		\draw[->] (3,1) -- (3,2);
		\draw[->] (3,2) edge[in=75, out=15, distance=10mm] (3,2);
	\end{scope}
\end{tikzpicture}
\]
Every object has been assigned an emanating morphism drawn in blue, but there need not be any rhyme or reason to our choice.
\end{example}

\begin{exercise}
How many arrow fields on the category \fbox{$\bullet\to\bullet$} are there?
\begin{solution}
We seek the number of arrow fields on the category \fbox{$\bullet\to\bullet$}.
There are $2$ choices of morphisms emanating from the object on the left, and $1$ choice of morphism emanating from the object on the right, for a total of $2 \cdot 1 = 2$ arrow fields.
\end{solution}
\end{exercise}

% Show that arrow fields can be composed
% maybe just bring all the arrow field stuff up here!

We will see later in \cref{prop.traj_mon_poly} that the arrow fields on a category form a monoid, and that this operation $\smcat^\sharp\to\Cat{Mon}\op$ is functorial and in fact an adjoint.

\begin{exercise}
Consider the monoid of integers $(\zz,0,+)$ as a $1$-object category $\yon^\zz$, and let $\yon^\nn$ be the monoid of natural numbers $(\nn,0,+)$ viewed as a $1$-object category as above.
\begin{enumerate}
	\item Describe the data of a cofunctor $\cat{C}\cof\yon^\zz$.
	\item What would you say is the canonical cofunctor $\yon^\zz\cof\yon^\nn$?
\qedhere
\end{enumerate}
\begin{solution}
\begin{enumerate}
    \item A cofunctor $\cat{C}\cof\yon^\zz$ assigns to each object $c\in\cat{C}$ and integer $n\in\zz$ an emanating arrow $c.n\in\cat{C}$ to some other object, with the property that $c.0=c$ and $c.n.n'=c.(n+n')$. But this is overkill. Indeed, it is enough to assign the $c.1$ arrow and to check that for every object $c'$ there exists a unique object $c$ with $\cod(c.1)=c'$.
    \item We seek a canonical cofunctor $\yon^\zz\cof\yon^\nn$.
    The canonical inclusion $i\colon\nn\inj\zz$ gives rise to a lens $\iota$ from $\yon^\zz$ to $\yon^\nn$, whose sole on-directions function $\iota^\sharp\colon\nn\inj\zz$ coincides with $i$. 
    We verify that $\iota$ is a cofunctor: it preserves identities, as $\iota^\sharp0=0$; it automatically preserves codomains; and it preserves composites, given by addition in either monoid, as $\iota^\sharp(m+n)=m+n=\iota^\sharp(m)+\iota^\sharp(n)$.
\end{enumerate}
\end{solution}
\end{exercise}

\begin{exercise}
\begin{enumerate}
	\item Suppose that $M,N$ are monoids (each is a category with one object).
	Are cofunctors between them related to monoid homomorphisms? If so, how?
	\item Suppose $\cat{C}$ and $\cat{D}$ are categories and $F\colon\cat{C}\cof\cat{D}$ is a cofunctor.
	Does there necessarily exist a cofunctor $\cat{C}\op\cof\cat{D}\op$ that acts the same as $F$ on objects?
\qedhere
\end{enumerate}
\begin{solution}
\begin{enumerate}
    \item Cofunctors $\yon^M\to\yon^N$ are the same as monoid homomorphisms $N\to M$. See \cref{prop.monoids_ff}.
    \item No! This is the weirdest thing about cofunctors. For example, there is a unique cofunctor $\yon\to\yon^\2+\yon$ from the walking object to the walking arrow, so if we reverse the arrows, there is no longer a cofunctor that acts the same on objects.
\end{enumerate}
\end{solution}
\end{exercise}




%** displaced content here
\begin{exercise}[Monoid actions]\label{exc.monoid_action}
Recall from \cref{ex.monoid_action} that every monoid action $\alpha\colon S\times M\to S$, where $S$ is a set and $(M,e,*)$ is a monoid, gives rise to a category carried by $S\yon^M$.
Show that the projection $S\yon^M\to\yon^M$ is a cofunctor.
\begin{solution}
We are given a monoid $(M,e,*)$, a set $S$, and an $M$-action $\alpha\colon M\times S\to S$. The category $S\yon^M$ has $e$ as the identity on each $s\in S$; the codomain of the map labeled $m$ emanating from $s$ is $\alpha(s,m)$, and composition is given by $*$. The projection $S\yon^M\to\yon^M$ sends the identity back to the identity, trivially preserves codomains, and also preserves composition, so it is a cofunctor.
\end{solution}
\end{exercise}



\begin{example}\label{ex.BGEG}
Let $(G,e,*)$ be a group and $(\yon^G,\epsilon,\delta)$ the corresponding comonoid. There is a cofunctor $G\yon^G\cof\yon^G$ given by
\[
\begin{tikzpicture}[polybox, mapstos]
	\node[poly, dom] (p) {$g_1*g_2$\at$g_1$};
	\node[poly, pure cod, right=of p] (q) {$g_2$\at\vphantom{$g_1$}};
	\draw (p_pos) to[first] (q_pos);
	\draw (q_dir) to[last] (p_dir);
\end{tikzpicture}
\]
To see this is a cofunctor, we check that identities, codomains, and compositions are preserved. For any $g_1$, the identity $e$ is passed back to $g_1*e=g_1$, and this is the identity on $g_1$ in $G\yon^G$. Codomains are preserved because there is only one object in $\yon^G$. Composites are preserved because for any $g_2,g_3$, we have $g_1*(g_2*g_3)=(g_1*g_2)*g_3$.
\end{example}

\begin{exercise}\label{exc.BGEG}
Does the idea of \cref{ex.BGEG} work when $G$ is merely a monoid, or does something go subtly wrong somehow?
\begin{solution}
This works! 
\end{solution}
\end{exercise}

\begin{proposition}\label{prop.monoids_ff}
There is a fully faithful functor $\Cat{Mon}\op\to\smcat^\sharp$, whose image consists of all categories whose carriers are representable.
\end{proposition}
\begin{proof}
Given a monoid $(M,e,*)$, we think of it as a category with one object; its carrier $\yon^M$ is representable. A cofunctor between such categories carries no data in its on-objects part, and codomains are automatically preserved. Cofunctors $\yon^M\to\yon^N$ simply carry elements of $N$ to elements of $M$, preserving identity and composition, exactly the description of monoid homomorphisms.
\end{proof}

\begin{proposition}
There is an adjunction
\[
\smcat^\sharp(\cat{C},A\yon)\cong\smset(\Ob\cat{C},A)
\]
for $\cat{C}\in\smcat^\sharp$ and $A\in\smset$.
\end{proposition}
\begin{proof}
In the solution to \cref{exc.linear_poly_cat}, we saw that a category is discrete iff its carrier is a linear polynomial: this occurs when the only arrow emanating from each object is its identity. Thus $A\yon$ corresponds to a discrete category. A cofunctor from any category to a discrete category needs to say what happens on objects, but the rest of the data is determined because identities need to be sent back to identities. This is the content of the proposition.
\end{proof}

\begin{exercise}[Continuous arrow fields]
Suppose we say that a \emph{continuous arrow field} on $\cat{C}$ is a cofunctor $\cat{C}\cof\yon^\rr$, viewing $\yon^\rr$ as the monoid of real numbers with addition.

Describe continuous arrow fields in $\cat{C}$ using elementary terms, i.e.\ to someone who doesn't know what a cofunctor is and isn't yet ready to learn.
\begin{solution}
A continuous arrow field on $\cat{C}$ assigns to each object $c\in\cat{C}$ and each real number $r\in\rr$ a morphism $c.r$ emanating from $c$. These have the property that $c.0$ is the identity on $c$ and that $(c.r).r'=c.(r+r')$. In other words, you can evolve $c$ forward or backward in time by any $r\in\rr$, and this works as expected.
\end{solution}
\end{exercise}

\begin{example}[Systems of ODEs]
A system of ordinary differential equations (ODEs) in $n$ variables, e.g.
\begin{align*}
    \dot{x}_1 &= f_1(x_1, \ldots, x_n) \\
    \dot{x}_2 &= f_2(x_1, \ldots, x_n) \\
    & \; \; \; \vdots \\
    \dot{x}_n &= f_n(x_1, \ldots, x_n),
\end{align*}
can be understood as a vector field on $\rr^n$.
We are often interested in integrating this vector field to get flow lines, or integral curves.
In other words, for each $x=(x_1, \ldots, x_n)\in\rr^n$, viewed as a point, and each $t\in\rr$, viewed as a quantity of time, we can begin at $x$ and move along the vector field for time $t$, arriving at a new point $x^{+t}$. These satisfy the equations
\begin{equation} \label{eqn.cofunctor_ode}
    x^{+0} = x \qqand x^{+t_1+t_2} = (x^{+t_1})^{+t_2}. 
\end{equation}
Let's call such things \emph{differentiable dynamical systems} with time domain $(T, 0, +)$; above, we used $T\coloneqq\rr$, but any monoid will do.

Dynamical systems in the above sense are cofunctors $F \colon \rr^n \yon^{\rr^n} \cof \yon^T$.
In order to say this, we first need to say how both $\cat{C} := \rr^n \yon^{\rr^n}$ and $\yon^T$ are being considered as categories.
The category $\cat{C}$ has objects $\rr^n$, and for each object $x \in \rr^n$ and outgoing arrow $v \in \rr^n$, the codomain of $v$ is $x + v$; in other words, $v$ is a vector emanating from $x$.
The identity is $v = 0$, and composition is given by addition.
The category $\yon^T$ is the monoid $T$ considered as a category with one object, $\bullet$.

The cofunctor assigns to every object $x \in \rr^n$ the unique object $F(x) = \bullet$, and to each element $t \in T$ the morphism $F^\sharp(x, t) = x^{+t} - x \in \rr^n$, which can be interpreted as a vector emanating from $x$.
Its codomain is $\cod F^\sharp(x, t) = x^{+t}$, and we will see that \eqref{eqn.cofunctor_ode} ensures the cofunctoriality properties.

The codomain law ii is vacuously true, since $\yon^T$ only has one object.
Law i follows because $F^\sharp(x, 0) = x^{+0} - x = 0$, and law iii follows as
\[
    F^\sharp(x^{+t_1}, t_2) + F^\sharp(x, t_1) = (x^{+t_1})^{+t_2} - x^{+t_1} + x^{+t_1} - x = x^{+t_1 + t_2} - x = F^\sharp(x, t_1+t_2).
\]
\end{example}

\subsubsection{Cofunctors from state categories}

By now we should be very familiar with lenses from state categories, which are our original dynamical systems.
A cofunctor from a state category, then, is just a dynamical system that satisfies the cofunctor laws.
It turns out that cofunctors from state categories are particularly noteworthy: just as a polynomial comonoid $\cat{C}$ can be identified with a category, a cofunctor out of $\cat{C}$ can be identified with a number of equivalent categorical constructions on $\cat{C}$, perhaps the most familiar being a functor $\cat{C}\to\smset$.
But these equivalences deserve their own subsection to examine in full; we'll defer them to \cref{sec.comon.sharp.cof.from_state}.
For now, let's look at some examples of cofunctors out of state categories.

\begin{example}[Cofunctors from state categories to $\cat{C}$ are $\cat{C}$-coalgebras]

Recall from \cref{ex.coalgebras} that for a set $S$, lenses $S\yon^S\to p$ correspond to functions $S\to p(S)$ known as coalgebras for the functor $p$.
As a cofunctor $S\yon^S\cof\cat{C}$ is just a special kind of lens from $S\yon^S$ to $\car{c}$, the carrier of $\cat{C}$, it should correspond to a special kind of coalgebra $S\to\car{c}(S)$ for the functor $\car{c}$. 


% that plays nicely with the comonoid structure of $\cat{C}$, the function $S\to\car{c}(S)$ that plays nicely with the comonoid structure carried by $\car{c}$.


Taking $A=B=S\in\smset$ in \eqref{eqn.monomials_and_comp}, we find that there is a natural isomorphism between dynamical systems $S\yon^S\to p$ and functions $S\to p(S)$, also known as a \emph{coalgebra for the functor} $p$ or a $p$\emph{-coalgebra}.\tablefootnote{There are two versions of coalgebras we are interested in (and more that we are not) with distinct definitions: a \emph{coalgebra for a functor}, which is the version used here, and a \emph{coalgebra for a comonad}, which is a coalgebra for a functor with extra conditions that we will introduce later.}
\end{example}


\begin{example}[Cofunctors between state categories are very well-behaved lenses] \label{ex.very_well_behaved_lenses}
Our familiar state category on $S$ from \cref{ex.state_cat} is the category with objects in $S$ and exactly $1$ morphism between every pair of objects; when we label each morphism with its codomain, its carrier is $S\yon^S$, the identity of $s\in S$ is $s$, and (disregarding domains) $s\then s'=s'$ for composable $s,s'\in S$.

Then a cofunctor $S\yon^S\cof T\yon^T$ between two state categories corresponds to what is known to functional programmers as a \emph{very well-behaved lens}.
We actually defined this way back in \cref{ex.lens_get_put}, where we called the on-objects (on-positions) function of such a cofunctor $\lensget\colon S\to T$, and the on-morphisms (on-directions) function $\lensput\colon S\times T\to S$.%
\tablefootnote{More precisely, we are treating the on-morphism functions $T\to S$ for each $s\in S$ of a cofunctor $S\yon^S\cof T\yon^T$ as a single function $S\times T\to S$.}
Then the cofunctor laws are as follows:
\begin{enumerate}
    \item Preservation of identities \eqref{eqn.pres_id} becomes
    \[
        \lensput(s,\lensget(s))=s,
    \]
    for all $s\in S$, known as the \emph{get-put law} (named in diagrammatic order: we apply $\lensget$ before we apply $\lensput$).
    
    \item Preservation of codomains \eqref{eqn.pres_cod} becomes
    \[
        \lensget(\lensput(s,t))=t,
    \]
    for all $s\in S$ and $t\in T$, known as the \emph{put-get law}.
    
    \item Preservation of composition becomes
    \[
        \lensput(\lensput(s,t),t')=\lensput(s,t')
    \]
    for all $s\in S$ and $t,t'\in T$, known as the \emph{put-put law}.
\end{enumerate}

In fact, it turns out that these laws can be satisfied if and only if $\lensget$ is a product projection! 
For example, if the cardinalities $|S|$ and $|T|$ of $S$ and $T$ are finite and $|S|$ is not divisible by $|T|$, then there are no cofunctors $S\yon^S\cof T\yon^T$.
A stringent condition, no?
We'll explore it in  \cref{exc.how_many_vwbls} below.

Let's explore why cofunctors between state categories are just product projections.
A product projection $A\times B\to A$ always has a second factor $B$; if every cofunctor between state categories is a product projection, what is the second factor?
It turns out to be
\[
    U\coloneqq\{u\colon T\to S\mid \forall t,t'\in T,\;\lensget(u(t))=t\text{ and }\lensput(u(t),t')=u(t')\}.
\]
In other words, we will show that if $(\lensget,\lensput)$ defines a cofunctor $S\yon^S\cof T\yon^T$, then there is a bijection $S\iso T\times U$ making $\lensget\colon S\to T$ a product projection.
We then prove the converse in \cref{exc.well_behaved_boring}.

Assume $(\lensget,\lensput)\colon S\yon^S\cof T\yon^T$ is a cofunctor, so that it satisfies the enumerated laws.
First, we define a function $\alpha\colon S\to T\times U$ as follows.
Given $s\in S$, the function $u_s\colon T\to S$ defined by
\[
    u_s(t)=\lensput(s,t)
\]
lies in $U$: we check that it satisfies
\[
    \lensget(u_s(t))=\lensget(\lensput(s,t))=t
\]
by the put-get law for $t\in T$ and
\[
    \lensput(u_s(t),t')=\lensput(\lensput(s,t),t')=\lensput(s,t')=u_s(t')
\]
by the put-put law for $t,t'\in T$.
We can therefore define a function $\alpha\colon S\to T\times U$ by
\[
    \alpha(s)=\left(\lensget(s),u_s\right).
\]
In the other direction, we have a function $\beta\colon T\times U\to S$ given by
\[
    \beta(t,u)=u(t).
\]
The two functions $\alpha$ and $\beta$ are mutually inverse: $\alpha\then\beta\colon S\to S$ is the identity because
\[
    \beta(\alpha(s))=u_s(\lensget(s))=\lensput(s,\lensget(s))=s
\]
by the get-put law, while $\beta\then\alpha\colon T\times U\to T\times U$ is the identity because
\[
    \alpha(\beta(t,u))=\left(\lensget(u(t)),u_{u(t)}\right)=(t,t'\mapsto\lensput(u(t),t'))=(t,u),
\]
as $\lensget(u(t))=t$ and $\lensput(u(t),t')=u(t')$ by construction for $u\in U$.
Thus $S\iso T\times U$, and the product projection $S\To\alpha T\times U\to T$ sends $s\mapsto\lensget(s)$, as desired.

We have therefore shown that for every cofunctor $S\yon^S\cof T\yon^T$, there exists a set $U$ for which $S\iso T\times U$ and the on-positions function $\lensget$ is the product projection $S\iso T\times U\to T$.
Notice that the on-directions function $\lensput$ can be uniquely recovered from the bijection $S\iso T\times U$ we constructed: it is determined by the functions $u_s\colon T\to S$ for $s\in S$, which in turn is determined by the second projection $T\times U\to U$.

More precisely, composing $\alpha\colon S\to T\times U$ with the projection to $U$ yields a map $S\to U$ sending $s\mapsto u_s$; then $\lensput(s,t)$ is given by $u_s(t)$.
Of course, a priori $U$ could just be a set---we may not know how to interpret its elements as a functions $T\to S$.
This is where $\beta\colon T\times U\to S$ comes in: we know $\beta(t,u_s)=u_s(t)$.
So $\lensput(s,t)$ must be $\beta(t,u_s)$.
\end{example}

\begin{exercise}\label{exc.well_behaved_boring}
Let $S,T,U$ be sets for which we have a bijection $S\iso T\times U$.
Show that there exists a unique cofunctor $S\yon^S\cof T\yon^T$ whose on-positions function $S\iso T\times U\to T$ is given by the product projection.
\begin{solution}
Given a bijection of sets $S\iso T\times U$, we seek a unique cofunctor $S\yon^S\cof T\yon^T$ whose on-positions function $\lensget$ is given by the product projection $S\iso T\times U\to T$.
Such a cofunctor should also have an on-directions function $\lensput\colon S\times T\to S$ such that the three laws from \cref{ex.very_well_behaved_lenses} are satisfied.
With $S\iso T\times U$, such a function is uniquely determined by its components
\[
    S\times T\To\lensput S\To\lensget T \qqand S\times T\To\lensput S\To\pi U,
\]
where $\pi\colon S\iso T\times U\to U$ is the other product projection.
The left component is determined by the put-get law, which specifies the behavior of the composite $\lensput\then\lensget$: it should send $(s,t)\mapsto t$.
Identifying $S$ with $T\times U$, the get-put law for $s=(t,u)\in T\times U$ (so $\lensget(t,u)=t$) reads as
\[
    \lensput((t,u),t)=(t,u),
\]
while the put-put law reads as
\[
    \lensput(\lensput((t,u),t'),t'')=\lensput((t,u),t'')
\]
for $t',t''\in T$.
Applying $\lensget$ to both sides, we observe that the first coordinate (in $T$) of either side of each equation are automatically equal when the put-get law holds.
So we are really only concerned with the second coordinates of either side (in $U$); applying $\pi$ to both sides yields
\[
    \pi(\lensput((t,u),t))=u \qqand \pi(\lensput(\lensput((t,u),t'),t''))=\pi(\lensput((t,u),t''))
\]
\end{solution}
\end{exercise}

\begin{exercise}\label{exc.how_many_vwbls}
\begin{enumerate}
	\item Suppose $|S|=3$. How many cofunctors are there $S\yon^S\to S\yon^S$?
	\item Suppose $|S|=4$ and $|T|=2$. How many cofunctors are there $S\yon^S\cof T\yon^T$?
\qedhere
\end{enumerate}
\begin{solution}
\begin{enumerate}
    \item There are 6 product projections $\3\to \3$, namely the three automorphisms, so the answer is 6.
    \item There are 6 product projections $\4\to\2$, so the answer is 6.
\end{enumerate}
\end{solution}
\end{exercise}

\begin{example}
We have a state category $\car{c}(\1)\yon^{\car{c}(\1)}$ on the set of objects of $\cat{C}$.
Define a lens $\car{c}(\1)\yon^{\car{c}(\1)}\to\car{c}$ by
\[
\begin{tikzpicture}[polybox, mapstos]
	\node[poly, dom, "$\car{c}(\1)\yon^{\car{c}(\1)}$" below] (s) {$\cod f$\at$i$};
	    \node[left=0pt of s_pos] {$\Ob\cat{C}$};
        \node[left=0pt of s_dir] {$\Ob\cat{C}$};

	\node[poly, cod, right=of s, "$\car{c}$" below] (c) {$f\vphantom{d}$\at$i$};
	    \node[right=0pt of c_pos] {$\Ob\cat{C}$};
        \node[right=0pt of c_dir] {$\cat{C}[-]$};
	
	\draw[double, -] (s_pos) -- (c_pos);
	\draw (c_dir) -- node[above] {$\cod$} (s_dir); 
\end{tikzpicture}
\]
sending each object $i\in\cat{C}$ to itself on positions and, at $i$, sending each morphism $f\colon i\to\_$ to its codomain $\cod f$ on directions.

This lens is a cofunctor $\car{c}(\1)\yon^{\car{c}(\1)}\cof\cat{C}$ because it sends identities back to identities, codomains forward to codomains, and preserves composition (trivially, since each morphism in $c(\1)\yon^{c(\1)}$ is determined by its domain and codomain.
\end{example}

\begin{exercise}
Fix an object $i\in\car{c}(\1)=\Ob\cat{C}$.
Then we have a state category $\car{c}[i]\yon^{\car{c}[i]}$ on the set $\car{c}[i]=\cat{C}[i]$ of morphisms out of $i$ in $\cat{C}$.
Define a lens $\car{c}[i]\yon^{\car{c}[i]}\to\car{c}$ by
\[
\begin{tikzpicture}[polybox, mapstos]
	\node[poly, dom, "{$\car{c}[i]\yon^{\car{c}[i]}$}" below] (s) {$f\then g$\at$f$};
        \node[left=0pt of s_pos] {$\cat{C}[i]$};
        \node[left=0pt of s_dir] {$\cat{C}[i]$};

	\node[poly, cod, right=of s, "$\car{c}$" below] (c) {$g$\at$\cod f$};
	    \node[right=0pt of c_pos] {$\Ob\cat{C}$};
        \node[right=0pt of c_dir] {$\cat{C}[-]$};

	\draw (s_pos) -- node[below] {$\cod$} (c_pos);
	\draw (c_dir) -- node[above] {$\then$} (s_dir);
\end{tikzpicture}
\]
sending each morphism $f\colon i\to\_$ to its codomain on positions and, at $f$, sending each morphism $g\colon\cod f\to\_$ to the composite $f\then g\colon i\to\_$ on directions.
Is this lens a cofunctor $\car{c}[i]\yon^{\car{c}[i]}\cof\cat{C}$?
\begin{solution}
Yes, it is a cofunctor. One sees easily that it sends identities back to identities and composites back to composites. The codomain of $f\then g$ is simply $f\then g$ as an element of $\car{c}[i]$, and it is sent forward to $\cod(f\then g)$, so the map preserves codomains. 
\end{solution}
\end{exercise}

We'll revisit cofunctors from state categories in \cref{sec.comon.sharp.cof.from_state}.

\subsubsection{Other cofunctors}

\begin{example}[Objects aren't representable in $\smcat^\sharp$]\label{ex.rep_objects}
In the world of categories and the usual functors between them, the terminal category $\cat{T}\coloneqq\fbox{$\bullet$}$ with one object and one morphism \emph{represents objects}, in the sense that functors $\cat{T}\to\cat{C}$ naturally correspond to objects in $\cat{C}$.

Unfortunately, the same cannot be said for cofunctors: we'll see in \cref{exc.rep_objects} that there does not exist a fixed category $\cat{U}$ for which cofunctors $\cat{U}\cof\cat{C}$ are in bijection with objects in $\cat{C}$ for every category $\cat{C}$.

Cofunctors $\cat{T}\cof\cat{C}$ are somewhat strange beasts: because they must preserve codomains, they can be identified with objects $c\in\cat{C}$ for which the codomain of every emanating morphism $c\to c'$ is $c'=c$ itself. 
\end{example}

\begin{exercise}\label{exc.rep_objects}
We saw in \cref{exc.linear_poly_comon} that $\2\yon$ has a unique comonoid structure.
\begin{enumerate}
	\item Show that for any category $\cat{U}$, cofunctors $\cat{U}\cof\2\yon$ are in bijection with the set $\2^{\Ob\cat{U}}$.
	\item Use the case of $\cat{C}\coloneqq\2\yon$ to show that if cofunctors $\cat{U}\cof\cat{C}$ are always in bijection with objects in $\cat{C}$, then $\cat{U}$ must have exactly one object.
	\item Now use a different category $\cat{D}$ to show that if cofunctors $\cat{U}\cof\cat{D}$ are in bijection with objects in $\cat{D}$, then $\cat{U}$ must have more than one object.
	Conclude that objects are not reprsentable in $\smcat^\sharp$ the way they are in $\smcat$.
	\item Is there a fixed category $\cat{V}$ for which cofunctors $\cat{E}\cof\cat{V}$ are in bijection with objects in $\cat{E}$ for every category $\cat{E}$?
	If there is, find it; if there isn't, prove there isn't.
\qedhere
\end{enumerate}
\begin{solution}
\begin{enumerate}
    \item Every object in $\cat{U}$ must be labeled with either 1 or 2, but there are no other requirements.
    \item If cofunctors $\cat{U}\to\cat{C}$ are always in bijection with objects in $\cat{C}$, then with $\cat{C}=\2\yon$, we have a bijection $\2\cong\2^{\Ob(\cat{U})}$ by part 1, so $\cat{U}$ has one object.
    \item Take $\cat{D}$ to be the walking arrow. Then if $\cat{U}$ has only one object, it cannot be sent to the source object of $\cat{D}$ because the emanating morphism would have nowhere to go. Hence the unique object of $\cat{U}$ must be sent to the target object of $\cat{D}$. But there is only one such cofunctor, whereas there are two objects in $\cat{D}$. We conclude that objects are not reprsentable in $\smcat^\sharp$ the way they are in $\smcat$.
    \item No, there is no such $\cat{V}$. There is exactly one cofunctor $0\cof\cat{V}$, but there are no objects of $0$.
\end{enumerate}
\end{solution}
\end{exercise}


\begin{example}\label{ex.cof_to_rr} %this is a cofunctor a monoid action... section for those??
Consider the category $\rr\yon^\rr$, where the codomain of $r$ emanating from $x$ is $x+r$, identities are $0$, and composition is given by addition. What are cofunctors into $\rr\yon^\rr$?

Let $\cat{C}$ be a category and $|\cdot|\colon\cat{C}\cof\rr\yon^\rr$ a cofunctor. It assigns to every object $c$ both a real number $|c|\in\rr$ and a choice of emanating morphism $|c|^\sharp(r)\colon c\to c_r$ such that $|c|+r=|c_r|$. This assignment satisfies some laws. Namely we have $c_0=c$ and, given reals $r,s\in\rr$, we have $(c_r)_s=c_{r+s}$. 
\end{example}

%  Interpret above. Possible names: $(\rr,0,+)$-action on the objects of $\cat{C}$, filtration, valuation

\begin{exercise} 
How many cofunctors
\[
    \fbox{$s\To{a}t$}\cof\fbox{$u\Tto{b}{c}v$}
\]
are there from the walking arrow category $\cat{A}$, drawn above on the left, to the walking parallel-arrows category $\cat{P\!A}$, drawn above on the right?
\begin{solution}
There are two: one of which sends $s\mapsto u$ and $t\mapsto v$ and the other of which sends both $s,t\mapsto v$.
\end{solution}
\end{exercise}


\begin{exercise}
\begin{enumerate}
	\item For any category $\cat{C}$ with carrier $\car{c}$, find a category with carrier $\car{c}\yon$.
	\item Show that your construction is functorial; i.e.\ assign each cofunctor $\cat{C}\cof\cat{D}$ a cofunctor $\car{c}\yon\cof\car{d}\yon$ in a way that preserves identities and composites.
	\item Is your functor a monad on $\smcat^\sharp$, a comonad on $\smcat^\sharp$, both, or neither?
\qedhere
\end{enumerate}
\begin{solution}
\begin{enumerate}
    \item Take the category $\cat{C}'$ that has the same objects as $\cat{C}$ and almost the same arrows, except that it has one more arrow $i_c$ from each object $c\in\cat{C}'$ to itself. This new arrow is the identity. The composites of all the old arrows in $\cat{C}'$ are exactly as they are in $\cat{C}$. The old identity $\id_c^\tn{old}$ is no longer an identity because $\id_c^\tn{old}\then i=\id_c^\tn{old}\neq i$.
    \item Given a cofunctor $\varphi\colon\car{c}\cof\car{d}$, we get a cofunctor $\car{c}\yon\cof\car{d}\yon$ that acts the same on objects and all the old arrows and sends the new identities back to the new identities. It preserves identities and composites going backward and codomains going forward, so it's a cofunctor.
    \item It is a monad: there is an obvious unit map $\car{c}\to\car{c}\yon$ and a multiplication map $\car{c}\yon\yon\to\car{c}\yon$ that sends the new identity back to the newest identity.
\end{enumerate}
\end{solution}
\end{exercise}


\begin{exercise}
Suppose $\car{c},\car{d},\car{e}$ are polynomials, each with a comonoid structure, and that $f\colon\car{c}\to\car{d}$ and $g\colon\car{d}\to\car{e}$ are lenses.
\begin{enumerate}
	\item If $f$ and $f\then g$ are each cofunctors, is $g$ automatically a cofunctor?
	If so, sketch a proof; if not, sketch a counterexample.
	\item If $g$ and $f\then g$ are each cofunctors, is $f$ automatically a cofunctor?
	If so, sketch a proof; if not, sketch a counterexample.
\qedhere
\end{enumerate}
\begin{solution}
\begin{enumerate}
    \item Counterexample: take $\car{c}=0$. Then the unique map $f\colon\car{c}\to\car{d}$ is a cofunctor and so is $f\then g$ for any lens $g\colon\car{d}\to\car{e}$, but some lenses are not cofunctors.
    \item Counterexample: take $\car{e}=\yon$. Then there is a unique cofunctor $\epsilon\colon\car{c}\to\yon$. As long as $f$ is copointed, meaning it sends identities backward to identities, then $f\then g$ will be a cofunctor. But not every copointed lens is a cofunctor.
\end{enumerate}
\end{solution}
\end{exercise}

In the next chapter, we will delve deeper into the categorical structure and properties of $\smcat^\sharp$.
We'll encounter many more categories and cofunctors along the way.
But first, we'll conclude this chapter with several alternative characterizations of cofunctors out of state categories.

\subsection{Equivalent characterizations of cofunctors from state categories} \label{sec.comon.sharp.cof.from_state}

Fix a category $\cat{C}$ throughout with polynomial carrier $\car{c}$.
How can view the data of a cofunctor from a state category $S\yon^S\cof\cat{C}$?
This is actually a very natural categorical concept---we'll see some equivalent ways to express this data below, then state and prove even more equivalences next chapter when we have the machinery to do so.

\subsubsection{As coalgebras}

Recall from \cref{ex.coalgebras} that for a set $S$, lenses $S\yon^S\to p$ correspond to functions $S\to p(S)$ known as coalgebras for the functor $p$.
As a cofunctor $S\yon^S\cof\cat{C}$ is just a special kind of lens from $S\yon^S$ to $\car{c}$, it should correspond to a special kind of coalgebra $S\to\car{c}(S)$ for the functor $\car{c}$.
Indeed, whenever $\car{c}$ carries a comonoid $\cat{C}$ with respect to the composition product (i.e.\ a comonad), there is a special notion of a $\cat{C}$-coalgebra (i.e.\ a coalgebra for the comonad $\cat{C}$), as follows.

\begin{definition}[Coalgebra for a polynomial comonoid]\label{def.coalgebra}
Let $\cat{C}=(\car{c},\epsilon,\delta)$ be a polynomial comonoid.
A \emph{$\cat{C}$-coalgebra} $(S,\alpha)$ is
\begin{itemize}
    \item a set $S$, called the \emph{carrier}, equipped with
    \item a function $\alpha\colon S\to\car{c}\tri S$,
\end{itemize}
such that the following diagrams, collectively known as the \emph{coalgebra laws}, commute:
\begin{equation} \label{eqn.coalg_laws}
\begin{tikzcd}
    S \ar[r, "\alpha"] \ar[dr, equal] &
    \car{c}\tri S \ar[d, "\epsilon\:\tri\:S"] \\
    & S
\end{tikzcd}
\hspace{.6in}
\begin{tikzcd}
    S \ar[d, "\alpha"] \ar[r, "\alpha"] &
    \car{c}\tri S \ar[d, "\delta\:\tri\:S"] \\
    \car{c}\tri S \ar[r, "\car{c}\:\tri\:\alpha"'] & 
	\car{c}\tri\car{c}\tri S.
\end{tikzcd}
\end{equation}

A \emph{morphism} of $\cat{C}$-coalgebras $(S,\alpha)\to(T,\beta)$ is a function $h\colon S\to T$ such that the following diagram commutes:
\[
\begin{tikzcd}
    S \ar[d, "h"'] \ar[r, "\alpha"] &
    \car{c}\tri S \ar[d, "\car{c}\:\tri\:h"] \\
    T \ar[r, "\beta"'] &
    \car{c}\tri T
\end{tikzcd}
\]
\end{definition}

% Before we show the correspondence between cofunctors out of state categories and coalgebras, we first discuss how state categories arise formally from the theory of the composition product.

% \begin{example}[State categories, formally]
% Fix  $S\in\smset$.
% In \cref{prop.comp_left_coclosed}, we saw that $\tri$ has a left coclosure operation given by $\lchom{-}{-}$, which by \eqref{eqn.lchom_def} satisfies
% \[
%     \lchom{S}{S}\iso S\yon^S.
% \]
% So by \eqref{eqn.lchom_adj_iso}, we have an isomorphism
% \[
%     \poly(S,p\tri S)\iso\poly(S\yon^S,p)
% \]
% natural in $p$.
% The proof of \cref{prop.comp_left_coclosed} tells us how to characterize this isomorphism using polyboxes: a lens $\varphi\colon S\to p\tri S$, really just a function, can be written as follows (recall that we color a box red when it is impossible to fill, as it must take an element of the empty set):
% \[
% \begin{tikzpicture}[polybox, mapstos]
% 	\node[poly, dom, "$S$" left, constant] (p) {\at$s$};
% 	\node[poly, cod, right=1.5cm of p.south, yshift=-1ex, "$p$" right] (r) {$a$\at$i$};
% 	\node[poly, cod, above=of r, "$S$" right, constant] (q) {\at$t$};
%   	\draw (p_pos) to[first] node[below] {$\varphi^p$} (r_pos);
%   	\draw (r_dir) to[climb] node[right] {$\varphi^S$} (q_pos);
% \end{tikzpicture}
% \]
% Meanwhile, the corresponding lens $\Phi\colon S\yon^S\to p$ can be written as
% \[
% \begin{tikzpicture}[polybox, mapstos]
%     \node[poly, dom, "$S\yon^S$" left] (l) {$j$\at$s$};
%     \node[poly, cod, "$p$" right, right=of l, yshift=-0.5ex] (r) {$a$\at$i$};
%     \draw (l_pos) -- node[below] {$\varphi^r$} (r_pos);
%     \draw (r_dir) -- node[above] {} (l_dir);
% \end{tikzpicture}
% \]





% In particular, the identity lens $\id_S\colon S\to S\iso\yon\tri S$ naturally corresponds to a lens $\epsilon_S\colon S\yon^S\to\yon$
% \end{example}

\begin{proposition}
Cofunctors $S\yon^S\cof\cat{C}$ can be identified (up to isomorphism) with $\cat{C}$-coalgebras carried by $S$.
\end{proposition}
\begin{proof}
Let $\car{c}$ be the carrier of $\cat{C}$.
In \cref{ex.coalgebras}, we showed that \eqref{eqn.monomials_and_comp} gives a natural correspondence between lenses $\Phi\colon S\yon^S\to\car{c}$ and functions $\varphi\colon S\to\car{c}\tri S$.
We can unravel this correspondence via the proof of \cref{prop.comp_left_coclosed} as follows.
A lens $\Phi\colon S\yon^S\to\car{c}$ can be drawn like so (we will adopt our former convention of identifying each morphism $s\to t$ from $S\yon^S$ with its codomain $t$):
\[
\begin{tikzpicture}[polybox, mapstos]
    \node[poly, dom, "$S\yon^S$" left, blue] (l) {$t\vphantom{f}$\at$s\vphantom{i}$};
    \node[poly, cod, "$\car{c}$" right, right=of l, red] (r) {$f$\at$i$};
    \draw (l_pos) -- node[below] {$\Phi_\1$} (r_pos);
    \draw (r_dir) -- node[above] {$\Phi^\sharp$} (l_dir);
\end{tikzpicture}
\]
Meanwhile, the corresponding function $\varphi\colon S\to\car{c}\tri S$, equivalently a lens between constants, can be drawn thusly (recall that we color a box red when it is impossible to fill, i.e.\ when it can only be filled by an element of the empty set):
\[
\begin{tikzpicture}[polybox, mapstos]
	\node[poly, constant dom, "$S$" left, blue] (p) {\at$s$};
	\node[poly, cod, right=1.5cm of p.south, yshift=-1.25ex, "$\car{c}$" right, red] (r) {$f$\at$i$};
	\node[poly, above=of r, "$S$" right, constant, blue] (q) {\at$t$};
  	\draw (p_pos) to[first] node[below] {$\Phi_\1$} (r_pos);
  	\draw (r_dir) to[climb] node[right] {$\Phi^\sharp$} (q_pos);
\end{tikzpicture}
\]

Then it suffices to show that $\Phi$ satisfies the cofunctor laws if and only if $\varphi$ satisfies the coalgebra laws.
We can verify this using polyboxes.
From \eqref{eqn.pres_era_draw}, the eraser preservation law for $\Phi$ would state the following (remember that the arrow in the eraser for the state category $S\yon^S$ is just an equality):
\[
\begin{tikzpicture}
	\node (id1) {
	\begin{tikzpicture}[polybox, mapstos]
		\node[poly, dom, blue, "$S\yon^S$" left] (p) {$s$\at$s$};
		\draw[blue,double,-] (p_pos) to[climb'] node[right] {$\idy$} (p_dir);
	\end{tikzpicture}	
	};
	\node[right=of id1] (id2) {
	\begin{tikzpicture}[polybox, mapstos]
		\node[poly, dom, blue, "$S\yon^S$" left] (p) {$\vphantom{s}$\at$s$};
		\node[poly, red, right=1 of p, "$\car{c}$" below] (q) {};
		\draw (p_pos) to[first] node[below] {$\Phi_\1$} (q_pos);
		\draw (q_dir) to[last] node[above] {$\Phi^\sharp$} (p_dir);
		\draw[red] (q_pos) to[climb'] node[right] {$\idy$} (q_dir);
	\end{tikzpicture}
	};
	\node at ($(id1.east)!.3!(id2.west)$) {$=$}; % -(0,6pt)
\end{tikzpicture}
\]
Meanwhile, the commutative triangle on the left of \eqref{eqn.coalg_laws} can be written as follows:
\[
\begin{tikzpicture}
	\node (id1) {
	\begin{tikzpicture}[polybox, mapstos]
    	\node[poly, constant dom, "$S$" left, blue] (p) {\at$s$};
    	\node[poly, constant, "$S$" right, blue, right=1 of p] (q) {\at$s$};
		\draw[double,blue,-] (p_pos) to[first] node[below] {} (q_pos);
	\end{tikzpicture}	
	};
	\node[right=of id1, yshift=-1.25ex] (id2) {
	\begin{tikzpicture}[polybox, mapstos]
    	\node[poly, constant dom, "$S$" left, blue] (p) {\at$s$};
    	\node[poly, right=1.5cm of p.south, yshift=-1.25ex, "$\car{c}$" below, red] (r) {};
    	\node[poly, above=of r, "$S$" right, constant, blue] (q) {};
    	
      	\draw (p_pos) to[first] node[below] {$\Phi_\1$} (r_pos);
      	\draw (r_dir) to[climb] node[right] {$\Phi^\sharp$} (q_pos);
      	
		\draw[red] (r_pos) to[climb'] node[right] {$\idy$} (r_dir);
    \end{tikzpicture}
	};
	\node at ($(id1.east)!.3!(id2.west)$) {$=$};
\end{tikzpicture}
\]
But these polybox equations are entirely equivalent.

Then from \eqref{eqn.pres_dup_draw}, the duplicator preservation law for $\Phi$ would state the following (remember that the three arrows in the duplicator for the state category $S\yon^S$ are all equalities)
\[
\begin{tikzpicture}
	\node (sp1) {
	\begin{tikzpicture}[polybox, mapstos]
		\node[poly, dom, blue, "$S\yon^S$" left] (c) {\at$s$};
		\node[poly, blue, right=2 of c.south, yshift=-2.75ex, "$S\yon^S$" below] (c1) {$\vphantom{g}$\at$s$};
		\node[poly, blue, above=1 of c1, "$S\yon^S$" above] (c2) {$\vphantom{h}$};
		\node[poly, cod, red, right=1 of c1, "$\car{c}$" below] (c'1) {$g$};
		\node[poly, cod, red, right=1 of c2, "$\car{c}$" above] (c'2) {$h$};
	%
		\draw[blue,double,-] (c_pos) to[first] (c1_pos);
		\draw[blue,double,-] (c1_dir) to[climb] node[right] {tgt} (c2_pos);
		\draw[blue,double,-] (c2_dir) to[last] node[above,sloped] {run} (c_dir);
		\draw (c1_pos) to[first] node[below] {$\Phi_\1$} (c'1_pos);
		\draw (c'1_dir) to[last] node[above] {$\Phi^\sharp$} (c1_dir);
		\draw (c2_pos) to[first] node[below] {$\Phi_\1$} (c'2_pos);
		\draw (c'2_dir) to[last] node[above] {$\Phi^\sharp$} (c2_dir);
    \end{tikzpicture}	
	};
	\node[right=of sp1] (sp2) {
	\begin{tikzpicture}[polybox, mapstos]
		\node[poly, dom, blue, "$S\yon^S$" left] (c) {\at$s$};
		\node[poly, red, right=1 of c, "$\car{c}$" above] (c') {};
		\node[poly, cod, red, right=2 of c'.south, yshift=-1ex, "$\car{c}$" below] (c'1) {$g$};
		\node[poly, cod, red, above=of c'1, "$\car{c}$" above] (c'2) {$h$};
	%
		\draw (c_pos) to[first] node[below] {$\Phi_\1$} (c'_pos);
		\draw (c'_dir) to[last] node[above] {$\Phi^\sharp$} (c_dir);
		\draw[red,double,-] (c'_pos) to[first] (c'1_pos);
		\draw[red] (c'1_dir) to[climb] node[right] {$\cod$} (c'2_pos);
		\draw[red] (c'2_dir) to[last] node[above] {$\then$} (c'_dir);
	\end{tikzpicture}
	};
	\node at ($(sp1.east)!.5!(sp2.west)-(0,4pt)$) {$=$};
\end{tikzpicture}
\]
Meanwhile, the commutative triangle on the right of \eqref{eqn.coalg_laws} can be written as follows:
\[
\begin{tikzpicture}
    \node (p1) {
	    \begin{tikzpicture}[polybox, mapstos]
            \node[poly, constant dom, "$S\yon^S$" left, blue] (m) {\at$s$};
            
            \node[poly, right= of m.south, yshift=-1ex, "$\car{c}$" below, red] (D) {$g$\at};
            \node[poly, constant, above=of D, "$S\yon^S$" above, blue] (mm) {};
            
            \node[poly, cod, right= of D.south, yshift=-1ex, "$\car{c}$" right, red] (DD) {$g$};
            \node[poly, cod, above=of DD, "$\car{c}$" right, red] (mmm) {$h$};
            \node[poly, constant, above=of mmm, "$S\yon^S$" right, blue] (C) {};
            %
            \draw (m_pos) to[first] node[below] {$\Phi_\1$} (D_pos);
            \draw (D_dir) to[climb] node[right] {$\Phi^\sharp$} (mm_pos);
            
            \draw[red,double,-] (D_pos) to[first] (DD_pos);
            \draw[red,double,-] (DD_dir) to[last] (D_dir);
            
            \draw (mm_pos) to[first] node[below] {$\Phi_\1$} (mmm_pos);
            \draw (mmm_dir) to[climb] node[right] {$\Phi^\sharp$} (C_pos);
        \end{tikzpicture}
	};
%
	\node (p2) [right=of p1] {
        \begin{tikzpicture}[polybox, mapstos]%, font=\tiny]
            \node[poly, constant dom, "$S\yon^S$" left, blue] (m') {\at$s$};
            
            \node[poly, right= of m'.south, yshift=-1ex, "$\car{c}$" below, red] (mm') {};
            \node[poly, constant, above=of mm', "$S\yon^S$" above, blue] (C') {};
            
            \node[poly, cod, right= of mm'.south, yshift=-1ex, "$\car{c}$" right, red] (D') {$g$};
            \node[poly, cod, above=of D', "$\car{c}$" right, red] (mmm') {$h$};
            \node[poly, constant, above=of mmm', "$S\yon^S$" right, blue] (CC') {};
            %
            \draw (m'_pos) to[first] node[below] {$\Phi_\1$} (mm'_pos);
            \draw (mm'_dir) to[climb] node[right] {$\Phi^\sharp$} (C'_pos);
            
            \draw[red,double,-] (mm'_pos) to[first] (D'_pos);
            \draw[red] (D'_dir) to[climb] node[right] {cod} (mmm'_pos);
            \draw[red] (mmm'_dir) to[last] node[above] {$\then$} (mm'_dir);
            
            \draw[blue,double, -] (C'_pos) to[first] (CC'_pos);
        \end{tikzpicture}
    };	
	\node at ($(p1.south)!.5!(p2.north)$) {$=$};
\end{tikzpicture}
\]
But these polybox equations are equivalent as well.
Hence the cofunctor laws for $\Phi$ are equivalent to the coalgebra laws for $\varphi$.
\end{proof}

So a cofunctor from a state category to $\cat{C}$ bears the same data as a $\cat{C}$-coalgebra.
The equivalences don't stop there, however.

\subsubsection{As discrete opfibrations}

The concept of a $\cat{C}$-coalgebra is in turn equivalent to a better known categorical construction on $\cat{C}$, which we introduce here.

\begin{definition}[Discrete opfibration]\label{def.dopf}
Let $\cat{C}$ be a category. A pair $(\cat{S},\pi)$, where $\cat{S}$ is a category and $\pi\colon\cat{S}\to\cat{C}$ is a functor, is called a \emph{discrete opfibration over $\cat{C}$} if it satisfies the following condition:
\begin{itemize}
	\item for every object $s\in\cat{S}$, object $c'\in\cat{C}$, and morphism $f\colon \pi(s)\to c'$ there exists a unique object $s'\in\cat{S}$ and morphism $\ol{f}\colon s\to s'$ such that $\pi(\ol{f})=f$. Note that in this case $\pi(s')=c$.
\end{itemize}
\[
\begin{tikzcd}
  s\ar[r, dashed, "\ol{f}"]\ar[d, |->, "\pi"']&
  s'\ar[d, |->, "\pi"]\\
  \pi(s)\ar[r, "f"']&
  \_\vphantom{()}
\end{tikzcd}
\]
A \emph{morphism} of discrete opfibrations $(\cat{S},\pi)\to(\cat{S}',\pi')$ over $\cat{C}$ is a functor $F\colon\cat{S}\to\cat{S}'$ making the following triangle commute:
We refer to $\ol{f}$ as the \emph{lift} of $f$ to $s$.

A \emph{morphism} $(\cat{S},\pi)\to(\cat{S}',\pi')$ between discrete opfibrations over $\cat{C}$ is a functor $F\colon\cat{S}\to\cat{S}'$ making the following triangle commute:
\begin{equation}\label{eqn.dopf_triangle}
\begin{tikzcd}[column sep=small]
	\cat{S}\ar[dr, "\pi"']\ar[rr, "F"]&&
	\cat{S}'\ar[dl, "\pi'"]\\&
	\cat{C}
\end{tikzcd}
\end{equation}
We denote the category of discrete opfibrations over $\cat{C}$ by $\Cat{dopf}(\cat{C})$.
\end{definition}

\begin{exercise}
Show that if $F\colon \cat{S}\to\cat{S}'$ is a functor making the triangle \eqref{eqn.dopf_triangle} commute, where both $\pi$ and $\pi'$ are discrete opfibrations, then $F$ is also a discrete opfibration.
\begin{solution}
In general, a functor $F\colon\cat{C}\to\cat{D}$ is a discrete opfibration iff, for every object $c\in\cat{C}$, the induced map $F[c]\colon\cat{C}[c]\to\cat{D}[Fc]$ is a bijection.

In our case, if $\pi$ and $\pi'$ are discrete opfibrations then for any $s\in\cat{S}$ we have that both the second map and the composite in $\cat{S}[s]\To{F[s]}\cat{S}'[Fs]\To{\pi'[Fs]}\cat{C}[\pi s]$ are bijections, so the first map is too.
\end{solution}
\end{exercise}

\begin{exercise}\label{exc.dopf_cof}
Suppose $\pi\colon\cat{S}\to\cat{C}$ is a discrete opfibration and $i\in\cat{S}
$ is an object. With notation as in \cref{def.dopf}, show the following:
\begin{enumerate}
	\item Show that the lift $\ol{\id_{\pi(i)}}=\id_i$ of the identity on $\pi(i)$ is the identity on $i$.
	\item Show that for $f\colon\pi(i)\to c$ and $g\colon c\to c'$, we have $\ol{f}\then\ol{g}=\ol{f\then g}$.
	\item Show how $\pi$ could instead be interpreted as a cofunctor.% (We will characterize exactly which cofunctors can arise in this way in \cref{**}.)
\qedhere
\end{enumerate}
\begin{solution}
\begin{enumerate}
    \item The identity map $\id_i$ satisfies $\pi(\id_i)=\id_{\pi(i)}$, so $\ol{\id_{\pi(i)}}=\id_i$ by the uniqueness-of-lift condition in \cref{def.dopf}.
    \item The morphism $\ol{f}\then\ol{g}$ satisfies $\pi(\ol{f}\then\ol{g})=\pi(\ol{f})\then\pi(\ol{g})=f\then g$, so again this follows by uniqueness of lift.
    \item To see that $\pi$ is a cofunctor, we need to understand and verify conditions about its action forward on objects and backward on morphisms. Its action forward on objects is that of $\pi$ as a functor. Given an object $s\in\cat{S}$, the action of $\pi$ backward on morphisms is the lift operation $\pi^\sharp_s(f)\coloneqq\ol{f}$. This preserves identity by part 1, composition by part 2, and codomains because $\pi(\cod(\pi^\sharp_s(f)))=\cod(\pi(\pi^\sharp_s(f)))=\cod(f)$.
\end{enumerate}
\end{solution}
\end{exercise}

As it turns out, not only do $\cat{C}$-coalgebras carry the same data as discrete opfibrations over $\cat{C}$, they in fact comprise isomorphic categories.

\begin{proposition}
The category of $\cat{C}$-coalgebras is isomorphic to the category $\Cat{dopf}(\cat{C})$ of discrete opfibrations over $\cat{C}$.
\end{proposition}
\begin{proof}
**
\end{proof}


\subsubsection{As copresheaves}

It is well-known in the category theory literature that the category of discrete opfibrations over $\cat{C}$ is equivalent to yet another familiar category: the category $\smset^{\cat{C}}$, whose objects are functors $\cat{C}\to\smset$.
Such a functor is known as a \emph{copresheaf} on $\cat{C}$ for short.
Here we review what is needed to understand this equivalence.
We begin by giving a standard construction on any copresheaf.

\begin{definition}[Category of elements]\label{def.cat_elements}
Given a copresheaf on $\cat{C}$, i.e.\ a functor $I\colon\cat{C}\to\smset$, its \emph{category of elements} $\elts^\cat{C}I$ is defined to have objects
\[
    \Ob\elts^\cat{C}I\coloneqq\{(c,x)\mid c\in\cat{C}, x\in Ic\}
\]
and a morphism $f\colon(c,x)\to(c',x')$ for every morphism $f\colon c\to c'$ from $\cat{C}$ satisfying
\[
    (If)(x)=x'.
\]
Identities and composites in $\elts^\cat{C}I$ are inherited from $\cat{C}$; they obey the usual category laws by the functoriality of $I$.

The category is so named because its objects are the elements of the sets that the objects of $\cat{C}$ are sent to by $I$.
Each morphism $f\colon c\to\_$ in $\cat{C}$ then becomes as many morphisms in $\elts^\cat{C}I$ as there are elements of $Ic$, tracking where $If$ sends each such element.
\end{definition}

The next exercise shows how this construction turns every copresheaf into a discrete opfibration.

\begin{exercise} \label{exc.copre_to_dopf}
\begin{exercise}
Let $I\colon\cat{C}\to\smset$ be a functor, and let $\int^{\cat{C}}I$ be as in \cref{def.cat_elements}.
\begin{enumerate}
    \item Show that there is a functor $\pi\colon\elts^\cat{C}I\to\cat{C}$ sending objects $(c,x)\mapsto c$ and morphisms $f\colon(c,x)\to(c',x')$ to $f\colon c\to c'$.
    \item Show that $\pi$ is in fact a discrete opfibration. \qedhere
\end{enumerate}
\begin{solution}
\begin{enumerate}
    \item The functor action on objects and morphisms is defined in the exercise statement, so it suffices to check that it preserves identities and composites. But this too is obvious: $\pi(\id)=\id$ and $\pi(f\then g)$ is $f\then g$.
    \item Given an object $(c,x)\in\int^\cat{C}I$ and $f\colon c\to c'$, we need to check that there is a unique object $s\in\int^{\cat{C}}I$ and morphism $\ol{f}\colon(c,x)\to s$ with $\pi(\ol{f})=f$. Using $x'\coloneqq I(f)(x)$ and $s\coloneqq(c',x')$ and $\ol{f}\coloneqq f$, we do indeed get $\pi(\ol{f})=f$ and we find that it is the only possible choice.
\end{enumerate}
\end{solution}
\end{exercise}

In fact, the assignment of a discrete opfibration to every copresheaf given above is functorial, as the next exercise shows.

\begin{exercise}\label{exc.elts_functor}
Suppose that $I,J\colon\cat{C}\to\smset$ are functors and $\alpha\colon I\to J$ is a natural transformation. 
\begin{enumerate}
	\item Show that $\alpha$ induces a functor $(\elts^\cat{C}I)\to(\elts^\cat{C}J)$.
	\item Show that it is a morphism of discrete opfibrations in the sense of \cref{def.dopf}.
	\item Have you now verified that there is a functor
	\[
	\elts^\cat{C}\colon\smset^{\cat{C}}\to\Cat{dopf}(\cat{C})
	\]
	or is there something left to do?
	\end{enumerate}
\begin{solution}
\begin{enumerate}
    \item Given a natural transformation $\alpha\colon I\to J$, we need a functor $\int^\cat{C}\alpha\colon\int^\cat{C}I\to\int^\cat{C}J$. On objects have it send $(c,x)\mapsto(c,\alpha_cx)$, where $x\in I(c)$ so $\alpha_cx\in J(c)$; on morphisms have it send $f\mapsto f$, a mapping which clearly preserves identities and composition.
    \item To see that $\int^\cat{C}\alpha$ is a morphism between discrete opfibrations, one only needs to check that it commutes with the projections to $\cat{C}$, but this is obvious: the mapping $(c,x)\mapsto(c,\alpha_cx)$ and the mapping $f\mapsto f$ preserve the objects and morphisms of $\cat{C}$.
    \item It is clear that $\int^\cat{C}$ preserves identities and composition in $\smset^\cat{C}$, so we have verified that this is functor.
\end{enumerate}
\end{solution}
\end{exercise}

\begin{exercise}\label{exc.elts_free_grph}
Let $G$ be a graph, and let $\cat{G}$ be the free category on it. Show that for any functor $S\colon\cat{G}\to\smset$, the category $\elts^\cat{G} S$ of elements is again free on a graph.
\begin{solution}
Given a graph $G\coloneqq(\fun{src},\fun{tgt}\colon E\tto V)$ and functor $S\colon\cat{G}\to\smset$, define a new graph $H$ as the following diagram of sets:
\[
\begin{tikzcd}[column sep=50pt]
	\sum_{e\in E} S(\fun{src}(e))\ar[r, shift left, "{(\fun{src},\id)}"]\ar[r, shift right, "{(\fun{\tgt},S(e))}"']&
	\sum_{v\in V} S(v)
\end{tikzcd}
\]
In other words, it is a graph for which a vertex is a pair $(v,s)$ with $v\in V$ a $G$-vertex and $s\in S(v)$, and for which an edge is a pair $(e, s)$ with $e\in E$ a $G$-edge, say $e\colon v\to v'$, and $s\in S(v)$ is an element over the source of that edge. With this notation, the edge $(e,s)$ has as source vertex $(v,s)$ and has as target vertex $(v',S(e)(s))$ where $S(e)\colon S(v)\to S(v')$ is the function given by the functor $S\colon\cat{G}\to\smset$.

It remains to see that the free category on $H$ is isomorphic to $\int^{\cat{G}}S$. We first note that it has the same set of objects, namely $\sum_{v\in V}S(v)$. A morphism in $\int^\cat{G}S$ can be identified with an object $(v,s)$ together with a morphism $f\colon v\to v'$ in $\cat{G}$, but this is just a length-$n$ sequence $(e_1,\ldots,e_n)$ of edges, with $v=\fun{src}(e_1)$, $\fun{tgt}(e_{i})=\fun{src}(e_{i+1})$ for $1\leq i<n$, and $\fun{tgt}(e_n)=v'$. This is the same data as a morphism in the free category on $H$.
\end{solution}
\end{exercise}

\begin{proposition}\label{prop.tfae_dopf}
The category $\smset^{\cat{C}}$ of copresheaves on $\cat{C}$ is equivalent to the category of discrete opfibrations over $\cat{C}$.
\end{proposition}
\begin{proof}
By \cref{exc.elts_functor} we have a functor $\elts^\cat{C}\colon\smset^{\cat{C}}\to\Cat{dopf}(\cat{C})$. There is a functor going back: given a discrete opfibration $\pi\colon\cat{S}\to\cat{C}$, we define a functor $\partial\pi\colon\cat{C}\to\smset$ on objects by sending each $c\in\cat{C}$ to the set of objects in $\cat{S}$ that $\pi$ maps to $c$; that is,
\[
    (\partial\pi)(c)\coloneqq\{s\in\cat{S}\mid\pi(s)=c\}.
\]
Then on morphisms, for each $f\colon c\to\_$ in $\cat{C}$ and $s\in(\partial\pi)(c)$ we have $\pi(s)=c$, so by \cref{def.dopf} there exists a unique morphism $\ol{f}\colon s\to\_$ for which $\pi(\ol{f})=f$.
As $\pi(\cod\ol{f})=\cod f$, we have $\cod\ol{f}\in(\partial\pi)(\cod f)$, so we can define
\[
    (\partial\pi)(f)(s)\coloneqq\cod\ol{f}.
\]
On objects, the roundtrip $\smset^{\cat{C}}\to\smset^{\cat{C}}$ sends $I\colon\cat{C}\to\smset$ to the functor
\begin{align*}
	c&
	\mapsto\{s\in\elts^\cat{C}I\mid \pi(s)\\&
	=\{(c,x)\mid x\in I(c)\}&=I(c).
\end{align*}
The roundtrip $\Cat{dopf}(\cat{C})\to\Cat{dopf}(\cat{C})$ sends $\pi\colon\cat{S}\to\cat{C}$ to the discrete opfibration whose object set is $\{(c,s)\in\Ob(\cat{C})\times\Ob(\cat{S})\mid\pi(s)=c\}$ and this set is clearly in bijection with $\Ob(\cat{S})$. Proceeding similarly, one defines an isomorphism of categories $\cat{S}\cong\elts^\cat{C}\partial\pi$.
\end{proof}

% ** ??

\begin{proposition}\label{prop.ds_dopf}
Up to isomorphism, discrete opfibrations into $\cat{C}$ can be identified with dynamical systems on $\cat{C}$.
\end{proposition}
In case it isn't clear, this association is only functorial on the groupoid of objects and isomorphisms.
\begin{proof}
Given a discrete opfibration $\pi\colon\cat{S}\to\cat{C}$, take $S\coloneqq\Ob(\cat{S})$ and define $(\varphi_1,\varphi^\sharp)\colon S\yon^S\to\car{c}$ by $\varphi_1=\pi$ and with $\varphi^\sharp$ given by the lifting: $\varphi(g)\coloneqq \hat{g}$ as in \cref{def.dopf}. One checks using \cref{exc.dopf_cof} that this defines a cofunctor. 

Conversely, given a cofunctor $(\varphi_1,\varphi^\sharp)\colon S\yon^S\to\car{c}$, the function $\varphi_1$ induces a map of polynomials $S\yon\to\car{c}$, and we can factor it as a vertical followed by a cartesian $S\yon\to\car{s}\To{\psi}\car{c}$. We can give $\car{s}$ the structure of a category such that $\psi$ is a cofunctor; see \cref{exc.ds_dopf}.
\end{proof}

\begin{exercise}\label{exc.ds_dopf}
With notation as in \cref{prop.ds_dopf}, complete the proof as follows.
\begin{enumerate}
	\item Check that $(\varphi,\varphi^\sharp)$ defined in the first paragraph is indeed a cofunctor.
	\item Find a comonoid structure on $\car{s}$ such that $\psi$ is a cofunctor, as stated in the second paragraph. 
	\item Show that the two directions are inverse, up to isomorphism.
\qedhere
\end{enumerate}
\end{exercise}

\begin{example}
In \cref{ex.cofree_dyn_sys} we had a dynamical system with $S\coloneqq\{\bul[dgreen],\bul[dyellow],\bul[red]\}$ and $p\coloneqq\yon^\2+\1$, and  $f\colon S\yon^S\to p$ from \cref{exc.halt_dsa}, depicted here again for your convenience:
\begin{equation}\label{eqn.dyn_sys_misc573}
\begin{tikzcd}[column sep=small]
	\bul[dgreen]\ar[rr, bend left, orange]\ar[loop left, dgreen]&&
	\bul[dyellow]\ar[dl, bend left, orange]\ar[ll, dgreen, bend left]\\&
	\bul[red]
\end{tikzcd}
\end{equation}
The polynomial map $f$ induces a cofunctor $F\colon S\yon^S\cof\cofree{p}$ from the state category on $S$ to the category of $p$-trees. We can now see this as a database instance on $\cofree{p}$, considered as a database schema. 

The cofree category $\cofree{t}$ is actually the free category on a graph, as we saw in \cref{prop.cofree_free_on_graph}, and so the schema is easy. There is one table for each tree (object in $\cofree{p}$), e.g.\ we have a table associated to this tree:
\[
	\treepic
\]
The table has two columns, say left and right, corresponding to the two arrows emanating from the root node. The left column refers back to the same table, and the right column refers to another table (the one corresponding to the yellow dot).

Again, there are infinitely many tables in this schema. Only three of them have data in them; the rest are empty. We know in advance that this instance has three rows in total, since $|S|=3$.
\end{example}

Given a dynamical system $S\yon^S\to p$, we extend it to a cofunctor $\varphi\colon S\yon^S\cof\cofree{p}$. By \cref{prop.tfae_dopf,prop.ds_dopf}, we can consider it as a discrete opfibration over $\cofree{p}$. By \cref{exc.elts_free_grph} the category $\elts \varphi$ is again free on a graph. It is this graph that we usually draw when depicting the dynamical system, e.g.\ in \eqref{eqn.dyn_sys_misc573}.


\begin{exercise}
Give an example of a dynamical system on $p\coloneqq\yon^\2+\yon$ for which the corresponding database instance has a table with at least two rows.
% ** translate to not databases
\end{exercise}

\begin{exercise}
% ** translate to cofunctors & not databases
A dynamical system with interface $\yon$ is a map $S\yon^S\to\yon$.
\begin{enumerate}
	\item What is the corresponding database schema?
	\item Explain what the corresponding database instance looks like.
	\item In particular, how many total rows does it have?
	\item Give an example with $|S|=7$, displayed both as a dynamical system (with states and transitions) and as a database instance.	
\qedhere
\end{enumerate}
\end{exercise}

To summarize, we have four equivalent notions:
\begin{enumerate}[label=(\arabic*)]
    \item cofunctors $F\colon S\yon^S\cof\cat{C}$;
    \item $\cat{C}$-coalgebras $(S,\alpha)$, with $\alpha\colon S\to\car{c}\tri S$;
    \item discrete opfibrations $\pi\colon \cat{S}\to\cat{C}$, with $\Ob\cat{S}=S$;
    \item copresheaves $I\colon\cat{C}\to\smset$, with $\Ob\elts^{\cat{C}}I=S$.
\end{enumerate}
Moreover, (2), (3), and (4) form equivalent categories.
Translating between these notions yields different perspectives on familiar categorical concepts.
In the next chapter, we will discover even more characterizations of the same data within $\poly$ (see \cref{prop.cart_dopf,**}).

%-------- Section --------%
\section{Summary and further reading}

In this chapter we began by showing that for every set $S$, the thing that makes a dynamical system like $S\yon^S\to p$ actually run is the fact that $S\yon^S$ has the structure of a comonoid.  We then explained Ahman-and-Uustalu's result that comonoids, i.e.\ polynomials $p$, equipped with a pair of lenses $\epsilon\colon p\to\yon$ and $\delta\colon p\to p\tri p$, are exactly categories \cite{ahman2016directed}. We explained how $\epsilon$ picks out an identity for each object and how $\delta$ picks out a codomain for each morphism and a composite for each composable pair of morphisms. In particular we showed that the category corresponding to $S\yon^S$ is the \emph{contractible groupoid on $S$}, i.e.\ the category with $S$-many objects and a unique morphism between any two.

We then discussed how comonoid morphisms $\car{c}\to\car{d}$ are not functors but \emph{cofunctors}: they map forwards on objects and backwards on morphisms. Cofunctors were first defined by Marcelo Aguiar \cite{aguiar1997internal}, though his definition was opposite to ours. Cofunctors are the morphisms of a category we notate as $\smcat^\sharp$. We showed that cofunctors between state categories $S\yon^S\cof T\yon^T$ are what are known in the functional programming community as \emph{very well-behaved lenses}. For more on lenses, see \cite{nlab2022lens}.


%-------- Section --------%
\section{Exercise solutions}
\Closesolutionfile{solutions}
{\footnotesize
\input{solution-file6}}

\Opensolutionfile{solutions}[solution-file7]

%------------ Chapter ------------%
\chapter{Categorical properties of polynomial comonoids} \label{ch.comon.cofree}

While we defined the category $\smcat^\sharp$ of categories and cofunctors in the last chapter, we have only begun to scratch the surface of the properties it satisfies.
As the cateogry of comonoids in $\poly$, equipped with a canonical forgetful functor $U\colon\smcat^\sharp\to\poly$ sending each polynomial to its carrier, $\smcat^\sharp$ inherits many of the categorical properties satisfied by $\poly$.
Underpinning this inheritance is the fact that $U$ has a right adjoint, a cofree functor $\poly\to\smcat^\sharp$.
We will introduce this adjunction in the first section of this chapter.
Then we will discuss how many of the categorical properties of $\poly$, including much of what we covered in \cref{ch.poly.bonus}, play nicely with restriction to $\smcat^\sharp$.
Finally, we will touch on other constructions we can make over the comonoids in $\poly$, such as their comodules and coalgebras.

%-------- Section --------%
\section{Cofree comonoids} \label{sec.comon.cofree.cons}

Consider a dynamical system $\varphi\colon\car{s}\to p$ with state system $\car{s}$ and interface $p$.
In \cref{subsec.comon.sharp.state.run}, we posed the question of whether there was a single morphism that could capture all the information encoded by the family of lenses $\text{Run}_n(\varphi)\colon\car{s}\to p\tripow{n}$ for all $n\in\nn$, defined as the composite
\[
    \car{s}\To{\delta^{(n)}}\car{s}\tripow{n}\To{\varphi\tripow{n}}p\tripow{n}
\]
that models $n$ runs through the system $\varphi$.

It turns out that there is: the key is that there is a natural way to interpret every polynomial $p$ as a category $\cofree{p}$, so that cofunctors into $\cofree{p}$ are exactly lenses into $p$.
In other words, $\cofree{p}$ will turn out to be the \emph{cofree comonoid} (or \emph{cofree category}) \emph{on $p$}.
Cofree comonoids in $\poly$ are beautiful objects, both in their visualizable structure as a category and in the metaphors we can make about them. They allow us to replace the interface of a dynamical system with a category and get access to a rich theory that exists there.

We'll go through the construction of the cofree comonoid and its implications in this section, featuring a purely formal proof of the fact the forgetful functor $U\colon\smcat^\sharp\to\poly$ has a right adjoint $\cofree{-}\colon\poly\to\smcat^\sharp$, where for each $p\in\poly$, the carrier $\car{t}_p\coloneqq U\cofree{p}$ of the category $\cofree{p}$ is given by the limit of the following diagram:
\begin{equation} \label{eqn.cofree_diagram}
\begin{tikzcd}
	\yon \ar[d] &
	p \ar[d] &
	p\tripow2 \ar[d] &
	[10pt] p\tripow3 \ar[d] &
	\cdots\\
	\1 &
	p\tri\1 \ar[l, "!"'] &
	p\tripow2\tri\1 \ar[l, "p\:\tri\:!"'] &
	p\tripow3\tri\1 \ar[l, "p\tripow2\:\tri\:!"'] &
	\cdots.\ar[l]
\end{tikzcd}
\end{equation}
Thus, we will show that $U$ and $\cofree{-}$ form a forgetful-cofree adjunction, making $\cofree{p}$ the cofree comonoid on $p$.
But first, let us concretely characterize the canonical comonoid structure on the limit of \eqref{eqn.cofree_diagram}, before showing that it is indeed cofree.

%---- Subsection ----%
\subsection{The carrier of the cofree comonoid} \label{subsec.comon.cofree.cons.car}

Let $\car{t}_p$ be the limit of the diagram \eqref{eqn.cofree_diagram} in $\poly$; it will turn out to be the carrier of the cofree comonoid on $p$ (where $p$ will be an arbitrary polynomial throughout).
We could compute this limit directly, but we will be able to describe it more concretely in terms of what we call \emph{trees on $p$} or \emph{$p$-trees}: trees comprised of $p$-corollas.
In doing so, we will formalize the tree pictures we have been using to describe polynomials all along.

\subsubsection{Trees on polynomials}

\begin{definition}[Tree on a polynomial] \label{def.poly_tree}
Let $p\in\poly$ be a polynomial.
A \emph{tree on $p$}, or a \emph{$p$-tree}, is a rooted tree whose every vertex $v$ is assigned a $p$-position $i$ and a bijection from the children of $v$ to $p[i]$.
We denote the set of $p$-trees by $\tr_p$.
\end{definition}
We can think of a $p$-tree as being ``built'' out of $p$-corollas according to these instructions:
\begin{quote}
To choose a $p$-tree in $\tr_p$: 
\begin{enumerate}
    \item choose a $p$-corolla:
    \begin{itemize}
        \item its root $i_0\in p(\1)$ will be the tree's root, and
        \item its leaves in $p[i_0]$ will be the edges out of the root;
    \end{itemize}
    \item for each $p[i_0]$-leaf $a_1$:
    \begin{enumerate}[label*=\arabic*.]
        \item choose a $p$-corolla:
        \begin{itemize}
            \item its root $i_1\in p(\1)$ will be the vertex adjoined to $a_1$, and
            \item its leaves in $p[i_1]$ will be the edges out of that vertex;
        \end{itemize}
        \item for each $p[i_1]$-leaf $a_2$:
        \begin{enumerate}[label*=\arabic*.]
            \item choose a $p$-corolla:
            \begin{itemize}
                \item its root $i_2\in p(\1)$ will be the vertex adjoined to $a_2$, and
                \item its leaves in $p[i_2]$ will be the edges out of that vertex;
            \end{itemize}
            \item for each $p[i_1]$-leaf $a_2$:
            
            $\cdots$
        \end{enumerate}
    \end{enumerate}
\end{enumerate}
\end{quote}
Of course, there may eventually be multiple copies of any one $p$-root as a vertex or $p$-leaf as an edge in our $p$-tree, and these vertices and edges are not literally the same.
So we should really think of the positions and directions of $p$ involved each step as \emph{labels} for the vertices and edges of a $p$-tree---although crucially, each $p[i]$-direction must be used as a label exactly once among the edges emanating from a given vertex labeled with $i$.

Although these instructions continue forever, we could abbreviate them by writing them recursively:
\begin{quote}
To choose a $p$-tree in $\tr_p$: 
\begin{enumerate}
    \item choose a $p$-corolla:
    \begin{itemize}
        \item its root $i_0\in p(\1)$ will be (the label of) the tree's root, and
        \item its leaves in $p[i_0]$ will be (the labels of) the edges out of the root;
    \end{itemize}
    \item for each $p[i_0]$-leaf $a_1$:
    \begin{enumerate}[label*=\arabic*.]
        \item choose a $p$-tree in $\tr_p$:
        \begin{itemize}
            \item it will be the subtree whose root is adjoined to $a_1$. 
        \end{itemize}
    \end{enumerate}
\end{enumerate}
\end{quote}

We would like to draw some examples of $p$-trees, but note that a $p$-tree can have infinite height---in fact, it always will unless every one of its branches terminates at a $p$-corolla with no leaves, i.e.\ a position with an empty direction set.
This means that plenty of $p$-trees cannot be drawn, even when all the position- and direction-sets of $p$ are finite; but we can instead consider finite-height portions of them that we will call \emph{pretrees}.

\subsubsection{Pretrees on polynomials}

Before we define pretrees, let's give some examples. 

\begin{example}[A few example $p$-pretrees]
Let $p\coloneqq\{\bul[red],\bul[blue]\}\yon^\2+\{\bul[dgreen]\}\yon+\{\bul[dyellow]\}$.
Here are four partially constructed $p$-trees:
\begin{equation}\label{eqn.some_trees_misc58}
\begin{tikzpicture}[trees,
  level 1/.style={sibling distance=10mm},
  level 2/.style={sibling distance=5mm},
  level 3/.style={sibling distance=2.5mm}]
	\node[red] (a) {$\bullet$}
		child {node[red] {$\bullet$}
			child {node[dyellow] {$\bullet$}}
			child {node[dyellow] {$\bullet$}}
		}
		child {node[dgreen] {$\bullet$}
			child {node[dgreen] {$\bullet$}
				child
			}
		}
		;
	\node[dgreen, right=2 of a] (b) {$\bullet$}
		child {node[blue] {$\bullet$}
			child {node[blue] {$\bullet$}
				child
				child
			}
			child {node[red] {$\bullet$}
				child
				child
			}
		};
	\node[dyellow, right=2 of b] (c) {$\bullet$};
	\node[red, right=2 of c] {$\bullet$}
		child {node[blue] {$\bullet$}
			child {node[red] {$\bullet$}
				child
				child
			}
			child {node[red] {$\bullet$}
				child
				child
			}
		}
		child {node[red] {$\bullet$}
			child {node[red] {$\bullet$}
				child
				child
			}
			child {node[red] {$\bullet$}
				child
				child
			}
		};
\end{tikzpicture}
\end{equation}
Here only the third one---the single yellow dot---would count as an element of $\tr_p$. 
After all, in \cref{def.poly_tree}, when we speak of a tree on $p$, we mean a tree for which every vertex is a position in $p$ with all of its emanating directions filled by another position in $p$.
Since three of the four trees shown in \eqref{eqn.some_trees_misc58} have leaves emanating from the top that have not been filled by any $p$-corollas, these trees are not elements of $\tr_p$.

However, each of these trees can be extended to an actual element of $\tr_p$ by continually filling in each open leaf with another $p$-corolla.
These might continue forever---or, if you're lazy, you could just cap them all off with the direction-less yellow dot.
\end{example}

\begin{exercise}
Let $q\coloneqq\yon^\2+\3\yon^\1$.
Are there any finite $q$-trees?
If not, could there be any vertices of a given $q$-tree with finitely many descendents?
\begin{solution}
With $q\coloneqq\yon^\2+\3\yon^\1$, every vertex of a $q$-tree starting from the root has either $1$ or $2$ outgoing edges, from which it follows that the tree is infinite and that every vertex has infinitely many descendents.
\end{solution}
\end{exercise}

The trees in \eqref{eqn.some_trees_misc58} can all be obtained by following just the first $3$ levels of instructions for building a $p$-tree (in fact, exactly as many instructions as we initially wrote out).
On the other hand, we know from \cref{subsec.comon.comp.def.corolla} that such a tree represents a position of $p\tripow3$, whose directions are its height-$3$ leaves---and this is true for any $n\in\nn$ in place of $3$.
So these trees are still important to our theory; but since they are not always complete $p$-trees, we will call them something else.


\begin{definition} \label{def.tripow_pretree}
Given $p\in\poly$, a \emph{stage-$n$ pretree} (or \emph{$p\tripow{n}$-pretree}) is defined to be an element of $p\tripow{n}(\1)$. For each $i\in p\tripow{n}(\1)$ the \emph{height-$n$ leaves} of $i$ is defined to be the set $p\tripow{n}[i]$.
\end{definition}

\begin{remark} \label{rmk.stage}
In \cref{def.tripow_pretree}, we use \emph{stage} instead of \emph{height} to allow for the fact that a $p\tripow{n}$-pretree may not reach its maximum height $n$ if all of its branches terminate early.
For example, the yellow dot in \eqref{eqn.some_trees_misc58} is a $p\tripow1$-pretree, but it is also a $p\tripow2$-pretree, a $p\tripow{50}$-pretree, and indeed a $p$-tree.

Note that for any polynomial $p\in\poly$ there is exactly one stage-$0$ pretree on $p$ for any $p\in\poly$, because $p\tripow0(\1)=\yon(\1)=\1$.
\end{remark}

\begin{example}[Trimming pretrees] \label{ex.trim}
Since $p\tripow1(\1)\iso p(\1)$ and $p\tripow0(\1)\iso\yon(\1)\iso\1$, the unique function $!\colon p(\1)\to\1$ can be thought of as a function from $p\tripow1$-positions to $p\tripow0$-positions, or equivalently a function from stage-$1$ pretrees (i.e.\ corollas) to stage-$0$ pretrees on $p$.
We can interpret this function as taking a corolla and ``stripping away'' its leaves along with the position-label on its root, leaving only a single unlabeled root: a stage-$0$ pretree.

This deceptively simple function has a surprising amount of utility when combined with other maps.
For any $n\in\nn$, we can take the composition product in $\poly$ of the identity on $p\tripow{n}$ and $!$, interpreted as a lens between constant polynomials, to obtain a lens $p\tripow{n}\tri \:!\colon p\tripow{n}\tri p(\1)\to p\tripow{n}\tri\1$, or equivalently a function $p\tripow{n}(!)\colon p\tripow{n+1}(\1)\to p\tripow{n}(\1)$ from stage-$(n+1)$ pretrees to stage-$n$ pretrees on $p$.

We can deduce the behavior of this function on stage-$(n+1)$ pretrees from what we know about how the composition product interacts with pretrees on $p$.
The identity lens on $p\tripow{n}$ keeps the lower $n$ levels of each $p\tripow{(n+1)}$-pretree intact, while $!$ will ``strip away'' the $p\tripow{(n+1)}$-pretree's height-$(n+1)$ leaves, along with all the position-labels on its height-$n$ vertices.
Thus $p\tripow{n}(!)$ is the function sending every stage-$(n+1)$ pretree on $p$ to its stage-$n$ pretree, effectively \emph{trimming it down} a level.

We can go even further: composing several such functions yields a composite function
\begin{equation} \label{eqn.trim}
    p\tripow{n}(\1) \From{p\tripow{n}(!)}
	p\tripow{(n+1)}(\1) \from\cdots\from
	p\tripow{(n+k-1)}(\1) \From{p\tripow{(n+k-1)}(!)}
	p\tripow{(n+k)}(\1)
\end{equation}
sending every stage-$(n+k)$ pretree on $p$ to its stage-$n$ pretree by trimming off its top $k$ levels.
We will see these functions again shortly.
\end{example}

% ** some pretree exercises?

\subsubsection{Trees as a limit of pretrees}

Before we go any further in the theory of $p$-trees, let us look at some more examples.

\begin{example}[A few more actual $p$-trees] \label{ex.imagining_trees}
Keeping $p\coloneqq\{\bul[red],\bul[blue]\}\yon^\2+\{\bul[dgreen]\}\yon+\{\bul[dyellow]\}$, here are some elements of $\tr_p$ that we could imagine (or even draw, at least in part):
\begin{itemize}
	\item The binary tree that's ``all red all the time.''
	\item The binary tree where odd layers are red and even layers are blue.
	\item The binary tree whose root is red, but after which every left child is red and every right child is blue.%
	\tablefootnote{To formalize the notions of ``left'' and ``right,'' we could think of the direction-sets of the red and blue dots as $\2\iso\{\const{left},\const{right}\}$, so that out of every vertex there is an edge labeled $\const{left}$ and an edge labeled $\const{right}$.}
	\item The tree where all the nodes are red, except for the rightmost branch, which (apart from the red root) is always green.
	\item Any finite tree, where every branch terminates in a yellow dot.
	\item A completely random tree: for the root, randomly choose either red, blue, green, or yellow, and at every leaf, loop back to the beginning, i.e.\ randomly choose either red, blue, green, or yellow, etc.
\end{itemize}
In fact, there are uncountably many trees in $\tr_p$ (even just $\tr_{2\yon}$ has cardinality $\2^\nn$), but only countably many can be uniquely characterized in a finite language like English (and of course only finitely many can be uniquely characterized in the time we have!).
Thus most elements of $\tr_p$ cannot even be described.
\end{example}

\begin{exercise}\label{exc.p_tree_sets}
% \begin{enumerate}
% 	\item Interpret each of the five tree examples imagined in \cref{ex.imagining_trees} by drawing three or four layers (your choice) of it.
% \end{enumerate}
For each of the following polynomials $p$, characterize the set of trees $\tr_{p}$.
\begin{enumerate}[resume]
	\item $p\coloneqq\1$.
	\item $p\coloneqq\2$.
	\item \label{exc.p_tree_sets.unary} $p\coloneqq\yon$.
	\item \label{exc.p_tree_sets.binary} $p\coloneqq\yon^\2$.
	\item $p\coloneqq{\2\yon}$.
	\item $p\coloneqq{\yon+\1}$.
	\item \label{exc.p_tree_sets.monomial} $p\coloneqq{B\yon^A}$ for some sets $A,B\in\smset$.
\qedhere
\end{enumerate}
\begin{solution}
\begin{enumerate}
    \item To select a $\1$-tree, we must select a position from $\1$\dots and then we are done, because there are no directions. So there is a unique $\1$-tree given by a root and no edges, implying that $\tr_\1\iso\1$.
    \item To select a $\2$-tree, we must select a position from $\2$.
    Then we are done, because there are no directions.
    So every $\2$-tree is a root with no edges, and the root is labeled with one of the elements of $\2$.
    Hence $\tr_\2\iso\2$.
    \item To select a $\yon$-tree, we must select a position from $\1$; then for the unique direction at that position, we must select a position from $\1$; and so forth.
    Since we only ever have $1$ position to choose from, there is only $1$ such $\yon$-tree we can build: an infinite ray extending from the root, where every vertex has exactly $1$ child.
    Hence $\tr_\yon\iso\1$.
    \item To select a $\yon^\2$-tree, we must select a position from $\1$; then for each direction at that position, we must select a position from $\1$; and so forth.
    We only ever have $1$ position to choose from, so there is only $1$ such $\yon^\2$-tree: an infinite binary tree, where every vertex has exactly $2$ children.
    Hence $\tr_{\yon^\2}\iso\1$.
    \item To select a $\2\yon$-tree, we must select a position from $\2$; then for the unique direction at that position, we must select a position from $\2$; and so forth, one position out of $\2$ for each level of the tree.
    So every $\2\yon$-tree is an infinite ray, where every vertex is labeled with an element of $\2$ and has exactly $1$ child.
    There is then a unique vertex of height $n$ for each $n\in\nn$, so there is a bijection between $2\yon$-trees $T$ and functions $f\colon\nn\to\2$, where $f(n)\in\2$ is the label of the height-$n$ vertex of $T$.
    Hence $\tr_{\2\yon}\iso\2^\nn$.
    \item To select a $(\yon+\1)$-tree, we choose either a position with $1$ direction or a position with no directions: if the position has no directions, we stop, and if the position has $1$ direction, we repeat our choice for the next level.
    So a choice of $(\yon+\1)$-tree is equivalent to a choice of when, if ever, to stop.
    That is, for each $n\in\nn$, there is a unique $(\yon+\1)$-tree of height-$n$ consisting of $n+1$ vertices along a single path, so that every vertex aside from the height-$n$ leaf has exactly $1$ child.
    Then there is exactly one more $(\yon+\1)$-tree: an infinite ray, obtained by always picking the position with $1$ directions and never the one with no directions.
    Hence we could write $\tr_{\yon+\1}\iso\nn\cup\{\infty\}$ (although this set is in bijection with $\nn$).
    \item To select a $B\yon^A$-tree for fixed $A,B\in\smset$, we must select a position from $B$; then for each direction in $A$ at that position, we must select a position from $B$; and so forth.
    This yields a tree in which every vertex has $A$-many children and a label from $B$.
    Such a tree has $1$ root and $|A|$ times as many vertices in one level than the level below it, so its height-$n$ vertices for each $n\in\nn$ are in bijection with the set $A^\ord{n}$: each $n$-tuple in $A^\ord{n}$ gives a length-$n$ rooted path of directions in $A$ to follow up the tree, uniquely specifying a height-$n$ vertex.
    So the set of all vertices is given by $\sum_{n\in\nn}A^\ord{n}=\lst(A)$.
    Then specifying a $B\yon^A$-tree amounts to assigning a label from $B$ to every vertex via a function $\lst(A)\to B$.
    Hence $\tr_{B\yon^A}\iso B^{\lst(A)}$.
\end{enumerate}
\end{solution}
\end{exercise}

\begin{exercise} \label{exc.n_ary_trees}
\begin{enumerate}
    \item Say we were interested in \emph{$\ord{n}$-ary trees}: infinite (unless $n=0$) rooted trees in which every vertex has $n$ children.
    Is there a polynomial $p$ for which $\tr_p$ is the set of $\ord{n}$-ary trees?
    \item \label{exc.n_ary_trees.l_labeled} Now say we wanted to assign each vertex of an $\ord{n}$-ary tree a label from a set $L$.
    Is there a polynomial $q$ for which $\tr_q$ is the set of $L$-labeled $\ord{n}$-ary trees?\qedhere
\end{enumerate}
\begin{solution}
\begin{enumerate}
    \item Yes: by \cref{exc.p_tree_sets} \cref{exc.p_tree_sets.monomial} in the case of $B=1$, or by analogy with \cref{exc.p_tree_sets} \cref{exc.p_tree_sets.unary,exc.p_tree_sets.binary}, we have that $\tr_{\yon^\ord{n}}$ is the set of $\ord{n}$-ary trees.
    \item Yes: by \cref{exc.p_tree_sets} \cref{exc.p_tree_sets.monomial}, we have that $\tr_{L\yon^\ord{n}}$ is the set of $L$-labeled $\ord{n}$-ary trees.
\end{enumerate}
\end{solution}
\end{exercise}

From here, a natural question to ask is how the set $\tr_p$ of $p$-trees is related to the set of $p\tripow{n}$-pretrees $p\tripow{n}(\1)$ for each $n\in\nn$.
A look back at \cref{def.tripow_pretree} gives a clue: every $p$-tree has a stage-$n$ pretree obtained by removing all vertices of height greater than $n$, yielding a function $\tr_p\to p\tripow{n}(\1)$ that we will denote by $\pi^{(n)}$.

Moreover, since the stage-$n$ pretree of a given $p$-tree agrees with the stage-$n$ pretree of any stage-$(n+k)$ pretree of the $p$-tree, the functions $\pi^{(n)}$ should commute with our tree-trimming functions $p\tripow{(n+k)}(\1)\to p\tripow{n}(\1)$ from \eqref{eqn.trim} in \cref{ex.trim}.
In particular, the following diagram commutes for all $n\in\nn$:
\[
\begin{tikzcd}[column sep=large]
    \tr_p \ar[d,"\pi^{(n)}"'] \ar[dr,"\pi^{(n+1)}",outer sep=-2pt] \\
    p\tripow{n}(\1) & p\tripow{(n+1)}(\1). \ar[l,"p\tripow{n}(!)"]
\end{tikzcd}
\]
All this says is that if we trim a $p$-tree down until only $n+1$ levels are left via $\pi^{(n+1)}$, then trimmed off one more level via $p\tripow{n}(!)$, it would be the same as if we had trimmed it down to $n$ levels from the start via $\pi^{(n)}$.
This is summarized by the following larger commutative diagram, which contains every function of the form \cref{ex.trim}:
\begin{equation} \label{eqn.cofree_pos_with_lim}
\begin{tikzcd}[sep=large]
    \tr_p \ar[dd,"\pi^{(0)}"'] \ar[ddr,"\pi^{(1)}"',outer sep=-2pt] \ar[ddrr,"\pi^{(2)}"',outer sep=-1.5pt] \ar[ddrrrr,"\pi^{(3)}"',outer sep=-1.5pt]\\
    &&&\cdots\\
    \1 &
	p(\1) \ar[l, "!"] &
	p\tripow2(\1) \ar[l, "p(!)"] &&
% 	[10pt]
	p\tripow3(\1) \ar[ll, "p\tripow2(!)"] &
	\cdots.\ar[l]
\end{tikzcd}
\end{equation}
% \[
% \begin{tikzcd}[sep=large]
%     \tr_p \ar[dd,"\pi^{(0)}"'] \ar[ddr,"\pi^{(1)}"',outer sep=-2pt] \ar[ddrr,"\pi^{(2)}"',outer sep=-1.5pt] \ar[ddrrrr,"\pi^{(3)}"',outer sep=-1.5pt]\\
%     &&&\ldots\\
%     \1 &
% 	p(\1) \ar[l, "!"] &
% 	p\tri p(\1) \ar[l, "p(!)"] &&
% % 	[10pt]
% 	p\tri p\tri p(\1) \ar[ll, "p\:\tri\:p(!)"] &
% 	\cdots.\ar[l]
% \end{tikzcd}
% \]
So $\tr_p$ with the functions $\pi^{(n)}$ forms a cone over the the bottom row---in fact, it is the universal cone.
Intuitively, this is because a $p$-tree carries exactly the information that a compatible sequence of $p\tripow{n}$-pretrees does: no more, no less.
But we can prove it formally as well.

\begin{exercise}
Prove that $\tr_p$ with the functions $\pi^{(n)}\colon\tr_p\to p\tripow{n}(\1)$ is the limit of the diagram
\begin{equation} \label{eqn.cofree_pos_diagram}
\begin{tikzcd}
    \1 &
	p(\1) \ar[l, "!"'] &
	p\tripow2(\1) \ar[l, "p(!)"'] &
 	[10pt]
	p\tripow3(\1) \ar[l, "p\tripow2(!)"'] &
	\cdots.\ar[l]
\end{tikzcd}
\end{equation}
You may use the fact that \eqref{eqn.cofree_pos_with_lim} commutes.
\begin{solution}
**
\end{solution}
\end{exercise}

If you know about coalgebras for functors, as mentioned in \cref{ex.coalgebras}, then you might know the limit $\car{t}_p(\1)$ of \eqref{eqn.cofree_pos_diagram} by a different name: it is the \emph{terminal coalgebra for the functor} $p$, or the \emph{terminal $p$-coalgebra}, because it is terminal in the category of $p$-coalgebras, as the following exercise shows.

\begin{exercise}
A \emph{$p$-coalgebra morphism} between $p$-coalgebras $\varphi\colon S\to p(S)$ and $\psi\colon T\to p(T)$ (as in \cref{ex.coalgebras}) is a function $f\colon S\to T$ such that the square
\[
\begin{tikzcd}
    S \ar[r,"\varphi"] \ar[d,"f"'] & p(S) \ar[d,"p(f)"] \\
    T \ar[r,"\psi"] & p(T)
\end{tikzcd}
\]
commutes.
Show that $\tr_p$ equipped with some function $\tr_p\to p(\tr_p)$ is the terminal object in the category of $p$-coalgebras and the morphisms between them.
Then show that the function $\tr_p\to p(\tr_p)$ you chose is a bijection.
\begin{solution}
**
\end{solution}
\end{exercise}

\subsubsection{Positions of the cofree comonoid}

Now recall from \cref{ex.compute_limits} that in $\poly$, the positions of a limit are the limit of the positions.
Moreover, in \eqref{eqn.cofree_diagram}, every vertical map $p\tripow{n}\to p\tripow{n}\tri\1$ is, in fact, a \emph{vertical} lens in the sense of \cref{def.vert_cart}: an isomorphism on positions.
So \eqref{eqn.cofree_diagram} on positions collapses down to its bottom row, viewed as a diagram in $\smset$.
Yet this is precisely the diagram from \eqref{eqn.cofree_pos_diagram}, whose limit is $\tr_p$.
So $\tr_p$ is the position-set of the limit $\car{t}_p$ of \eqref{eqn.cofree_diagram}: we write $\car{t}_p(\1)\iso\tr_p$.

So, as we said above, $\car{t}_p(\1)$ is the set carrying the terminal coalgebra of $p$, but  we prefer to think of it as the set of $p$-trees, for it gives us a concrete way to realize the limit and its projections, as well as a natural interpretation of the directions of $\car{t}_p$ at each position.

\subsubsection{The directions of the cofree comonoid}

Given that $\car{t}_p$ is the limit of \eqref{eqn.cofree_diagram}, \cref{ex.compute_limits} also tells us how to compute its directions: the directions of a limit are the colimit of the directions.
But every polynomial in the bottom row of \eqref{eqn.cofree_diagram} has an empty direction-set, and there are no arrows between polynomials in the top row.
So the directions of $\car{t}_p$ are given by a coproduct of the directions of each $p\tripow{n}$.

More precisely, given a $p$-tree $T\in\tr_p$ whose stage-$n$ pretree for $n\in\nn$ is $\pi^{(n)}T$, the direction-set $\car{t}_p[t]$ is given by the following coproduct:
\[
    \car{t}_p[T]\coloneqq\sum_{n\in\nn}p\tripow{n}[\pi^{(n)}T].
\]
But by \cref{def.tripow_pretree}, each $p\tripow{n}[\pi^{(n)}T]$ is the set of height-$n$ leaves of the $p\tripow{n}$-pretree $\pi^{(n)}T$, which in turn is the stage-$n$ pretree of $T$.
So its height-$n$ leaves coincide with the height-$n$ vertices of $T$.
Therefore, we can identify $p\tripow{n}[\pi^{(n)}T]$ with the set of height-$n$ vertices of $T$; we denote this set by $\vtx_n(T)$.

Since the coproduct above ranges over all $n\in\nn$, it follows that $\car{t}_p[T]$ is the set of \emph{all} vertices in $T$; we denote this set by $\vtx(T)$.
The on-directions function at $T$ of each projection $\car{t}_p\to p\tripow{n}$ from the limit must then be the canonical inclusion
\[
    p\tripow{n}[\pi^{(n)}T]\iso \vtx_n(T)\inj \vtx(T)\iso\car{t}_p[T],
\]
sending height-$n$ leaves of $\pi^{(n)}T$ to height-$n$ vertices of $T$.

Here is alternative way to think about the directions of $\car{t}_p$ and each $p\tripow{n}$ that will be helpful.
A defining feature of a rooted tree is that its vertices are in bijection with its finite rooted paths: each vertex gives rise to a unique path to that vertex from the root, and every finite rooted path arises this way.
So the directions of $p\tripow{n}$ at a given $p\tripow{n}$-pretree correspond in turn to the rooted paths of that pretree leading to its height-$n$ leaves; indeed, each such direction is comprised of a sequence of $n$ directions of $p$, which together specify a length-$n$ rooted path up the pretree.
Then for $T\in\tr_p$, the direction-set $\car{t}_p[T]$ consists of every finite rooted path of $T$. 

Since only finite rooted paths correspond to vertices, all our paths will be assumed to be finite from here on out. This is our preferred way to think about directions in $\car{t}_p$.
When we wish to refer to what one might call an infinite (rooted) ``path,'' we will instead call it a (rooted) \emph{ray}.

\begin{exercise}\label{exc.p_tree_polys}
For each of the following polynomials $p$, characterize the polynomial $\car{t}_p$.
You may choose to think of the directions of $\car{t}_p$ either as vertices or as rooted paths.
(Note that these are the same polynomials from \cref{exc.p_tree_sets}.)
\begin{enumerate}
	\item \label{exc.p_tree_polys.1} $p\coloneqq\1$.
	\item $p\coloneqq\2$.
	\item \label{exc.p_tree_polys.unary} $p\coloneqq\yon$.
	\item \label{exc.p_tree_polys.binary} $p\coloneqq\yon^\2$.
	\item \label{exc.p_tree_polys.2_label_ray} $p\coloneqq{\2\yon}$.
	\item \label{exc.p_tree_polys.maybe_unary} $p\coloneqq{\yon+\1}$.
	\item \label{exc.p_tree_polys.monomial} $p\coloneqq{B\yon^A}$ for some sets $A,B\in\smset$.
\qedhere
\end{enumerate}
\begin{solution}
For the given values of $p$, we have already characterized the position-set $\car{t}_p(\1)\iso\tr_p$ of $\car{t}$ in \cref{exc.p_tree_sets}, so it remains to characterize the directions at each position, i.e.\ the vertices of each $p$-tree.
\begin{enumerate}
    \item We saw that $\tr_\1\iso\1$ and that the unique $\1$-tree has a single vertex, its root.
    Equivalently, it has only $1$ rooted path: the empty path from the root to itself.
    So $\car{t}_\1\iso\1\yon^\1\iso\yon$.
    \item We saw that $\tr_\2\iso\2$ and that each $\2$-tree has a single vertex, its root.
    Equivalently, its only rooted path is the empty path.
    So $\car{t}_\2\iso\2\yon^\1\iso\2\yon$.
    \item We saw that $\tr_\yon\iso\1$ and that the unique $\yon$-tree is a single ray extending from the root, where every vertex has exactly $1$ child.
    So there is exactly $1$ vertex of height-$n$ for each $n\in\nn$, yielding a bijection between the vertices of the $\yon$-tree to $\nn$.
    Equivalently, the ray has exactly $1$ rooted path of length $n$ for each $n\in\nn$.
    So $\car{t}_\yon\iso\yon^\nn$.
    \item We saw that $\tr_{\yon^\2}\iso\1$ and that the unique $\yon^\2$-tree is an infinite binary tree, where every vertex has exactly $2$ children.
    So the vertices of height-$n$ are in bijection with $\2^\ord{n}$, yielding a bijection between the vertices of the $\yon^\2$-tree to $\sum_{n\in\nn}\2^\ord{n}\iso\lst(\2)$.
    Equivalently, the rooted paths of an infinite binary tree are just finite binary sequences, which comprise the set $\lst(\2)$.
    Hence $\car{t}_{\yon^\2}\iso\yon^{\lst(\2)}$.
    \item We saw that $\tr_{\2\yon}\iso\2^\nn$, and that every $2\yon$-tree is an infinite ray, whose vertices (or rooted paths) are in bijection with $\nn$.
    Hence $\car{t}_{\2\yon}\iso\2^\nn\yon^\nn$.
    \item We saw that $\tr_{\yon+\1}\iso\nn\cup\{\infty\}$.
    Here the $(\yon+\1)$-tree corresponding to $n\in\nn$ consists of $n+1$ vertices along a single path, so that every vertex aside from the height-$n$ leaf has exactly $1$ child; and the $(\yon+\1)$-tree corresponding to $\infty$ is an infinite ray.
    Thus the direction-set of $\car{t}_{\yon+\1}$ at $n\in\nn$ is $\ord{n}+\1$, while its direction-set at $\infty$ is $\nn$.
    Hence $\car{t}_{\yon+\1}\iso\{\infty\}\yon^\nn+\sum_{n\in\nn}\yon^{\ord{n}+\1}$.
    \item We saw that $\tr_{B\yon^A}\iso B^{\lst(A)}$, where the height-$n$ vertices of a given $B\yon^A$-tree are in bijection with the set $A^\ord{n}$, so the set of all vertices of a $B\yon^A$-tree is given by $\sum_{n\in\nn}A^\ord{n}=\lst(A)$.
    Equivalently, the rooted paths of the $B\yon^A$-tree are just finite sequences in $A$, which comprise the set $\lst(A)$.
    Hence $\car{t}_{B\yon^A}\iso B^{\lst(A)}\yon^{\lst(A)}$.
\end{enumerate}
\end{solution}
\end{exercise}

We summarize the results of this section in the following proposition, thus concretely characterizing the carrier $\car{t}_p$ of the cofree comonoid on $p$ in terms of $p$-trees.
For reasons that will become clear shortly, we will denote each projection from the limit of \eqref{eqn.cofree_diagram} by $\epsilon^{(n)}_p\colon\car{t}_p\to p\tripow{n}$. We denote $\epsilon$ simply by $\epsilon$.

\begin{proposition} \label{prop.cofree_carrier_lim}
For $p\in\poly$, let
\[
    \car{t}_p\coloneqq\sum_{T\in\tr_p}\yon^{\vtx(T)}
\]
be the polynomial whose positions are $p$-trees and whose directions at each $p$-tree are the rooted paths.
Then $\car{t}_p$ is the limit of the diagram \eqref{eqn.cofree_diagram}, with projections $\epsilon^{(n)}_p\colon\car{t}_p\to p\tripow{n}$ for every $n\in\nn$ making the following diagram commute:
\begin{equation} \label{eqn.cofree_with_lim}
\begin{tikzcd}[sep=large]
    \car{t}_p \ar[dd,"\epsilon_p"'] \ar[ddr,"\epsilon^{(1)}_p"',outer sep=-2pt] \ar[ddrr,"\epsilon^{(2)}_p"',outer sep=-1.5pt] \ar[ddrrrr,"\epsilon^{(3)}_p"',outer sep=-1.5pt]\\
    &&&\cdots\\
    \yon \ar[d] &
	p \ar[d] &
	p\tripow2 \ar[d] &&
% 	[10pt]
	p\tripow3 \ar[d] &
	\cdots \\
    \1 &
	p(\1) \ar[l, "!"] &
	p\tripow2(\1) \ar[l, "p(!)"] &&
% 	[10pt]
	p\tripow3(\1) \ar[ll, "p\tripow2(!)"] &
	\cdots.\ar[l]
\end{tikzcd}
\end{equation}
The lens $\epsilon^{(n)}_p\colon\car{t}_p\to p\tripow{n}$ sends each $p$-tree $T\in\tr_p$ to its stage-$n$ pretree $\pi^{(n)}T$ on positions and each height-$n$ leaf of $\pi^{(n)}T$ to the corresponding height-$n$ rooted path of $T$ on directions.
\end{proposition}

\begin{example}[Drawing $\epsilon^{(n)}_p$ in polyboxes] \label{ex.eps_n_polybox}
Here is $\epsilon^{(n)}_p\colon\car{t}_p\to p\tripow{n}$ drawn in polyboxes, where we continue to denote the stage-$n$ pretree of a $p$-tree by $\pi^{(n)}T$:
\begin{equation} \label{eqn.eps_n_polybox}
\begin{tikzpicture}
  \node (f) {
    \begin{tikzpicture}[polybox, mapstos]
  	  \node[poly, dom, "$\car{t}_p$" below] (p) {$v$\at$T$};
  	  \node[left=0pt of p_pos] {$\tr_p$};
  	  \node[left=0pt of p_dir] {$\vtx(-)$};

  	  \node[poly, cod, right=of p, "$p\tripow{n}$" below] (q) {$v$\at$\pi^{(n)}T$};
  	  \node[right=0pt of q_pos] {$p\tripow{n}(\1)$};
	  \node[right=0pt of q_dir] {$\vtx_n(-)$};
	  
  	  \draw (p_pos) -- node[below] {} (q_pos);
  	  \draw (q_dir) -- node[above] {} (p_dir);
    \end{tikzpicture}
  };
\end{tikzpicture}
\end{equation}
On the right hand side, $v$ is a height-$n$ leaf of $\pi^{(n)}T$; on the left, $v$ is identified with the corresponding height-$n$ vertex of $T$.

This isn't the only way we can write this lens in polyboxes, however; polyboxes have special notation for lenses to composites, allowing us to write, say, the $n=4$ case like so:
\begin{equation} \label{eqn.eps_1_1_1_1_polybox}
\begin{tikzpicture}[polybox, mapstos]
	\node[poly, dom, "$\car{t}_p$" left] (p) {$a_1\leadsto a_2\leadsto a_3\leadsto a_4$\at$T$};
	\foreach \i/\j in {1/0,2/1,3/2,4/3}
	{
  	\node[poly, cod, "$p$" right] (q\i) at (4,1.3*\i-3.25) {$a_\i$\at$i_\j$};
	};
	\draw (p_pos) to[first] node[below] {} (q1_pos.west);
	\foreach \i/\j in {1/2,2/3,3/4}
	{
		\draw 
			(q\i_dir.west) 
			to[climb] 
			node[left] {}
			(q\j_pos.west);
	};
	\draw (q4_dir) to[last] node[above left] {} (p_dir);
\end{tikzpicture}
\end{equation}
Here we are unpacking the construction of the first $4$ levels of $T$, according to our nested instructions for building $p$-trees.
The $p$-position $i_0$ is the label on the root of $T$, while the $p[i_0]$-direction $a_1$ specifies one of the edges coming out of it---leading to a height-$1$ vertex of $T$ labeled $i_1$, and so on.

The contents of the position-boxes and the arrows going up on the codomain side carry all the data of the bottom $4$ levels of $T$: namely the label $i_0$ of the root, the label $i_1$ of the vertex at the end of every direction $a_1$ out of the root, and so on until $i_3$.
All this specifies a unique $p\tripow4$-position, a $p\tripow4$-pretree, which is the same as the $p\tripow4$-pretree $T$.
Indeed, we can think of $\pi^{(4)}T$ as a shorthand for the gadget comprised of the $4$ polyboxes on the right hand side of \eqref{eqn.eps_1_1_1_1_polybox} when their blue boxes are yet to be filled.
So the position and direction depicted on the codomain side of \eqref{eqn.eps_1_1_1_1_polybox} is equivalent to the position and direction depicted on the codomain side of \eqref{eqn.eps_n_polybox}.
This generalizes to all values of $n$. The direction $a_4$ emanating from $i_3$, together with all the data below it, corresponds to the rooted path we've denoted $a_1\leadsto a_2\leadsto a_3\leadsto a_4$ in $T$.

There are even more ways to express $\epsilon^{(4)}_p\colon\car{t}_p\to p\tripow4$ in polyboxes, however.
After all, $p\tripow4\iso p\tripow2\tri p\tripow2$.
So we ought to be able to draw $\epsilon^{(4)}_p$ as follows:
\begin{equation} \label{eqn.eps_2_2_polybox_empty}
\begin{tikzpicture}[polybox, tos]
    \node[poly, dom, "$\car{t}_p$" left] (r) {};
    \node[poly, cod, right=1.8 of r.south, yshift=-1ex, "$p\tripow2$" right] (q) {};
    \node[poly, cod, above=of q, "$p\tripow2$" right] (q') {};
    
    \draw (r_pos) to[first] node[below] {} (q_pos);
    \draw (q_dir) to[climb] node[right] {} (q'_pos);
    \draw (q'_dir) to[last] node[above] {} (r_dir);
\end{tikzpicture}
\end{equation}
Let's think about how we should fill these boxes.
We can still put a $p$-tree $T$ in the lower left position box.
From the commutativity of \eqref{eqn.cofree_with_lim}, we know the on-positions function $\pi^{(4)}$ of $\epsilon^{(4)}_p$ factors through the on-positions function $\pi^{(2)}$ of $\epsilon^{(2)}_p$, which tells us that $p\tripow2$-pretree that should go in the lower right position box should be $\pi^{(2)}T$: the $p\tripow2$-pretree of $T$.

Another way to think about this is that the polyboxes for the lower $p\tripow2$ on the right side of \eqref{eqn.eps_2_2_polybox_empty} are equivalent to the polyboxes for the $2$ lower copies of $p$ on the right side of \eqref{eqn.eps_1_1_1_1_polybox}---just like how the polyboxes for $p\tripow{n}$ in \eqref{eqn.eps_n_polybox} are equivalent to the polyboxes for all $n=4$ copies of $p$ in \eqref{eqn.eps_1_1_1_1_polybox}.
There, the position could be represented with a single $p\tripow{n}$-pretree $\pi^{(n)}T$, and the direction $(a_1,\ldots,a_n)$ is one of its length-$n$ rooted paths.
So here, too, we can package the $2$ lower copies of $p$ into a single pair of polyboxes for $p\tripow2$, if we let $u$ be the height-$2$ vertex of $T$ at the end of the rooted path $(a_1,a_2)$:
\begin{equation} \label{eqn.eps_2_2_polybox_partly}
\begin{tikzpicture}[polybox, mapstos]
    \node[poly, dom, "$\car{t}_p$" left] (r) {\at$T$};
    \node[poly, cod, right=1.8 of r.south, yshift=-1ex, "$p\tripow2$" right] (q) {$u$\at$\pi^{(2)}T$};
    \node[poly, cod, above=of q, "$p\tripow2$" right] (q') {};
    
    \draw (r_pos) to[first] node[below] {} (q_pos);
    \draw (q_dir) to[climb] node[right] {} (q'_pos);
    \draw (q'_dir) to[last] node[above] {} (r_dir);
\end{tikzpicture}
\end{equation}
But then the polyboxes for the $2$ upper copies of $p$ from \eqref{eqn.eps_1_1_1_1_polybox} should also collapse down to a single pair of polyboxes for $p\tripow2$, with a $p\tripow2$-pretree as its position and a height-$2$ leaf of that pretree as its direction.
Indeed, once we have followed the directions $(a_1,a_2)$ up to the height-$2$ vertex $u$, the subtree of $T$ rooted at $u$ is itself a $p$-tree: it has a label $i_2$ on its root, out of which we can follow the direction $a_3$ to reach a height-$1$ vertex labeled $i_3$, then follow the direction $a_4$ to reach a height-$2$ vertex that we call $w$.
Of course, the vertex labeled $i_3$ is actually a height-$3$ vertex of the whole tree $T$; likewise $w$ corresponds to a height-$4$ vertex of $T$.
However, from the perspective of the upper copy of $p\tripow2$ in \eqref{eqn.eps_2_2_polybox_partly}, we are starting over from $u$ and moving up the subtree of $T$ rooted at $u$---or, more precisely, the $p\tripow2$-pretree of the subtree rooted at $u$.
So the polyboxes end up looking like this:
\begin{equation} \label{eqn.eps_2_2_polybox}
\begin{tikzpicture}[polybox, mapstos]
    \node[poly, dom, "$\car{t}_p$" left] (r) {$u\leadsto w$\at$T$};
    \node[poly, cod, right=1.8 of r.south, yshift=-1ex, "$p\tripow2$" right] (q) {$u$\at$\pi^{(2)}T$};
    \node[poly, cod, above=of q, "$p\tripow2$" right] (q') {$w$\at$\pi^{(2)}T(u)$};
    
    \draw (r_pos) to[first] node[below] {} (q_pos);
    \draw (q_dir) to[climb] node[right] {} (q'_pos);
    \draw (q'_dir) to[last] node[above] {} (r_dir);
\end{tikzpicture}
\end{equation}
Here $T(u)$ denotes the $p$-tree equal to the subtree of $T$ rooted at its vertex $u$, and $w$ is one of $T(u)$'s height-$2$ vertices.
When viewed as the subtree of $T$ rooted at its the height-$2$ vertex $u$, the $p$-tree $T(u)$ has its height-$2$ vertex $w$ identified with a height-$4$ vertex of $T$, a descendent of $u$ that we denote by $u\leadsto w$.
Alternatively, $u$ corresponds to the rooted path $(a_1,a_2)$ of $T$, while $w$ corresponds to the rooted path $(a_3,a_4)$ of $T(u)$, so $u\leadsto w$ corresponds to the concatenated rooted path $(a_1,a_2,a_3,a_4)$ of $T$.
As concatenation is associative, $\leadsto$ is associative as well. 

Both the notation $T(u)$, for what we will call the $p$-\emph{subtree} of the $p$-tree $T$ rooted at $u\in\vtx(T)$, and the notation $u\leadsto w$, for the vertex in $\vtx(T)$ that $w\in\vtx(T(u))$ coincides with when $T(u)$ is identified with the subtree of $p$ rooted at $u$, will turn out to be temporary---we will soon justify why we can express these concepts in much more familiar terms.%
\tablefootnote{As a reminder, due to the definition of a $p$-tree $T$, a $p$-subtree of $T$ is still itself a $p$-tree, whereas the $p\tripow{n}$-pretree of $T$ is not a $p$-tree unless the height of $T$ is strictly less than $n$.}
As a sneak preview, they will be crucial to defining the categorical structure of the cofree comonoid on $p$.

Here are three more ways to depict $\epsilon^{(4)}_p$, viewing its codomain in turn as $p\tripow3\tri p\tripow1$, as $p\tripow1\tri p\tripow2\tri p\tripow1$, or as $p\tripow1\tri p\tripow1\tri p\tripow1\tri p\tripow1$:
\[
\begin{tikzpicture}
\node (1) {
\begin{tikzpicture}[polybox, mapstos]
    \node[poly, dom, "$\car{t}_p$" left] (r) {$r\leadsto t$\at$T$};
    \node[poly, cod, right=1.8 of r.south, yshift=-1ex, "$p\tripow3$" right] (q) {$r$\at$\pi^{(3)}T$};
    \node[poly, cod, above=of q, "$p\tripow1$" right] (q') {$t$\at$\pi^{(1)}T(r)$};
    
    \draw (r_pos) to[first] node[below] {} (q_pos);
    \draw (q_dir) to[climb] node[right] {} (q'_pos);
    \draw (q'_dir) to[last] node[above] {} (r_dir);
\end{tikzpicture}
};
\node[right=1.5 of 1] (2) {
\begin{tikzpicture}[polybox, mapstos]
	\node[poly, dom, "$\car{t}_p$" left] (S) {$x\leadsto s\leadsto t$\at$T$};
	\node[poly, cod, right=of S, "$p\tripow2$" right] (S2) {$s$\at$\pi^{(2)}T(x)$};
	\node[poly, cod, below=of S2, "$p\tripow1$" right] (S1) {$x$\at$\pi^{(1)}T$};
	\node[poly, cod, above=of S2, "$p\tripow1$" right] (S3) {$t$\at$\pi^{(1)}T(x\leadsto s)$};
%
	\draw (S_pos) to[first] (S1_pos);
	\draw (S1_dir) to[climb] (S2_pos);
	\draw (S2_dir) to[climb] (S3_pos);
	\draw (S3_dir) to[last] (S_dir);
\end{tikzpicture}	
};
\node at ($(1.east)!.5!(2.west)$) {=};
\end{tikzpicture}
\]
\[
\begin{tikzpicture}[polybox, mapstos]
	\node[poly, dom, "$=\qquad\car{t}_p$" left] (p) {$x\leadsto y\leadsto z\leadsto t$\at$T$};
  	\node[poly, cod, "$p\tripow1$" right] (q1) at (4,1.5*1-3.25) {$x$\at$\pi^{(1)}T$};
  	\node[poly, cod, "$p\tripow1$" right] (q2) at (4,1.5*2-3.25) {$y$\at$\pi^{(1)}T(x)$};
  	\node[poly, cod, "$p\tripow1$" right] (q3) at (4,1.5*3-3.25) {$z$\at$\pi^{(1)}T(x\leadsto y)$};
  	\node[poly, cod, "$p\tripow1$" right] (q4) at (4,1.5*4-3.25) {$t$\at$\pi^{(1)}T(x\leadsto y\leadsto z)$};
  	
	\draw (p_pos) to[first] node[below] {} (q1_pos.west);
	\foreach \i/\j in {1/2,2/3,3/4}
	{
		\draw 
			(q\i_dir.west) 
			to[climb] 
			node[left] {}
			(q\j_pos.west);
	};
	\draw (q4_dir) to[last] node[above left] {} (p_dir);
\end{tikzpicture}
\]
Here $r=x\leadsto s$ and $s=y\leadsto z$.
Notice that the last depiction is just another way to write \eqref{eqn.eps_1_1_1_1_polybox}, with each $p\tripow1$-pretree in place of the $p$-position that labels its root and height-$1$ vertices in place of their corresponding directions, which are just length-$1$ rooted paths.

Finally, all this could be generalized to other values of $n$.
Here are different ways to draw polyboxes for $\epsilon^{(n)}_p\colon\car{t}_p\to p\tripow{n}$, viewing its codomain as $p\tripow\ell\tri p\tripow{m}$ with $n=\ell+m$ or $p\tripow{i}\tri p\tripow{j}\tri p\tripow{k}$ with $n=i+j+k$:
\[
\begin{tikzpicture}
\node (1) {
\begin{tikzpicture}[polybox, mapstos]
    \node[poly, dom, "$\car{t}_p$" left] (r) {$u\leadsto w$\at$T$};
    \node[poly, cod, right=1.8 of r.south, yshift=-1ex, "$p\tripow\ell$" right] (q) {$u$\at$\pi^{(\ell)}T$};
    \node[poly, cod, above=of q, "$p\tripow{m}$" right] (q') {$w$\at$\pi^{(m)}T(u)$};
    
    \draw (r_pos) to[first] node[below] {} (q_pos);
    \draw (q_dir) to[climb] node[right] {} (q'_pos);
    \draw (q'_dir) to[last] node[above] {} (r_dir);
\end{tikzpicture}
};
\node[right=1.5 of 1] (2) {
\begin{tikzpicture}[polybox, mapstos]
	\node[poly, dom, "$\car{t}_p$" left] (S) {$x\leadsto s\leadsto t$\at$T$};
	\node[poly, cod, right=of S, "$p\tripow{j}$" right] (S2) {$s$\at$\pi^{(j)}T(x)$};
	\node[poly, cod, below=of S2, "$p\tripow{i}$" right] (S1) {$x$\at$\pi^{(i)}T$};
	\node[poly, cod, above=of S2, "$p\tripow{k}$" right] (S3) {$t$\at$\pi^{(k)}T(x\leadsto s)$};
%
	\draw (S_pos) to[first] (S1_pos);
	\draw (S1_dir) to[climb] (S2_pos);
	\draw (S2_dir) to[climb] (S3_pos);
	\draw (S3_dir) to[last] (S_dir);
\end{tikzpicture}	
};
\node at ($(1.east)!.5!(2.west)$) {=};
\end{tikzpicture}
\]
\end{example}

%---- Subsection ----%
\subsection{Cofree comonoids as categories} \label{subsec.comon.cofree.cons.cat}

We have now characterized the carrier $\car{t}_p$ of the comonoid $\cofree{p}$ that will turn out to be cofree on $p$; but we have yet to describe the comonoid structure of $\cofree{p}$ that $\car{t}_p$ carries.
This structure will allow us to interpret $\cofree{p}$ as a category, whose objects will be $p$-trees and whose morphisms will be the vertices of each $p$-tree.
We could go ahead and describe this category right now, but as category theorists, let us show that the eraser and duplicator of $\cofree{p}$, as well as the comonoid laws that they satisfy, arise naturally from our construction of $\car{t}_p$ as the limit of \eqref{eqn.cofree_diagram}.

\subsubsection{The eraser of the cofree comonoid}

The eraser for a comonoid $\cofree{p}$ carried by $\car{t}_p$ should be a lens of the form $\car{t}_p\to\yon$.
Conveniently, since $\yon$ appears in \eqref{eqn.cofree_diagram}, its limit $\car{t}_p$ is already equipped with a canonical lens $\epsilon_p\colon\car{t}_p\to\yon$, as seen in \eqref{eqn.cofree_with_lim}.
This lens will turn out to be the eraser of the cofree comonoid on $p$.

The eraser picks out a direction at each position of the carrier to be the identity morphism on that object.
As each $\car{t}_p$-position is a tree $T\in\tr_p$, and each $\car{t}_p[T]$-direction is a vertex of $T$, the eraser $\epsilon_p$ should pick out a single vertex of every $p$-tree.
Even without looking at \eqref{eqn.cofree_with_lim}, you may already have your suspicions as to which vertex this will turn out to be, as there is, after all, only one sensible way to choose a canonical vertex that every $p$-tree is guaranteed to have: choose its root.
Indeed, \cref{prop.cofree_carrier_lim} tells us that $\epsilon_p\colon\car{t}_p\to\yon$ sends each $p$-tree $T\in\tr_p$ to its stage-$0$ pretree on positions, stripping away everything except for the single unlabeled root of $T$; then on-directions, $\epsilon_p$ picks out the unique height-$0$ vertex of $T$ in $\vtx_0(T)\ss\vtx(T)$, which is just its root.

So in the category $\cofree{p}$, where morphisms out of objects are vertices of trees, the identity morphism on a tree is its root---in fact, we will henceforth denote the root of a $p$-tree by $\id_T$ (so that $\vtx_0(T)=\{\id_T\}$).
Equivalently, we can identify $\id_T$ with the unique length-$0$ rooted path of $T$: the \emph{empty rooted path}, which starts and ends at the root.
The rest of the categorical structure of $\cofree{p}$ will be determined by its duplicator.

\subsubsection{The duplicator of the cofree comonoid}

The duplicator for a comonoid $\cofree{p}$ carried by $\car{t}_p$ should be a lens $\delta_p\colon\car{t}_p\to\car{t}_p\tri\car{t}_p$.
But before we can specify such a lens, we need to figure out what kind of polynomial $\car{t}_p\tri\car{t}_p$ is.

Here is where our work from \cref{subsec.comon.comp.prop.lim_left,subsec.comon.comp.prop.lim_right} comes in handy: since the diagram in \eqref{eqn.cofree_diagram} is connected, its limit $\car{t}_p$ is a connected limit, and we showed in \cref{thm.connected_limits} that $\tri$ preserves connected limits.
Therefore $\car{t}_p\tri\car{t}_p$ is itself the limit of some diagram, and a morphism to $\car{t}_p\tri\car{t}_p$ is just a cone over that diagram.

Which diagram is it?
First, we can use the fact that $\tri$ preserves connected limits on the left to expand $\car{t}_p\tri\car{t}_p$ as the limit of the following diagram, where we have applied the functor $-\tri\car{t}_p$ to the diagram from \eqref{eqn.cofree_diagram}:
\[
\begin{tikzcd}
	\yon\tri\car{t}_p \ar[d] &
	p\tri\car{t}_p \ar[d] &
	p\tripow2\tri\car{t}_p \ar[d] &
	p\tripow3\tri\car{t}_p \ar[d] &
	\cdots\\
	\1\tri\car{t}_p &
	p\tri\1\tri\car{t}_p \ar[l] &
	p\tripow2\tri\1\tri\car{t}_p \ar[l] &
	p\tripow3\tri\1\tri\car{t}_p \ar[l] &
	\cdots.\ar[l]
\end{tikzcd}
\]
But we have $p\tripow{n}\tri\1\tri\car{t}_p\iso p\tripow{n}\tri\1$, so we can simplify this diagram like so:
\begin{equation} \label{eqn.cofree_tri2_lim_expand_left}
\begin{tikzcd}
	\yon\tri\car{t}_p \ar[d] &
	p\tri\car{t}_p \ar[d] &
	p\tripow2\tri\car{t}_p \ar[d] &
	[10pt] p\tripow3\tri\car{t}_p \ar[d] &
	\cdots\\
	\1 &
	p\tri\1 \ar[l] &
	p\tripow2\tri\1 \ar[l] &
	p\tripow3\tri\1 \ar[l] &
	\cdots.\ar[l]
\end{tikzcd}
\end{equation}
(This works because according to \cref{prop.left_pres_lim}, $\tri$ actually preserves \emph{all} limits on the left---including the terminal object $\1$.)
So $\car{t}_p\tri\car{t}_p$ is the limit of \eqref{eqn.cofree_tri2_lim_expand_left}.

Then we use the fact that $\tri$ preserves connected limits on the right to expand each $p\tripow\ell\tri\car{t}_p$ in \eqref{eqn.cofree_tri2_lim_expand_left} as the limit of the following:
\begin{equation} \label{eqn.cofree_tri2_lim_expand_right}
\begin{tikzcd}
	p\tripow\ell\tri\yon \ar[d] &
	p\tripow\ell\tri p \ar[d] &
	p\tripow\ell\tri p\tripow2 \ar[d] & p\tripow\ell\tri p\tripow3 \ar[d] &
	\cdots\\
	p\tripow\ell\tri\1 &
	p\tripow\ell\tri p\tri\1 \ar[l] &
	p\tripow\ell\tri p\tripow2\tri\1 \ar[l] &
	p\tripow\ell\tri p\tripow3\tri\1 \ar[l] &
	\cdots.\ar[l]
\end{tikzcd}
\end{equation}
So the limit of \eqref{eqn.cofree_tri2_lim_expand_left} is the limit of a larger diagram, where we have ``plugged in'' a copy of \eqref{eqn.cofree_tri2_lim_expand_right} in place of each $p\tripow\ell\tri\car{t}_p$ that appears.

It's worth being a little careful, though, when we draw this diagram: each $p\tripow\ell\tri\car{t}_p$ in \eqref{eqn.cofree_tri2_lim_expand_left} appears with a lens to $p\tripow\ell\tri\1$, and we need to work out what arrow should go in its place.
The lens in question is given by applying $p\tripow\ell\tri-$ to the unique lens $\car{t}_p\to\1$.
But $\1$ actually shows up in the lower left corner of \eqref{eqn.cofree_diagram}, so the unique lens $\car{t}_p\to\1$ is just the projection from the limit of \eqref{eqn.cofree_diagram} to that $\1$.
Then once we apply the connected limit-preserving functor $p\tripow\ell\tri-$ to \eqref{eqn.cofree_diagram}, yielding \eqref{eqn.cofree_tri2_lim_expand_right}, we obtain the lens $p\tripow\ell\tri\car{t}_p\to p\tripow\ell\tri\1$ we desire as the projection from the limit of \eqref{eqn.cofree_tri2_lim_expand_right} to the $p\tripow\ell\tri\1$ in the lower left corner.
So if we want to replace each $p\tripow\ell\tri\car{t}_p$ in \eqref{eqn.cofree_tri2_lim_expand_left} with a copy of \eqref{eqn.cofree_tri2_lim_expand_right}, without changing the limit of the whole diagram, we should replace the arrow $p\tripow\ell\tri\car{t}_p\to p\tripow\ell\tri\1$ with an identity arrow from the $p\tripow\ell\tri\1$ in the lower left corner of \eqref{eqn.cofree_tri2_lim_expand_right} to the $p\tripow\ell\tri\1$ in \eqref{eqn.cofree_tri2_lim_expand_left}.
Of course, we can then collapse these identity arrows down without changing the limit, so the diagram we are left with should look like this:
\begin{equation} \label{eqn.cofree_tri2_diagram}
\begin{tikzcd}[row sep=small, column sep=tiny]
    p\tripow3 \ar[rd] && p\tripow3\tri p \ar[rd] && p\tripow3\tri p\tripow2 \ar[rd] && \cdots \\
    & p\tripow3\tri\1 \ar[dd] && p\tripow3\tri p\tri1 \ar[dd] && p\tripow3\tri p\tripow2\tri\1 \ar[dd] && \cdots \\
    p\tripow2 \ar[rd] && p\tripow2\tri p \ar[rd] && p\tripow2\tri p\tripow2 \ar[rd] && \cdots \\
    & p\tripow2\tri\1 \ar[dd] && p\tripow2\tri p\tri1 \ar[dd] && p\tripow2\tri p\tripow2\tri\1 \ar[dd] && \cdots \\
    p \ar[rd] && p\tri p \ar[rd] && p\tri p\tripow2 \ar[rd] && \cdots \\
    & p\tri\1 \ar[dd] && p\tri p\tri1 \ar[dd] && p\tri p\tripow2\tri\1 \ar[dd] && \cdots \\
    \yon \ar[rd] && p \ar[rd] && p\tripow2 \ar[rd] && \cdots \\
    & \1 && p\tri\1 \ar[ll] && p\tripow2\tri\1 \ar[ll] && \cdots.\ar[ll]
\end{tikzcd}
\end{equation}
Here the bottom row of \eqref{eqn.cofree_tri2_lim_expand_left} is still the bottom row of \eqref{eqn.cofree_tri2_diagram}, but in the place of each $p\tripow\ell\tri\car{t}_p$ in the top row, we have grafted in a copy of \eqref{eqn.cofree_tri2_lim_expand_right}.
Yet the limit of the diagram is preserved: the limit of \eqref{eqn.cofree_tri2_diagram} is still $\car{t}_p\tri\car{t}_p$.
In summary, for purely formal reasons, \cref{prop.left_pres_lim,thm.connected_limits} ensure that since the limit of \eqref{eqn.cofree_diagram} is $\car{t}_p$, the limit of \eqref{eqn.cofree_tri2_diagram} is $\car{t}_p\tri\car{t}_p$.

While \eqref{eqn.cofree_tri2_diagram} has become rather unwieldy to draw, it is easy to characterize: it is a diagram with a copy each of
\[
    p\tripow\ell\tri p\tripow{m} \qqand p\tripow\ell\tri p\tripow{m}\tri\1
\]
for every $\ell,m\in\nn$, with arrows
\begin{equation} \label{eqn.cofree_tri2_diagram_arr_diag}
    p\tripow\ell\tri p\tripow{m}\to p\tripow\ell\tri p\tripow{m}\tri\1
\end{equation}
between them; along with arrows
\begin{equation} \label{eqn.cofree_tri2_diagram_arr_vert}
    p\tripow\ell\tri p\tripow{(m+1)}\tri\1\to p\tripow\ell\tri p\tripow{m}\tri\1,
\end{equation}
drawn vertically in \eqref{eqn.cofree_tri2_diagram}; and
\begin{equation} \label{eqn.cofree_tri2_diagram_arr_horiz}
    p\tripow{\ell+1}\tri p\tripow0\tri\1\iso p\tripow{\ell+1}\tri\1\to p\tripow\ell\tri\1\iso p\tripow\ell\tri p\tripow0\tri\1,
\end{equation}
drawn horizontally in \eqref{eqn.cofree_tri2_diagram} along the bottom row.
Of course, we could write each $p\tripow\ell\tri p\tripow{m}$ as $p\tripow{(\ell+m)}$, but the notation $p\tripow\ell\tri p\tripow{m}$ helps us distinguish it as the object appearing $\ell$ rows above the bottom and $m$ columns to the right in \eqref{eqn.cofree_tri2_diagram}, in contrast with any other $p\tripow{\ell'}\tri p\tripow{m'}$ with $(\ell,m)\neq(\ell',m')$, even if $\ell+m=\ell'+m'$ guarantees that there are isomorphisms between these objects.

Nevertheless, it is these isomorphisms that induce a canonical lens $\car{t}_p\to\car{t}_p\tri\car{t}_p$, by giving a map from the diagram \eqref{eqn.cofree_diagram} to the diagram \eqref{eqn.cofree_tri2_diagram} as follows.
For all $\ell,m,n\in\nn$ with $n=\ell+m$, we have a canonical isomorphism $p\tripow{n}\To\iso p\tripow\ell\tri p\tripow{m}$ sending the $p\tripow{n}$ that appears in \eqref{eqn.cofree_diagram} to the $p\tripow\ell\tri p\tripow{m}$ that appears in \eqref{eqn.cofree_tri2_diagram}, and similarly sending $p\tripow{n}\tri\1$ in \eqref{eqn.cofree_diagram} to $p\tripow\ell\tri p\tripow{m}\tri\1$ in \eqref{eqn.cofree_tri2_diagram}.
Then all the arrows that appear in \eqref{eqn.cofree_tri2_diagram}---i.e.\ all the arrows in \eqref{eqn.cofree_tri2_diagram_arr_diag}, \eqref{eqn.cofree_tri2_diagram_arr_vert}, and \eqref{eqn.cofree_tri2_diagram_arr_horiz}---can be identified with arrows that appear in \eqref{eqn.cofree_diagram}, so everything commutes.
We therefore induce a lens from the limit $\car{t}_p$ of \eqref{eqn.cofree_diagram} to the limit $\car{t}_p\tri\car{t}_p$ of \eqref{eqn.cofree_tri2_diagram}, which we call $\delta_p\colon\car{t}_p\to\car{t}_p\tri\car{t}_p$.
This turns out to be the duplicator of $\cofree{p}$.

How does $\delta_p$ behave in terms of $p$-trees?
First, we characterize $\car{t}_p\tri\car{t}_p$ and its projections to each $p\tripow\ell\tri p\tripow{m}$ in \eqref{eqn.cofree_tri2_diagram}.
Concretely, we know that a $\car{t}_p\tri\car{t}_p$-position is just a $p$-tree $T\in\tr_p$ along with a $p$-tree $U(v)\in\tr_p$ associated with every vertex $v\in\vtx(T)$.
Then a direction at that position is a choice of vertex $v\in\vtx(T)$ and another vertex $w\in\vtx(U(v))$ of the $p$-tree $U(v)$ associated with $v$.
Each projection from $\car{t}_p\tri\car{t}_p$ to $p\tripow\ell\tri p\tripow{m}$ in \eqref{eqn.cofree_tri2_diagram} is then the composition product of the projections $\epsilon^{(\ell)}_p\colon\car{t}_p\to p\tripow\ell$ and $\epsilon^{(m)}_p\colon\car{t}_p\to p\tripow{m}$, which by \cref{ex.eps_n_polybox} we can draw in polyboxes like so:
\[
\begin{tikzpicture}[polybox, mapstos]
	\node[poly, dom, "$\car{t}_p$" below] (p) {$v$\at$T$};
        \node[left=0pt of p_pos] {$\tr_p$};
        \node[left=0pt of p_dir] {$\vtx(-)$};
	\node[poly, dom, above=.8 of p, "$\car{t}_p$" above] (p') {$w$\at$U_v$};
        \node[left=0pt of p'_pos] {$\tr_p$};
        \node[left=0pt of p'_dir] {$\vtx(-)$};
	    
	\node[poly, cod, right=of p, "$p\tripow\ell$" below] (q) {$v$\at$\pi^{(\ell)}T$};
	    \node[right=0pt of q_pos] {$p\tripow\ell(\1)$};
        \node[right=0pt of q_dir] {$\vtx_\ell(-)$};
	\node[poly, cod, above=.8 of q, "$p\tripow{m}$" above] (q') {$w$\at$\pi^{(m)}U_v$};
	    \node[right=0pt of q'_pos] {$p\tripow{m}(\1)$};
        \node[right=0pt of q'_dir] {$\vtx_m(-)$};
	
	\draw (p_pos) -- node[below] {} (q_pos);
	\draw (q_dir) -- node[above] {} (p_dir);
	\draw (p'_pos) -- node[below] {} (q'_pos);
	\draw (q'_dir) -- node[above] {} (p'_dir);
\end{tikzpicture}
\]
On positions, $\epsilon^{(\ell)}_p\tri\epsilon^{(m)}_p$ sends the $p$-tree $T$ to its stage-$\ell$ pretree $\pi^{(\ell)}T$, and it sends each $p$-tree $U_v$ associated to a height-$\ell$ vertex $v\in\vtx_\ell(T)$ to its stage-$m$ pretree $\pi^{(m)}U_v$, to be $p\tripow{m}$-pretree associated with the height-$\ell$ leaf $v$ of $\pi^{(m)}T$.
Equivalently, this specifies a $p\tripow{(\ell+m)}$-pretree on the right: its bottom $\ell$ levels coincide with the bottom $\ell$ levels of $T$, and its top $m$ levels coincide with the bottom $m$ levels of the $U_v$'s for $v\in\vtx_\ell(T)$.
Then on directions, $\epsilon^{(\ell)}_p\tri\epsilon^{(m)}_p$ is the canonical inclusion of vertices $\vtx_\ell(T)\inj\vtx(T)$ sending $v\mapsto v$, followed by the canonical inclusion of vertices $\vtx_m(U_v)\inj\vtx(U_v)$.
These lenses comprise the universal cone over \eqref{eqn.cofree_tri2_diagram}.

Meanwhile, the other cone we formed over \eqref{eqn.cofree_tri2_diagram} is comprised of lenses of the form $\epsilon^{(\ell+m)}_p\colon\car{t}_p\to p\tripow{(\ell+m)}\iso p\tripow\ell\tri p\tripow{m}$, each of which should factor through $\car{t}_p\tri\car{t}_p$, as depicted in the following commutative diagram:
\begin{equation} \label{eqn.delta_p_tri_epsilons}
\begin{tikzcd}[row sep=large]
    \car{t}_p \ar[r,dashed,"\delta_p"] \ar[dr,"\epsilon^{(\ell+m)}_p"'] & \car{t}_p\tri\car{t}_p \ar[d,"\epsilon^{(\ell)}_p\:\tri\:\epsilon^{(m)}_p"] \\
    & p\tripow{\ell}\tri p\tripow{m}.
\end{tikzcd}
\end{equation}
Indeed, by the universal property of $\car{t}_p\tri\car{t}_p$, our $\delta_p$ is the unique lens for which the above diagram commutes for all $\ell,m\in\nn$.
We will use the equation given by the commutativity of \eqref{eqn.delta_p_tri_epsilons} repeatedly in what follows, whenever we work with $\delta_p$.

Expressing \eqref{eqn.delta_p_tri_epsilons} as an equation of polyboxes, using our usual labels for the arrows of the duplicator $\delta_p$ on the left and our depiction of the projection $\epsilon^{(\ell+m)}_p\colon\car{t}_p\to p\tripow\ell\tri p\tripow{m}$ from \cref{ex.eps_n_polybox} on the right, we have
\[
\begin{tikzpicture}
	\node (1) {
  \begin{tikzpicture}[polybox, mapstos]
	\node[poly, dom, "$\car{t}_p$" left] (r) {$v\then w$\at$T$};
	\node[poly, right=1.8 of r.south, yshift=-2.5ex, "$\car{t}_p$" below] (p) {$v$\at$T$};
	\node[poly, above=.8 of p, "$\car{t}_p$" above] (p') {$w$\at$\cod v$};
	\node[poly, cod, right=of p, "$p\tripow\ell$" right] (q) {$v$\at$\pi^{(\ell)}T$};
	\node[poly, cod, above=.75 of q, "$p\tripow{m}$" right] (q') {$w$\at$\pi^{(m)}(\cod v)$};
	
	\draw (p_pos) -- node[below] {} (q_pos);
	\draw (q_dir) -- node[above] {} (p_dir);
	\draw (p'_pos) -- node[below] {} (q'_pos);
	\draw (q'_dir) -- node[above] {} (p'_dir);	
	\draw[double, -] (r_pos) to[first] node[below] {} (p_pos);
	\draw (p_dir) to[climb] node[right] {$\cod$} (p'_pos);
	\draw (p'_dir) to[last] node[above] {$\then$} (r_dir);
  \end{tikzpicture}
	};
	\node[right=1.8 of 1] (2) {
  \begin{tikzpicture}[polybox, mapstos]
  	\node[poly, dom, "$\car{t}_p$" left] (r) {$v\leadsto w$\at$T$};
  	\node[poly, cod, right=1.8 of r.south, yshift=-1ex, "$p\tripow\ell$" right] (q) {$v$\at$\pi^{(\ell)}T$};
  	\node[poly, cod, above=of q, "$p\tripow{m}$" right] (q') {$w$\at$\pi^{(m)}T(v)$};
  	
  	\draw (r_pos) to[first] node[below] {} (q_pos);
  	\draw (q_dir) to[climb] node[right] {} (q'_pos);
  	\draw (q'_dir) to[last] node[above] {} (r_dir);
  \end{tikzpicture}
	};
	\node at ($(1.east)!.5!(2.west)$) {=};
\end{tikzpicture}
\]
Recall from \cref{ex.eps_n_polybox} that $T(v)$ denotes the $p$-tree equal to the subtree of $T$ rooted at $v\in\vtx(T)$, while $v\leadsto w\in\vtx(T)$ for $w\in\vtx(T(v))$ is the descendent of $v$ that coincides with $w$ when $T(v)$ is identified with the subtree of $T$ rooted at $v$.
Equivalently, we can identify $v\in\vtx(T)$ with the rooted path in $T$ that ends at the vertex $v$ and $w\in\vtx(T(v))$ with the rooted path of $T(v)$ that ends at the vertex $w$, so $v\leadsto w$ becomes the rooted path in $T$ obtained by concatenating $v$ and $w$.
Then for this equality to hold over all $\ell,m\in\nn$, we want $\cod v\coloneqq T(v)$ and $v\then w\coloneqq v\leadsto w$; in fact, $\cod v$ and $v\then w$ will henceforth be our preferred notation for $T(v)$ and $v\leadsto w$.

\subsubsection{Verifying the comonoid laws}

Putting together our constructions of the carrier, the eraser, and the duplicator of the $\cofree{p}$ yields the following result.
\begin{proposition} \label{prop.cofree_as_cat}
As defined above, $\left(\car{t}_p,\epsilon_p,\delta_p\right)$ is a polynomial comonoid corresponding to a category $\cofree{p}$ characterized as follows.
\begin{itemize}
    \item An object in $\cofree{p}$ is a \textit{$p$-tree} in $T\in\tr_p$.
    \item A morphism emanating from $T$ is a \textit{rooted path} in $T$; its codomain is the $p$-subtree rooted at the end of the path.
    \item The identity morphism on $T$ is its empty empty rooted path:
    \item Composition is given by concatenating rooted paths: given a rooted path $v$ in $T$ and a rooted path $w$ in $\cod v$, the $p$-subtree rooted at the end of $v$, we identify $w$ with the corresponding path in $T$ that starts where $v$ ends, then concatenate the two paths in $T$ to obtain the composite morphism $v\then w$, another rooted path in $T$.
\end{itemize}
\end{proposition}
\begin{proof}
We have already shown how to construct the given carrier, eraser, and duplicator purely diagrammatically, and we have given them concrete interpretations in terms of $p$-trees, their vertices, and their $p$-subtrees.
So it remains to verify that the category laws hold for $\cofree{p}$, or equivalently that the comonoid laws hold for $\left(\car{t}_p,\epsilon_p,\delta_p\right)$.
Again, our argument will be purely formal, although it is not too hard to see that our concrete characterization above in terms of $p$-trees satisfies the laws for a category.

First, we verify the left erasure law: that
\[
\begin{tikzcd}
    \yon\tri\car{t}_p & \car{t}_p \ar[l,equals] \ar[d, "\delta_p"] \\
    & \car{t}_p\tri\car{t}_p \ar[ul, "\epsilon_p\:\tri\:\car{t}_p"]
\end{tikzcd}
\]
commutes.
We know the lens $\epsilon_p\tri\car{t}_p\colon\car{t}_p\tri\car{t}_p\to\yon\tri\car{t}_p$ is characterized by its components $\epsilon_p\tri\epsilon^{(n)}_p\colon\car{t}_p\tri\car{t}_p\to p\tripow0\tri p\tripow{n}$, a projection out of the limit $\car{t}_p\tri\car{t}_p$, for all $n\in\nn$.
Then by our construction of $\delta_p$, each composite $\delta_p\then\left(\epsilon_p\tri\epsilon^{(n)}_p\right)\colon\car{t}_p\to p\tripow0\tri p\tripow{n}$ is the component of $\delta_p$ equal to $\epsilon^{(n)}_p=\epsilon^{(0+n)}_p\colon\car{t}_p\to p\tripow0\tri p\tripow{n}\iso p\tripow{n}$ (this is just the commutativity of \eqref{eqn.delta_p_tri_epsilons} in the case of $(\ell,m)=(0,n)$).
Together, these characterize the composite lens $\delta_p\then\left(\epsilon_p\tri\car{t}_p\right)\colon\car{t}_p\to\yon\tri\car{t}_p\iso\car{t}_p$ as the lens whose components are the projections $\epsilon^{(n)}_p\colon\car{t}_p\to p\tripow{n}$ from the limit.
It follows from the universal property of $\car{t}_p$ that $\delta_p\then\left(\epsilon_p\tri\car{t}_p\right)$ can only be the identity lens on $\car{t}_p$.
Hence the left erasure law holds.

The right erasure law, that
\[
\begin{tikzcd}
    \car{t}_p \ar[r,equals] \ar[d, "\delta_p"'] & \car{t}_p\tri\yon \\
    \car{t}_p\tri\car{t}_p \ar[ur, "\car{t}_p\:\tri\:\epsilon_p"']
\end{tikzcd}
\]
commutes, follows similarly: the composite $\delta_p\then\left(\car{t}_p\tri\epsilon_p\right)$ is characterized by its components over $n\in\nn$ of the form $\delta_p\then\left(\epsilon^{(n)}_p\tri\epsilon_p\right)\colon\car{t}_p\to p\tripow{n}\tri p\tripow0$, which we know by \eqref{eqn.delta_p_tri_epsilons} is equal to $\epsilon^{(n+0)}_p=\epsilon^{(n)}_p$, the projection out of the limit $\car{t}_p$.
It follows from the universal property of this limit that $\delta_p\then\left(\car{t}_p\tri\epsilon_p\right)$ must be the identity lens on $\car{t}_p$.

Finally, we check the coassociative law: that
\[
\begin{tikzcd}[column sep=large]
	\car{t}_p\ar[r, "\delta_p"]\ar[d, "\delta_p"']&
	\car{t}_p\tri\car{t}_p\ar[d, "\car{t}_p\:\tri\:\delta_p"]\\
	\car{t}_p\tri\car{t}_p\ar[r, "\delta_p\:\tri\:\car{t}_p"']&
	\car{t}_p\tri\car{t}_p\tri\car{t}_p,
\end{tikzcd}
\]
commutes.
Because $\tri$ preserves connected limits, we can write $\car{t}_p\tri\car{t}_p\tri\car{t}_p$ as a limit the way we did with $\car{t}_p\tri\car{t}_p$: it is the limit of diagram consisting of arrows
\[
    p\tripow{i}\tri p\tripow{j}\tri p\tripow{k}\to p\tripow{i}\tri p\tripow{j}\tri p\tripow{k}\tri\1
\]
for each $i,j,k\in\nn$, with additional arrows between the position-sets.
So a lens to $\car{t}_p\tri\car{t}_p\tri\car{t}_p$, such as those in the square above, is uniquely determined by its components to $p\tripow{i}\tri p\tripow{j}\tri p\tripow{k}$ for all $i,j,k\in\nn$, obtained by composing it with the projections $\epsilon^{(i)}_p\tri\epsilon^{(j)}_p\tri\epsilon^{(k)}_p$ out of the limit.
Then by \eqref{eqn.delta_p_tri_epsilons},
\begin{align*}
    \delta_p\then\left(\car{t}_p\tri\delta_p\right)\then\left(\epsilon^{(i)}_p\tri\epsilon^{(j)}_p\tri\epsilon^{(k)}_p\right) &=
    \delta_p\then\left(\epsilon^{(i)}_p\tri\left(\delta_p\then\left(\epsilon^{(j)}_p\tri\epsilon^{(k)}_p\right)\right)\right) \\ &=
    \delta_p\then\left(\epsilon^{(i)}_p\tri\epsilon^{(j+k)}_p\right) \tag*{\eqref{eqn.delta_p_tri_epsilons}} \\ &=
    \epsilon^{(i+j+k)}_p \tag*{\eqref{eqn.delta_p_tri_epsilons}} \\ &=
    \delta_p\then\left(\epsilon^{(i+j)}_p\tri\epsilon^{(k)}_p\right) \tag*{\eqref{eqn.delta_p_tri_epsilons}} \\ &=
    \delta_p\then\left(\left(\delta_p\then\left(\epsilon^{(i)}_p\tri\epsilon^{(j)}_p\right)\right)\tri\epsilon^{(k)}_p\right) \tag*{\eqref{eqn.delta_p_tri_epsilons}} \\ &=
    \delta_p\then\left(\delta_p\tri\car{t}_p\right)\then\left(\epsilon^{(i)}_p\tri\epsilon^{(j)}_p\tri\epsilon^{(k)}_p\right).
\end{align*}
for all $i,j,k\in\nn$.
So by the universal property of $\car{t}_p\tri\car{t}_p\tri\car{t}_p$, coassociativity holds.
\end{proof}

We call the category $\cofree{p}$ corresponding to the comonoid $\left(\car{t}_p,\epsilon_p,\delta_p\right)$ the \emph{category of $p$-trees}, the \emph{category of trees on $p$}, or the \emph{$p$-tree category}.

\begin{example}[The category of $p$-trees: states and transitions for (co)free]
Let's step back and think about how $p$-tree categories relate to the original polynomial $p$ from the perspective of the states and transitions of dynamical systems.
Before we build any trees or categories out of it, a polynomial $p$ is just an arena of positions and directions.
The directions emerge from positions, but don't point to anywhere in particular.
If we want to interpret the positions of $p$ as states and the directions of $p$ as composable transitions, first we would need to point the directions to other positions by assigning them codomains.
There are many ways to do this, but we would like to do so ``freely,'' without having to make any choices along the way that would bias us one way or another, so as to give a canonical way to interpret $p$ as a category.

So to avoid making choices, rather than fixing a codomain for each direction, we allow every possible direction to point to every possible position once.
But a single direction of any one position cannot point to multiple positions, which is when we need to make several copies of each position: at least one copy for every possible combination of codomains that can be assigned to its directions.
This is how we get from $p$ to $p\tripow2$: the $p\tripow2$-pretrees represent all the ways we could assign codomains to the directions in $p$.
Essentially, we have freely refined our positions into more specific states to account for everywhere their directions could lead.
Each $p\tripow2$-pretree still remembers which $p\tripow1$-pretree it grew from, giving us our canonical trimming operation $p\tripow2(\1)\to p\tripow1(\1)$.

Yet even that is not enough: sure, we've assigned codomains to the directions of $p$ in every possible way, but now that we're building a category, we want our directions to be composable transitions.
So each pair of composable directions of $p$each length-$2$ rooted path of the $p\tripow2$-pretreesis now a possible transition as well, another morphism in our category.
To keep everything canonical, we still want to avoid making any actual choices; we can't simply say that two directions of $p$ compose to a third direction of $p$ that we already have.
Each pair of composable directions must be an entirely new morphism---and every new morphism needs a codomain.

You can tell where this is going.
To avoid actually choosing codomains for the new morphisms, we need to refine our $p\tripow2$-pretrees by making copies of them to account for every possibility, building $p\tripow3$-pretrees as a result.
Then their length-$3$ rooted paths are new morphisms, too, and they need new codomains, and so forth, ad infinitum.
Indeed, this process cannot terminate in a finite number of steps, but that's okay---we can take the limit, yielding the ultimate free refinement of positions into states and free composites of directions as transitions.

This is where \eqref{eqn.cofree_diagram} comes from; it captures the infinite process of turning sequences of directions into morphisms by giving them codomains in every possible way, then dealing with the longer sequences of directions that emerge as a result.
Note that we also need to account for the fact that every object needs an identity; to avoid making a choice, we don't set it to be any direction or composite of multiple directions of $p$, reserving it instead for the empty sequence of directions that every pretree has.
Then the limit $\car{t}_p$ of \eqref{eqn.cofree_diagram} is all we need: the $p$-trees are states representing every possible way that sequences of directions emerging from a $p$-position can lead to other $p$-positions, and the rooted paths of each $p$-tree are transitions accounting for every finite sequence of composable directions from the corresponding state.

Since composites were freely generated, directions and thus entire rooted paths compose by concatenation---making the empty rooted path the correct identity.
And the codomain is whatever the direction at the end of a rooted path has been freely assigned to point to---not just the $p$-position there but the whole $p$-subtree, an entire state representing all the sequences of directions one could take and the positions to which they lead, starting from the end of the path just followed.
This gives the comonoid structure on $\car{t}_p$, completing the cofree construction of the category of $p$-trees $\cofree{p}$.
\end{example}

Soon we will prove that $\cofree{p}$ really is the cofree category on $p$, but first we give some examples to make all this concrete.

\subsubsection{Examples of $p$-tree categories}

In what follows, we will freely switch between the morphisms-as-vertices and the morphisms-as-rooted-paths perspectives of $p$-tree categories given in \cref{prop.cofree_as_cat} whenever convenient.

\begin{example}[The category of $\1$-trees]
Let's start by taking $p\coloneqq\1$.
In \cref{exc.p_tree_polys} \cref{exc.p_tree_polys.1}, we showed that there is a unique $\1$-tree: a tree with only $1$ vertex, its root.
So $\car{t}_\1\iso\yon$ is the carrier of the category of $\1$-trees $\cofree\1$.

Up to isomorphism, there is only one category carried by $\yon$: the terminal category with $1$ object and no morphisms aside from the $1$ identity.
When we think of this as the category of $\1$-trees, we can characterize it as follows.
\begin{itemize}
    \item The $1$ object is the tree with $1$ vertex: call the tree $\bullet$, because that's what it looks like.
    \item The $1$ morphism $\bullet\to\_$ is the $1$ vertex of $\bullet$, its root.
    After all, there are no directions of $\1$ to freely compose, so the only morphism generated is the identity.
    Since the $\1$-subtree of $\bullet$ rooted as its root is just the entire $\1$-tree $\bullet$, the codomain of this morphism is still $\bullet$, which makes sense---it's the only object we have.
    \item The identity morphism $\id_\bullet\colon\bullet\to\bullet$ is the root of $\bullet$.
    This is the same morphism we just mentioned.
    Equivalently, it is the empty rooted path.
    \item The composite morphism $\id_\bullet\then\id_\bullet=\id_\bullet\then\id_{\cod(\id_\bullet)}\colon\bullet\to\_$ is obtained by concatenating the empty rooted path $\id_\bullet$ of $\bullet$ with the empty rooted path $\id_{\cod(\id_\bullet)}$ of $\cod(\id_\bullet)$, which is again just the empty rooted path of $\bullet$.
    Hence $\id_\bullet\then\id_{\cod\id_\bullet}=\id_\bullet$, as expected---it's the only morphism we have.
\end{itemize}
This is certainly too trivial an example to say much about, but it demonstrates how we can interpret the category carried by $\yon$ as the category of $p$-trees for $p\coloneqq\1$.
Moreover, it helps us see concretely why taking the identity to be the root gives it the right codomain and compositional behavior.

\end{example}

\begin{exercise}[The category of trees on a constant]
Let $B$ be a set, viewed as a constant polynomial.
\begin{enumerate}
	\item What is the polynomial $\car{t}_B$? 
	\item Characterize the $B$-tree category $\cofree{B}$.
\qedhere
\end{enumerate}
\begin{solution}
\begin{enumerate}
    \item We compute $\car{t}_B$ as follows.
    To select a $B$-tree, we must select a position from $B$.
    Then we are done, because there are no directions.
    So every $B$-tree consists of $1$ vertex labeled with an element of $B$.
    Hence the set of $B$-trees $\car{t}_B(\1)=\tr_B$ is in bijection with $B$ itself, yielding $\car{t}_B\iso B\yon$.
    (We could have also applied \cref{exc.p_tree_polys} \cref{exc.p_tree_polys.monomial} in the case of $A=\0$, yielding $\car{t}_{B\yon^\0}\iso B^{\lst(\0)}\yon^{\lst(\0)}\iso B\yon$, as $\lst(\0)\iso\1+\0^\1+\0^\2+\cdots\iso\1$---the empty sequence is the only sequence with elements in $\0$.)
    \item We characterize the $B$-tree category $\cofree{B}$ as follows.
    We saw in \cref{exc.linear_poly_comon,exc.linear_poly_cat} that (up to isomorphism) there is a unique comonoid structure on $B\yon$, corresponding to the discrete category on $B$.
    So $\cofree{B}$ must be isomorphic to the discrete category on $B$.
    In the language of $B$-trees, the objects of $\cofree{B}$ are trees with exactly $1$ vertex, labeled with an element of $B$.
    Each tree has an identity morphism, its root; but there are no vertices aside from the root, so there are no morphisms aside from the identities.
    In particular, the only $B$-subtree of any one $B$-tree is the entire $B$-tree itself, so there are no morphisms from one $B$-tree to a different $B$-tree.
    So the category of $B$-trees can indeed be identified with the discrete category on $B$.
\end{enumerate}
\end{solution}
\end{exercise}

\begin{example}[The category of $\yon$-trees] \label{ex.yon_tree_nn}
Now consider $p\coloneqq\yon$.
In \cref{exc.p_tree_polys} \cref{exc.p_tree_polys.unary}, we showed that there is a unique $\yon$-tree: a single ray extending from the root in which every vertex has exactly $1$ child, so that there is exactly $1$ height-$n$ vertex---and $1$ length-$n$ rooted path---for every $n\in\nn$.
Then $\car{t}_\yon\iso\yon^\nn$ is the carrier of the category of $\yon$-trees $\cofree\yon$.
In fact, we can identify the set of rooted paths of this $\yon$-tree with $\nn$, so that $n\in\nn$ is the $\yon$-tree's unique length-$n$ rooted path.

We know from \cref{ex.monoids} that comonoids with representable carriers correspond to $1$-object categories, which can be identified with monoids.
In particular, a comonoid structure on $\yon^\nn$ corresponds to a monoid structure on $\nn$.
There is more than one monoid structure on $\nn$, though, so which one corresponds to the category $\cofree\yon$?

We can characterize $\cofree\yon$ in terms of $\yon$-trees as follows.
\begin{itemize}
    \item The $1$ object is the unique $\yon$-tree, a single ray: call it $\uparrow$.
    Here is a picture of this ray, to help you visualize its vertices, rooted paths, and subtrees:
    \begin{gather*}
    \vdots\\
    \begin{tikzpicture}[trees]
    	\node {$\bullet$}
    		child {node {$\bullet$}
    		    child {node {$\bullet$}
    		        child {node {$\bullet$}
    		            child {node {$\vphantom\bullet$}}
    		        }
    	        }
    	    };
    \end{tikzpicture}
    \end{gather*}
    \item The morphisms are the rooted paths of $\uparrow$; they comprise the set $\nn$, where each $n\in\nn$ is the unique rooted path of $\uparrow$ of length $n$.
    Each rooted path represents the free composite of $n$ copies of the sole direction of $\yon$.
    Since $\uparrow$ is an infinite ray, the $\yon$-subtree of $\uparrow$ rooted at any of its vertices is still just a copy of $\uparrow$.
    So the codomain of each morphism is still $\uparrow$, which makes sense---it's the only object we have.
    \item The identity morphism $\id_\uparrow\colon{\uparrow}\to{\uparrow}$ is the empty rooted path, which has length $0$; so $\id_\uparrow=0$.
    In the corresponding monoid structure on $\nn$, the element $0\in\nn$ must then be the unit.
    \item The composite morphism $m\then n\colon{\uparrow}\to{\uparrow}$ for $m,n\in\nn$ is obtained by concatenating $m$, i.e.\ the length-$m$ rooted path of $\uparrow$, with $n$, i.e.\ the length-$n$ rooted path of $\uparrow$, translating the latter path so that it begins where the former path ends.
    The result is then the rooted path of $\uparrow$ of length $m+n$; so $m\then n=m+n$.
    In the corresponding monoid structure on $\nn$, the binary operation must then be given by addition.
\end{itemize}
Hence $\cofree{\yon}$ is the monoid $(\nn,0,+)$ viewed as a $1$-object category.
\end{example}

% \begin{exercise}[Category of trees on linear polynomials]
% Let $B$ be a set, so that $B\yon$ is a linear polynomial.
% \begin{enumerate}
% 	\item What is the polynomial $\car{t}_{B\yon}$? 
% 	\item Characterize the $B\yon$-tree category $\cofree{B\yon}$.
% \qedhere
% \end{enumerate}
% \begin{solution}
% \begin{enumerate}
%     \item **
%     \item **
% \end{enumerate}
% \end{solution}
% \end{exercise}


\begin{example}[$B\yon$-trees are $B$-streams]\label{ex.streams_cofree}
Let $B$ be a set, and consider $p\coloneqq B\yon$.
Generalizing \cref{exc.p_tree_polys} \cref{exc.p_tree_polys.2_label_ray} for $B$ instead of $\2$, or applying \cref{exc.p_tree_polys} \cref{exc.p_tree_polys.monomial} for the case of $A\coloneqq\1$, we can deduce that a $B\yon$-tree consists of a single ray for which every vertex is given a label from $B$.
So the vertices of a $B\yon$-tree are in bijection with $\nn$, and $B\yon$-trees are in bijection with functions $\nn\to B$ assigning each vertex a label.
Hence $\car{t}_{B\yon}\iso B^\nn\yon^\nn$ is the carrier of the category of $B\yon$-trees $\cofree{B\yon}$.
As in \cref{ex.yon_tree_nn}, we identify the set of rooted paths of a given $B\yon$-tree with $\nn$, so that $n\in\nn$ is the $B\yon$-tree's unique length-$n$ rooted path.

In fact, we have already seen the category $\cofree{B\yon}$ once before: it is the category of $B$-streams from \cref{ex.streams_category}.

\begin{itemize}
    \item Recall that a $B$-stream is an element of $B^\nn$ interpreted as a countable sequence of elements $b_n\in B$ for $n\in\nn$, written like so:
    \[
        \ol{b}\coloneqq(b_0\to b_1\to b_2\to b_3\to\cdots).
    \]
    This is just a $B\yon$-tree lying on its side!
    Each arrow is a copy of the sole direction at each position of $B\yon$, pointing to one of the positions in $B$ for that direction to lead to next.
    \item Given a $B$-stream $\ol{b}\in B^\nn$ above, recall that a morphism out of $\ol{b}$ is a natural number $n\in\nn$, and its codomain is the substream of $B$ starting at $b_n$:
    \[
        \cod(\ol{b}\To{n}\_)=(b_n\to b_{n+1}\to b_{n+2}\to b_{n+3}\to\cdots).
    \]
    This coincides with how we view morphisms as rooted paths and codomains as subtrees rooted at the end of those paths in the category of $B\yon$-trees.
    \item Whether we view $\ol{b}$ as a $B$-stream or a $B\yon$-tree, its identity morphism $\id_{\ol{b}}\colon\ol{b}\to\ol{b}$ corresponds to $0\in\nn$; from the latter perspective, it is the length-$0$ path from the root to itself.
    \item Whether we view $\ol{b}$ as a $B$-stream or a $B\yon$-tree, composition is given by addition; from the latter perspective, concatenating a length-$m$ rooted path with a length-$n$ path yields a length-$(m+n)$ rooted path.
\end{itemize}
\end{example}

\begin{example}[The category of $\nn$-labeled binary trees] \label{ex.nn_labeled_binary_trees}
Consider $p\coloneqq\nn\yon^\2$.
By \cref{exc.p_tree_polys} \cref{exc.p_tree_polys.monomial}, or \cref{exc.n_ary_trees} \cref{exc.n_ary_trees.l_labeled} in the case of $L\coloneqq\nn$ and $\ord{n}\coloneqq\2$, an $\nn\yon^\2$-tree is an infinite binary tree with vertices labeled by elements of $\nn$.
Here's how such an $\nn\yon^\2$-tree might start:
\[
\begin{tikzpicture}[trees,
  level 1/.style={sibling distance=10mm},
  level 2/.style={sibling distance=5mm},
  level 3/.style={sibling distance=2.5mm}]
	\node {$17$}
		child {node {$3$}
			child {node {$0$}
				child
				child
			}
			child {node {$3$}
				child
				child
			}
		}
		child {node {$1$}
			child {node {$92$}
				child
				child
			}
			child {node {$6$}
				child
				child
			}
		};
\end{tikzpicture}
\]
We can characterize the category $\cofree{\nn\yon^\2}$ as follows.
\begin{itemize}
    \item The objects are $\nn$-labeled binary trees from the set $\nn^{\lst(\2)}$.
    \item A morphism out of an $\nn$-labeled binary tree is a binary sequence: a finite list of directions in $\2$, whose elements could be interpreted as ``left'' and ``right,'' thus uniquely specifying a rooted path in a binary tree.
    They comprise the set $\lst(\2)$.
    The codomain of each rooted path is the $\nn$-labeled binary subtree rooted at the end of the path.
    \item The identity morphism on a given $\nn$-labeled binary tree is its empty rooted path.
    \item The composite of two binary sequences is obtained by concatenation.
\end{itemize}
\end{example}

\begin{exercise}[The category of $B$-labeled $A$-ary trees]
Characterize the $B\yon^A$-tree category $\cofree{B\yon^A}$.
\begin{solution}
We characterize $\cofree{B\yon^A}$, following \cref{ex.nn_labeled_binary_trees}.
\begin{itemize}
    \item The objects are $B\yon^A$-trees.
    By \cref{exc.p_tree_polys} \cref{exc.p_tree_polys.monomial}, or \cref{exc.n_ary_trees} \cref{exc.n_ary_trees.l_labeled} with $L\coloneqq B$ and $\ord{n}$ replaced with an arbitrary set $A$, a $B\yon^A$-tree is a (infinite, assuming $|A|,|B|>0$) tree whose every vertex is labeled by an element of $B$ and whose children are in bijection with $A$.
    We can call these $B$-labeled $A$-ary trees; they are in bijection with the set $B^{\lst(A)}$.
    \item A morphism out of a $B$-labeled $A$-ary tree is a finite list of directions in $A$, or a rooted path in an $A$-ary tree.
    They comprise the set $\lst(A)$.
    The codomain of each rooted path is the $B$-labeled $A$-ary subtree rooted at the end of the path.
    \item The identity morphism on a given $B$-labeled $A$-ary tree is its empty rooted path.
    \item The composite of two lists in $A$ is obtained by concatenation.
\end{itemize}
\end{solution}
\end{exercise}

\begin{exercise}
Characterize the $\left(\yon+\1\right)$-tree category $\cofree{\yon+\1}$.
\begin{solution}
We characterize $\cofree{\yon+\1}$ as follows.
\begin{itemize}
    \item The objects are $(\yon+\1)$-trees.
    By \cref{exc.p_tree_polys} \cref{exc.p_tree_polys.maybe_unary}, a $(\yon+\1)$-tree is either a single length-$n$ path for some $n\in\nn$, which we denote by $[n]$, or a ray, which we denote by $[\infty]$.
    So the set of objects is $\tr_{\yon+\1}=\{[n]\mid n\in\nn\cup\{\infty\}\}\iso\nn\cup\{\infty\}$.
    \item A finite $(\yon+\1)$-tree $[n]$ for $n\in\nn$ has $n+1$ rooted paths: $1$ each of length $0$ through $n$, inclusive.
    So a morphism out of $[n]$ can be identified with an element of the set $\{0,\ldots,n\}$.
    
    Meanwhile, the infinite $(\yon+\1)$-tree $[\infty]$, a ray, has exactly $1$ rooted path of every length $\ell\in\nn$.
    So a morphism out of $[\infty]$ can be identified with an element of the set $\nn$.
    Every $(\yon+\1)$-subtree of the ray is still a ray, so the codomain of each of these morphisms is still $[\infty]$.
    \item The identity morphism on a given $B$-labeled $A$-ary tree is its empty rooted path.
    \item The composite of two lists in $A$ is obtained by concatenation.
\end{itemize}
\end{solution}
\end{exercise}

\begin{exercise}
Let $p\coloneqq \{a,b,c,\ldots,z,\text{\textvisiblespace}\}\yon+\1$.
\begin{enumerate}
	\item Describe the objects of the cofree category $\cofree{p}$, and draw one.
	\item For a given such object, describe the emanating morphisms.
	\item Describe how to take the codomain of a morphism.
\qedhere
\end{enumerate}
\begin{solution}
\begin{enumerate}
    \item **
    \item **
    \item **
\end{enumerate}
\end{solution}
\end{exercise}

\begin{exercise}
Let $p\coloneqq\{\bul[red],\bul[blue]\}\yon^\2+\{\bul[dgreen]\}\yon+\{\bul[dyellow]\}$ as in \cref{ex.imagining_trees}.
\begin{enumerate}
	\item Choose an object $t\in \tr_p$, i.e.\ a tree in $p$, and draw a finite approximation of it (say four layers).
	\item What is the identity morphism at $t$?
	\item Choose a nonidentity morphism $f$ emanating from $t$ and draw it.
	\item What is the codomain of $f$? Draw a finite approximation of it.
	\item Choose a morphism emanating from the codomain of $f$ and draw it.
	\item What is the composite of your two morphisms? Draw it on $t$.
\qedhere
\end{enumerate}
\begin{solution}
\begin{enumerate}
    \item **
    \item **
    \item **
    \item **
    \item **
    \item **
\end{enumerate}
\end{solution}
\end{exercise}


\begin{exercise}
Let $p$ be a polynomial, let $Q\coloneqq\{q\in\qq\mid q\geq 0\}$ and consider the monoid $\yon^Q$ of nonnegative rational numbers under addition. Is it true that any cofunctor $\varphi\colon\cofree{p}\cof\yon^\qq$ is constant, i.e.\ that it factors as
\[
\cofree{p}\cof\yon\cof\yon^\qq? \qedhere
\]
\begin{solution}
Take $p\coloneqq\2\yon$, and consider the object $x\in\cofree{p}(\1)$ given by the stream
\[
x\coloneqq(2\,12\,112\,1112\,11112\,111112\ldots)
\]
(with spaces only for readability); note that every morphism emanating from $x$ has a different codomain. We need to give $\varphi^\sharp_i(q)$ for every $i\in\cofree{p}(\1)$ and $q\geq 0$. Define
\[
	\varphi^\sharp_i(q)\coloneqq
	\begin{cases}
		i&\tn{ if }i\neq x \tn{ or } q=0\\
		x'&\tn{ if }i=x\tn{ and } q>0
	\end{cases}
\]
where $x'\coloneqq(12\,112\,1112\,11112\,111112\ldots)$. There are three cofunctor conditions to check, namely identity, codomains, and composition. The codomain condition is vacuous since $\yon^Q$ has one object, and the identity condition holds by construction, because we always have $\varphi^\sharp_i(0)=i$. Now take $q_1,q_2\in Q$; we need to check that
\[\varphi^\sharp_{\cod\varphi^\sharp_i(q_1)}(q_2)=^?\varphi^\sharp_i(q_1+q_2)\]
holds. If $i\neq x$ or $q_1=q_2=0$, then it holds because both sides equal $i$. If $i=x$ and either $q_1>0$ or $q_2>0$, it is easy to check that both sides equal $x'$, so again it holds.
\end{solution}
\end{exercise}


%---- Subsection ----%
\subsection{Exhibiting the forgetful-cofree adjunction}

We are now ready to give a diagrammatic proof of the main result of this section: as promised, the category $\cofree{p}$ we constructed is the cofree comonoid on $p$.

\begin{theorem}[Cofree comonoid] \label{thm.cofree}
The forgetful functor $U\colon \smcat^\sharp\to\poly$ has a right adjoint $\cofree{-}\colon\poly\to\smcat^\sharp$, giving rise to an adjunction
\[
    \adj{\smcat^\sharp}{U}{\cofree{-}}{\poly},
\]
such that for each $p\in\poly$, the carrier $\car{t}_p\coloneqq U\cofree{p}$ of the category $\cofree{p}$ is given by the limit of the diagram \eqref{eqn.cofree_diagram}, repeated here:
\[
\begin{tikzcd}
	\yon \ar[d] &
	p \ar[d] &
	p\tripow2 \ar[d] &
	[10pt] p\tripow3 \ar[d] &
	\cdots\\
	\1 &
	p\tri\1 \ar[l, "!"'] &
	p\tripow2\tri\1 \ar[l, "p\:\tri\:!"'] &
	p\tripow3\tri\1 \ar[l, "p\tripow2\:\tri\:!"'] &
	\cdots.\ar[l]
\end{tikzcd}
\]
That is, for any category $\cat{C}\in\smcat^\sharp$ with carrier $\car{c}\coloneqq U\cat{C}$, there is a natural isomorphism
\[
    \poly(\car{c},p)\iso\smcat^\sharp(\cat{C},\cofree{p}).
\]
\end{theorem}

\begin{proof}
To show that $\cofree{-}$ is the right adjoint of $U$, it is enough to show that for every lens $\varphi\colon\car{c}\to p$, there exists a unique cofunctor $F\colon\cat{C}\cof\cofree{p}$ for which
\begin{equation} \label{eqn.cofree_universal_lens_counit}
\begin{tikzcd}
    \car{c} \ar[d,dashed,"F"'] \ar[dr,"\varphi"] \\
    \car{t}_p \ar[r,"\epsilon^{(1)}_p"'] & p
\end{tikzcd}
\end{equation}
commutes.
Here the projection $\epsilon^{(1)}_p\colon U\cofree{p}\iso\car{t}_p\to p$ serves as the counit of the adjunction, and we identify the cofunctor $F$ with its underlying lens $UF\colon\car{c}\to\car{t}_p$.

First, we construct $F$ from $\varphi$ as follows.
If we let $\epsilon$ and $\delta$ be the eraser and duplicator of $\cat{C}$, the diagram
\begin{equation} \label{eqn.phi_seed}
\begin{tikzcd}[column sep=large]
    \car{c} \ar[d, "\epsilon"'] \ar[r, "\delta"] \ar[dr, "\varphi"'] &
    \car{c}\tri\car{c} \ar[d, "\epsilon\:\tri\:\varphi"] \\
    \yon \ar[d] & p \ar[d] \\
    \1 & p\tri\1 \ar[l]
\end{tikzcd}
\end{equation}
commutes: the pentagon in the lower left commutes trivially, while the triangle in the upper right commutes by the left erasure law of $\cat{C}$, as
\begin{align*}
    \delta\then\left(\epsilon\tri\varphi\right)&=
    \delta\then\left(\epsilon\tri\car{c}\right)\then\varphi \\ &=
    \id_\car{c}\then\varphi \tag{Left erasure law} \\ &=
    \varphi.
\end{align*}
Then by induction, the larger diagram
\begin{equation} \label{eqn.phi_expand}
\begin{tikzcd}[column sep=large]
    \car{c} \ar[d,"\epsilon"'] \ar[r,"\delta"] \ar[dr,"\varphi"'] & \car{c}\tri\car{c} \ar[d,"\epsilon\:\tri\:\varphi"] \ar[r,"\delta\:\tri\:\car{c}"] & \car{c}\tripow3 \ar[d, "\epsilon\:\tri\:\varphi\tripow2"] \ar[r,"\delta\:\tri\:\car{c}\tripow2"] & \car{c}\tripow4 \ar[d,"\epsilon\:\tri\:\varphi\tripow{3}"] \ar[r] & \cdots \\
    \yon \ar[d] & p \ar[d] & p\tripow2 \ar[d] & p\tripow3 \ar[d] & \cdots \\
    \1 & p\tri\1 \ar[l] & p\tripow2\tri\1 \ar[l] & p\tripow3\tri\1 \ar[l] & \cdots \ar[l]
\end{tikzcd}
\end{equation}
commutes as well: its leftmost rectangle is \eqref{eqn.phi_seed}, and taking the composition product of each rectangle in \eqref{eqn.phi_expand} with the commutative rectangle
\[
\begin{tikzcd}[column sep=large]
    \car{c} \ar[d, "\varphi"'] \ar[r, equals] & \car{c} \ar[d, "\varphi"] \\
    p \ar[d, equals] & p \ar[d, equals] \\
    p & p \ar[l, equals]
\end{tikzcd}
\]
yields the rectangle to its right.
As $\car{t}_p$ is the limit of the bottom two rows of \eqref{eqn.phi_expand}, it follows that there is an induced lens $F\colon\car{c}\to\car{t}_p$ that, when composed with each projection $\epsilon^{(n)}_p\colon\car{t}_p\to p\tripow{n}$, yields the lens depicted in \eqref{eqn.phi_expand} from $\car{c}$ to $p\tripow{n}$.
This lens is the composite of the lens $\car{c}\to\car{c}\tripow{(n+1)}$ in the top row, which by \cref{prop.n_duplication} is the canonical lens $\delta^{(n+1)}$ associated with the comonoid $\cat{C}$, composed with the lens $\epsilon\tri\varphi\tripow{n}\colon\car{c}\tripow{(n+1)}\to p\tripow{n}$.
%** check that it satisfies cofunctor laws

Next, we prove uniqueness: that a cofunctor $\cat{C}\cof\cofree{p}$ with underlying lens $f\colon\car{c}\to\car{t}_p$ is completely determined by the value of $f\then\epsilon^{(1)}_p$.
It suffices to show that we can recover the $n^\text{th}$ component of $g$ from its first component.
% We do so by demonstrating that the diagram
% \begin{diag} \label{diag.g_components}
% \begin{tikzcd}[sep=large]
%     C \ar[d, "\d^{n-1}"'] \ar[r, "g"] & C_p \ar[d, "\d^{n-1}_p"'] \ar[dr, "\e^n_p"] \\
%     C\circpow{n} \ar[r, "g\circpow{n}"'] & C_p\circpow{n} \ar[r, "\left(\e^1_p\right)\circpow{n}"'] & p\circpow{n}
% \end{tikzcd}
% \end{diag}
% commutes, which would show that $g \sm \e^n_p = \d^{n-1} \sm \left( g \sm \e^1_p \right)\circpow{n}$.

% The square on the left side of \cref{diag.g_components} commutes because $g$ respects the comonoid structure, and we can show that the triangle on the right side of \cref{diag.g_components} commutes via induction on $n$.
% When $n = 0$, the triangle commutes because $\delta^{-1}_p$ and $\e^0_p$ are both just the counit of the comonoid $C_p$; and if the triangle commutes for some fixed $n$, then by \cref{eq.d_pow_n,eq.d_m_n},
% \[
% \begin{split}
%     \d^n_p \sm \left(\e^1_p\right)\circpow{(n+1)} &= \d_p \sm \left(C_p \circ \d^{n-1}_p\right) \sm \left(\e^1_p\right)\circpow{(n+1)} \\
%     &= \d_p \sm \left(\e^1_p \circ \left(\d^{n-1}_p \sm \left(\e^1_p\right)\circpow{n}\right)\right) \\
%     &= \d_p \sm \left(\e^1_p \circ \e^n_p \right) \\
%     &= \e^{n+1}_p.
% \end{split}
% \]
% Hence the triangle commutes by induction, so \cref{diag.g_components} commutes, as desired.
\end{proof}

% ** include examples


%---- Subsection ----%
\subsection{The many (inter)faces of the cofree comonoid} \label{subsec.comon.cofree.cons.faces}

The forgetful-cofree adjunction of \cref{thm.cofree} tells us that given a category $\cat{C}\in\smcat^\sharp$ with carrier $\car{c}\coloneqq U\cat{C}$ and a polynomial $p\in\poly$, there is a natural isomorphism
\[
    \poly(\car{c},p)\iso\smcat^\sharp(\cat{C},\cofree{p}).
\]
So every lens $\varphi\colon\car{c}\to p$ has a corresponding cofunctor $F\colon\cat{C}\cof\cofree{p}$ that we call its \emph{mate}.

We can view $\varphi$ as a dynamical system with an interface $p$ and a generalized state system $\car{c}$, carrying an arbitrary category $\cat{C}$ of states and transitions.
Then the lens $\text{Run}_n(\varphi)\colon\car{c}\to p\tripow{n}$ for $n\in\nn$, defined as the composite
\[
    \car{c}\To{\delta^{(n)}}\car{c}\tripow{n}\To{\varphi\tripow{n}}p\tripow{n},
\]
models $n$ runs through the system $\varphi$.

Meanwhile, as the limit of the diagram \eqref{eqn.cofree_diagram} with the row of polynomials of the form $p\tripow{n}$ across the top, the carrier $\car{t}_p$ of the cofree comonoid on $p$ comes equipped with a lens $\epsilon^{(n)}_p\colon\car{t}_p\to p\tripow{n}$ for each $n\in\nn$.
Since the cofunctor $F\colon\cat{C}\cof\cofree{p}$ has an underlying lens between carriers $f\coloneqq UF\colon\car{c}\to\car{t}_p$, we can obtain another lens $\car{c}\to\tripow{n}$ as the composite
\[
    \car{c}\To{f}\car{t}_p\To{\epsilon^{(n)}_p}p\tripow{n}.
\]

It follows from our forgetful-cofree adjunction that these two composites are equal.

\begin{proposition}
With the definitions above, the following diagram commutes:
\[
\begin{tikzcd}
    \car{c} \ar[r,"f"] \ar[d, "\delta^{(n)}"'] & \car{t}_p \ar[d, "\epsilon^{(n)}_p"] \\
    \car{c}\tripow{n} \ar[r, "\varphi\tripow{n}"'] & p\tripow{n}.
\end{tikzcd}
\]
\end{proposition}
\begin{proof}
**
\end{proof}

Now we have a better sense of what we mean when we say that $F\colon\cat{C}\cof\cofree{p}$ captures all the information that the lenses $\text{Run}_n(\varphi)\colon\car{c}\to p\tripow{n}$ encode: the category $\cofree{p}$ is carried by a polynomial $\car{t}_p$ equipped with lenses $\epsilon^{(n)}_p\colon\car{t}_p\to p\tripow{n}$, each of which exposes a part of the category as the $n$-fold interface $p\tripow{n}$.
All together, $\car{t}_p$ acts as a giant interface that captures the $n$-fold behavior of $p\tripow{n}$ for every $n\in\nn$.
But to see all this explicitly, let's consider some examples.

%we need to be clear on what the positions and directions of $\car{t}_p$ are and what category $\cofree{p}$ it carries, as well as how each lens $\epsilon^{(n)}_p\colon\car{t}_p\to p\tripow{n}$ behaves.

\begin{example}\label{ex.cofree_dyn_sys}
Let $S\coloneqq\{\bul[dgreen],\bul[dyellow],\bul[red]\}$ and $p\coloneqq\yon^\2+\1$, and consider the dynamical system $f\colon S\yon^S\to p$ from \cref{exc.halt_dsa}, depicted here again for your convenience:
\[
\begin{tikzcd}[column sep=small]
	\bul[dgreen]\ar[rr, bend left, orange]\ar[loop left, dgreen]&&
	\bul[dyellow]\ar[dl, bend left, orange]\ar[ll, dgreen, bend left]\\&
	\bul[red]
\end{tikzcd}
\]
The polynomial map $f$ is supposed to induce a cofunctor $F\colon S\yon^S\cof\cofree{p}$ from the state category on $S$ to the category of $p$-trees. Thus to each state $s\in S$, we need to associate a tree; which should it be? 
**
\end{example}

% ** more examples?

% ** figure out what this means

% %---- Subsection ----%
% \subsection{Dynamical systems and graph fibrations}

% In \cref{ex.cofree_dyn_sys}, there's a certain relationship we can see between the graph we associate to the dynamical system $S\yon^S\to p$, namely 
% \[
% \begin{tikzcd}[column sep=small]
% 	\bul[dgreen]\ar[rr, bend left, orange]\ar[loop left, dgreen]&&
% 	\bul[dyellow]\ar[dl, bend left, orange]\ar[ll, dgreen, bend left]\\&
% 	\bul[red]
% \end{tikzcd}
% \]
% and the trees (which are also graphs) that its mate $S\yon^S\to\cofree{p}$ associates to each element of $S$, e.g.\ for the green dot:
% \[
% \treepic
% \]
% Indeed, there is a map of graphs from the latter to the former, which sends all the green dots in the tree to the green dot in the dynamical system, etc. This map of graphs is a kind of \emph{fibration}, or maybe we should say op-fibration, in the sense that the set of arrows emanating from every dot in the tree is in bijection with the set of arrows emanating from its image in the dynamical system graph.

% \begin{exercise}
% \begin{enumerate}
% 	\item Draw the other two trees associated to the dynamical system in \cref{ex.cofree_dyn_sys}.
% 	\item Do they also have an op-fibration down to the dynamical system graph?
% 	\item Are these op-fibrations special in any way? That is, are they unique, or have any universal property?
% \qedhere
% \end{enumerate}
% \begin{solution}
% \begin{enumerate}
%     \item **
%     \item **
%     \item **
% \end{enumerate}
% \end{solution}
% \end{exercise}



%---- Subsection ----%
\subsection{Morphisms between cofree comonoids}
Given a morphism of polynomials $\varphi \colon p \to q$, the cofree functor gives us a map of comonoids $\cofree{\varphi} \colon \cofree {p} \to \cofree{q}$, which works as follows.

An object $t \in \tr_p$ is a tree; the tree $u \coloneqq \cofree{\varphi} (t) \in \tr_q $ is constructed recursively as follows. If the root of $t$ is $i \in p(\1)$ then the root of $u$ is $j \coloneqq \varphi_1 (i)$. To each branch $b \in q[j]$, we need to assign a new tree, and we use the one situated at $\varphi_i ^ \sharp (b)$.

\begin{exercise}
Let $p \coloneqq \yon ^\2 + \1$ and $q \coloneqq \2 \yon + \2$.
\begin{enumerate}
    \item Choose a map $\varphi\colon p\to q$, and write it out.
    \item Choose a tree $T\in\tr_p$ with at least height $2$.
    \item What is $\cofree{\varphi}(T)$?
    \qedhere
\end{enumerate}
\begin{solution}
\begin{enumerate}
    \item **
    \item **
    \item **
\end{enumerate}
\end{solution}
\end{exercise}

% The following exercise is useful when considering the (topos-theoretic) logic of dynamical systems. Namely, it will allow us to specify legal subtrees of height $n$. %** what does this mean?

\begin{exercise}
Let $p$ be a polynomial.
\begin{enumerate}
    \item Show there is an induced cofunctor $\cofree{p} \to \cofree{p\tripow{n}}$ for all $n\in\nn$.
    \item Show that when $n\geq1$, the induced cofunctor is an isomorphism. \qedhere
\end{enumerate}
\begin{solution}
\begin{enumerate}
    \item **
    \item **
\end{enumerate}
\end{solution}
\end{exercise}

%---- Subsection ----%
\subsection{Some categorical properties of cofree comonoids}

\begin{proposition}\label{prop.cofree_free_on_graph}
For every polynomial $p$, the cofree category $\cofree{p}$ is free on a graph. That is, there is a graph $G_p$ whose associated free category in the usual sense (the category of vertices and paths in $G_p$) is isomorphic to $\cofree{p}$.
\end{proposition}
\begin{proof}
For vertices, we let $V_p$ denote the set of $p$-trees,
\[V_p\coloneqq\tr_p(\1).\]
For arrows we use the map $\pi\colon\tr_p\to p$ from \cref{**} to define
\[
A_p\coloneqq\sum_{t\in\tr_p(\1)}p[\pi_1(t)]
\]
In other words $A_p$ is the set $\{d\in p[\pi_1(t)]\,\mid\,t\in\tr_p\}$ of directions in $p$ that emanate from the root corolla of each $p$-tree. The source of $(t,d)$ is $t$ and the target is $\cod(\pi^\sharp_t(d))$. It is clear that every morphism in $\cofree{t}$ is the composite of a finite sequence of such morphisms, completing the proof.
\end{proof}


\begin{corollary}
Let $p$ be a polynomial and $\cofree{p}$ the cofree comonoid. Every morphism in $\cat{C}_p$ is both monic and epic.
\end{corollary}
\begin{proof}
The free category on a graph always has this property, so the result follows from \cref{prop.cofree_free_on_graph}.
\end{proof}

\begin{proposition}\label{prop.ynn_monoid}
The additive monoid $\yon^\nn$ of natural numbers has a $\times$-monoid structure in $\smcat^\sharp$.
\end{proposition}
\begin{proof}
The right adjoint $p\mapsto\cofree{p}$ preserves products, so $\yon^{\List(\ord{n})}\cong\cofree{\yon^{\ord{n}}}$ is the $n$-fold product of $\yon^\nn$ in $\smcat^\sharp$. We thus want to find cofunctors $e\colon \yon\to\yon^\nn$ and $m\colon\yon^{\List(\2)}\to\yon^\nn$ that satisfy the axioms of a monoid. 

The unique polynomial map $\yon\to\yon^\nn$ is a cofunctor (it is the mate of the identity $\yon\to\yon$). We take $m$ to be the mate of the polynomial map $\yon^{\List(\2)}\to\yon$ given by the list $[1,2]$. One can check by hand that these definitions make $(\yon^\nn,e,m)$ a monoid in $(\smcat^\sharp,\yon,\times)$.
\end{proof}

Recall from \cref{ex.arrow_field} that an arrow field of a category $\cat{C}$ is a cofunctor $\cat{C}\cof\yon^\nn$.

\begin{corollary}
For any category $\cat{C}$, the set $\smcat^\sharp(\cat{C},\yon^\nn)$ of arrow fields has the structure of a monoid. Moreover, this construction is functorial
\[\smcat^\sharp(-,\yon^\nn)\colon\smcat^\sharp\to\Cat{Mon}\op\]
\end{corollary}
\begin{proof}
We saw that $\yon^\nn$ is a monoid object in \cref{prop.ynn_monoid}.
\end{proof}

A cofunctor $\cat{C}\cof\yon^\nn$ is a policy in $\cat{C}$: it assigns an outgoing morphism to each object of $\cat{C}$. Any two such trajectories can be multiplied: we simply do one and then the other; this is the monoid operation. The policy assigning the identity to each object is the unit of the monoid.

We use the notation $\cat{C}\mapsto\vec{\cat{C}}$ for the monoid of arrow fields.

\begin{theorem}\label{thm.catsharp_to_mon}
The arrow fields functor
\[\smcat^\sharp\to\Cat{Mon}\op\]
is right adjoint to the inclusion $\Cat{Mon}\op\to\smcat^\sharp$ from \cref{prop.monoids_ff}.
\end{theorem}
\begin{proof}
Let $\cat{C}$ be a category and $(M,e,*)$ a monoid. A cofunctor $F\colon\cat{C}\cof\yon^M$ has no data on objects; it is just a way to assign to each $c\in \cat{C}$ and $m\in M$ a morphism $F^\sharp_c(m)\colon c\to c'$ for some $c'\coloneqq\cod(F^\sharp_c(m))$. This assignment must send identities to identities and composites to composites: given $m'\in M$ we have $F^\sharp_c(m\then m')=F^\sharp_c(m)\then F^\sharp_{c'}(m')$. This is exactly the data of a monoid morphism $M\to \vec{\cat{C}}$: it assigns to each $m\in M$ an arrow field $\cat{C}$, preserving unit and multiplication.
\end{proof}

\begin{proposition}\label{prop.traj_mon_poly}
There is a commutative square of left adjoints
\[
\begin{tikzcd}
	\Cat{Mon}\op\ar[r, "U"]\ar[d, "\yon^-"']&
	\smset\op\ar[d, "\yon^-"]\\
	\smcat^\sharp\ar[r, "U"']&
	\poly
\end{tikzcd}
\]
where the functors denoted $U$ are forgetful functors.
\end{proposition}
\begin{proof}
Using the fully faithful functor $\yon^-\colon\Cat{Mon}\op\fromto\smcat^\sharp$ from \cref{prop.monoids_ff}, it is easy to check that the above diagram commutes. 

The free-forgetful adjunction $\smset\fromto\Cat{Mon}$ gives an opposite adjunction $\smset\op\fromto\Cat{Mon}\op$, where $U$ is now left adjoint. We saw that $\yon^-\colon\smset\op\to\poly$ is a left adjoint in \cref{prop.yoneda_left_adjoint}, that $U\colon\smcat^\sharp\to\poly$ is a left adjoint in \cref{thm.cofree}, and that $\yon^-\colon\Cat{Mon}\to\smcat^\sharp$ is a left adjoint in \cref{thm.catsharp_to_mon}.
\end{proof}

\section{More categorical properties of $\smcat^\sharp$}

Many of the properties of $\poly$ we covered in \cref{ch.poly.func_nat,ch.poly.bonus} have analogues in $\smcat^\sharp$; we review these here.

%-------- Section --------%
\subsection{Other special comonoids and adjunctions}

We begin by highlighting a few other adjunctions involving $\smcat^\sharp$, as well as the special comonoids in $\smcat^\sharp$ they provide.

\begin{proposition}
The functor $\yon^-$ from \cref{prop.traj_mon_poly} factors through an isomorphism of categories
\[
    \smcat^\sharp_{\text{rep}}\iso\Cat{Mon}\op,
\]
where $\Cat{Mon}$ is the category of monoids and monoid homomorphisms and  $\smcat^\sharp_{\text{rep}}$ is the full subcategory of $\smcat^\sharp$ consisting of categories with representable carriers $\yon^M$ for some $M\in\smset$.
\end{proposition}
\begin{proof}
Let $\cat{C}$ be a category. It has only one object iff its carrier $\car{c}$ has only one position, i.e.\ $\car{c}\cong\yon^M$ for some $M\in\smset$, namely where $M$ is the set of morphisms in $\cat{C}$. It remains to show that cofunctors between monoids are dual---opposite---to morphisms between monoids.

A cofunctor $f\colon\yon^M\to\yon^N$ involves a single function $f^\sharp\colon N\to M$ that must satisfy a law coming from unitality and one coming from composition, as in \cref{def.morphism_comonoids}. The result can now be checked by hand, or seen formally as follows. Each object in the two diagrams of \eqref{def.morphism_comonoids} is representable by \cref{exc.composites_of_specials}. The Yoneda embedding $\smset\op\to\poly$ is fully faithful, so these two diagrams are equivalent to the unit and composition diagrams for monoid homomorphisms.
\end{proof}

\begin{exercise}\label{exc.lin_comon_set}
Let $\smcat^\sharp_{\text{lin}}$ be the full subcategory of $\smcat^\sharp$ consisting of categories with linear carriers $S\yon$ for some $S\in\smset$.
Show that there is an isomorphism of categories
\[
\smcat^\sharp_{\text{lin}}\iso\smset.
\qedhere
\]
\begin{solution}
**
\end{solution}
\end{exercise}

\begin{proposition}[Discrete categories]
The inclusion $\smcat^\sharp_{\text{lin}}\to\smcat^\sharp$ has a left adjoint sending each $(\car{c},\epsilon,\delta)\in\smcat^\sharp$ to the unique comonoid carried by $(\car{c}\tri\1)\yon$ in $\smcat^\sharp_{\text{lin}}$.
\end{proposition}
\begin{proof}
We need to show that for any comonoid $(\car{c},\epsilon,\delta)$ and set $A$, we have a natural isomorphism
\[
  \smcat^\sharp(\car{c},A\yon).
  \cong^?
  \smcat^\sharp((\car{c}\tri\1)\yon,A\yon)
\]
But every morphism in $A\yon$ is an identity, so the result follows from the fact that every cofunctor must pass identities back to identities. 
\end{proof}


%**
%* monoids, etc.

%-------- Section --------%
\subsection{Vertical-cartesian factorization of cofunctors}

A cofunctor is called \emph{cartesian} if the underlying lens $f\colon\car{c}\to\car{d}$ is cartesian (i.e.\ for each position $i\in\car{c}(\1)$, the map $f^\sharp_i\colon\car{d}[f_1(i)]\to\car{c}[i]$ is an isomorphism). %** refer back to earlier section where we defined this...also vertical cartesian...and make this its own section

\begin{proposition}\label{prop.factor_cofunctor}
Every cofunctor $f\colon\cat{C}\cof\cat{D}$ factors as a vertical morphism followed by a cartesian morphism
\[
\cat{C}\overset{\text{vert}}{\cof}\cat{C}'\overset{\text{cart}}{\cof}\com{D}.
\]
\end{proposition}
\begin{proof}
A cofunctor $\cat{C}\cof\cat{D}$ is a map of polynomials $\car{c}\to\car{d}$ satisfying some properties, and any map of polynomials $f\colon\car{c}\to\car{d}$ can be factored as a vertical morphism followed by a cartesian morphism
\[
	\car{c}\To{g}\car{c'}\To{h}\car{d}.
\]
For simplicity, assume $g_1\colon\car{c}(\1)\to\car{c'}(\1)$ is identity (rather than merely isomorphism) on positions and similarly that for each $i\in\car{c}$ the map $h^\sharp_i\colon\car{c'}[i]\to\car{d}[h_1(i)]$ is identity (rather than merely isomorphism) on directions. 

It suffices to show that the intermediate object $\car{c'}$ can be endowed with the structure of a category such that $g$ and $h$ are cofunctors. Given an object $i\in\car{c'}(\1)$, assign its identity to be the identity on $h_1(i)=f(i)$; then both $g$ and $h$ preserve identities because $f$ does. Given an emanating morphism $m\in\car{c'}[i]=\car{d}[f(i)]$, assign its codomain to be $\cod(m)\coloneqq\cod(f^\sharp_i(m))$, and given an emanating morphism $m'\in\car{c'}[\cod(m)]$, assign the composite $m\then m'$ in $\car{c'}$ to be $m\then m'$ in $\car{d}$. In \cref{exc.factor_cofunctor} we will check that with these definitions, $\car{c'}$ is a category and both $g$ and $h$ are cofunctors.
\end{proof}

\begin{exercise}\label{exc.factor_cofunctor}
We will complete the proof of \cref{prop.factor_cofunctor}, using the same notation.
\begin{enumerate}
	\item Show that composition is associative and unital in $\car{c'}$.
	\item Show that $g$ preserves codomains.
	\item Show that $g$ preserves compositions.
	\item Show that $h$ preserves codomains.
	\item Show that $h$ preserves compositions.
\qedhere
\end{enumerate}
\begin{solution}
\begin{enumerate}
    \item **
    \item **
    \item **
    \item **
    \item **
\end{enumerate}
\end{solution}
\end{exercise}

\begin{proposition} \label{prop.cart_dopf}
The wide%
\footnote{A subcategory $\Cat{D}$ of a category $\Cat{C}$ is \emph{wide} if every object of $\Cat{C}$ is in $\Cat{D}$.}%
subcategory of cartesian cofunctors in $\smcat^\sharp$ is isomorphic to the wide subcategory of discrete opfibrations in $\smcat$.
\end{proposition}
\begin{proof}
Suppose that $\cat{C}$ and $\cat{D}$ are categories. Both a functor and a cofunctor between them involve a map on objects, say $f\colon\Ob\cat{C}\to\Ob\cat{D}$. For any object $c\in\Ob\cat{C}$, a functor gives a function, say $f_\sharp\colon\cat{C}[c]\to\cat{D}[f(c)]$ whereas a cofunctor gives a function $f^\sharp\colon\cat{D}[f(c)]\to\cat{C}[c]$. The cofunctor is cartesian iff $f^\sharp$ is an iso, and the functor is a discrete opfibration iff $f_\sharp$ is an iso. We thus transform our functor into a cofunctor (or vice versa) by taking the inverse function on morphisms. It is easy to check that this inverse appropriately preserves identities, codomains, and compositions.
\end{proof}

% ** connect the above to earlier discrete opfibration stuff; also see below

% The above correspondence is well-known; it remains to address the relationship between (2) and (3). A cartesian cofunctor $(\varphi_1,\varphi^\sharp)\colon\cat{S}\cof\cat{C}$ gives a function $\varphi\colon\Ob(\cat{S})\to\Ob(\cat{C})$ and for each $s\in\cat{S}$ an isomorphism
% \[
%   \varphi_s^\sharp\colon\cat{C}[\varphi_1(s)]\To{\cong}\cat{S}[s]
% \]
% between the set of $\cat{S}$-morphisms emanating from $s$ and the set of $\cat{C}$-morphisms emanating from $\varphi_1(s)$. This isomorphism respects identities, codomains, and composites. As such we can define a functor that acts as $\varphi_1$ on objects and $(\varphi^\sharp)\inv$ on morphisms, and it is easily checked to be a discrete opfibration.

% Finally, given a discrete opfibration $\pi\colon\cat{S}\to\cat{C}$, we define $\varphi_1\coloneqq\Ob(\pi)$ to be its on-objects part, and for any $s\in\Ob(\cat{S})$ and emanating morphism $f\in\cat{C}[\varphi_1(s)]$, we define $\varphi^\sharp_s(f)\coloneqq\ol{f}$ to be the lift guaranteed by \cref{def.dopf}. The conversions between discrete opfibrations and cartesian cofunctors are easily seen to be functorial and the roundtrips are identities.


\begin{proposition}\label{prop.com_vert_cat_boo}
The wide subcategory of vertical maps in $\smcat^\sharp$ is isomorphic to the opposite of the wide subcategory bijective-on-objects maps in $\smcat$:
\[
\smcat^\sharp_{\text{vert}}\cong(\smcat_{\text{boo}})\op.
\]
\end{proposition}
\begin{proof}
Let $\cat{C}$ and $\cat{D}$ be categories. Given a vertical cofunctor $F\colon\cat{C}\cof\cat{D}$, we have a bijection $F_1\colon\Ob\cat{C}\to\Ob\cat{D}$; let $G_1$ be its inverse. We define a functor $G\colon\cat{D}\to\cat{C}$ on objects by $G_1$ and, for any $f\colon d\to d'$ in $\cat{D}$ we define $G(f)\coloneqq F^\sharp_{G_1(d)}$. It has the correct codomain: $\cod(G(f))=G_1(F_1(\cod(G(f)))=G_1(\cod f)$. And it sends identities and compositions to identities and compositions by the laws of cofunctors.

The construction of a vertical cofunctor from a bijective-on-objects functor is analogous, and it is easy to check that the two constructions are inverses.
\end{proof}

\begin{exercise}
Let $S$ be a set and consider the state category $\cat{S}\coloneqq(S\yon^S,\epsilon,\delta)$. Use \cref{prop.com_vert_cat_boo} to show that categories $\cat{C}$ equipped with a vertical cofunctor $\cat{S}\to\cat{C}$ can be identified with categories whose set of objects is $S$.
\begin{solution}
**
\end{solution}
\end{exercise}

\begin{exercise}
Consider the categories $\cat{C}\coloneqq\fbox{$\bullet\tto\bullet$}$ and $\cat{D}\coloneqq\fbox{$\bullet\to\bullet$}$. There is a unique bijective-on-objects (boo) functor $F\colon\cat{C}\to\cat{D}$ and two boo functors $G_1,G_2\colon\cat{D}\to\cat{C}$. These have corresponding cofunctors going the other way.
\begin{enumerate}
	\item Write down the morphism $\car{d}\to\car{c}$ of carriers corresponding to $F$.
	\item Write down the morphism $\car{c}\to\car{d}$ of carriers corresponding to either $G_1$ or $G_2$.
\qedhere
\end{enumerate}
\begin{solution}
\begin{enumerate}
    \item **
    \item **
\end{enumerate}
\end{solution}
\end{exercise}

We record the following proposition here; it will be useful in \cref{cor.cartesian_cof_extra_adjoint}.

\begin{proposition}
If $f\colon p\to q$ is a cartesian lens, then $\cofree{f}\colon\cofree{p}\to\cofree{q}$ is a cartesian cofunctor: that is, for each $t\in\tr_p$, the on-morphisms function
\[
    \left(\cofree{f}\right)^\sharp_t\colon\cofree{q}[\cofree{f}t]\To{\iso}\cofree{p}[t]
\]
is a bijection.
\end{proposition}
\begin{proof}
**
\end{proof}

%-------- Section --------%
\subsection{Limits and colimits of comonoids}

We saw in \cref{thm.poly_limits,thm.poly_colimits} that $\poly$ has all small limits and colimits.
It turns out that $\smcat^\sharp$ has all small limits and colimits as well.
We start by discussing colimits in $\smcat^\sharp$, as they are somewhat easier to get a handle on.

\subsubsection{Colimits in $\smcat^\sharp$}

It is a consequence of the forgetful-cofree adjunction from \cref{thm.cofree} that $\smcat^\sharp$ inherits all the colimits from $\poly$.
As these results are somewhat technical, relying on a property of functors known as \emph{comonadicity}, we defer their proofs to references.

\begin{proposition}[Porst]
The forgetful functor $\smcat^\sharp\to\poly$ is comonadic.
\end{proposition}
\begin{proof}
The fact that a forgetful functor $\smcat^\sharp\iso\Cat{Comon}(\poly)\to\poly$ is comonadic if it has a right adjoint follows from Beck's monadicity theorem via a straightforward generalization of an argument given by Par{\'e} in \cite[pp.~138-9]{pare1969absolute}, as pointed out by Porst in \cite[Fact~3.1]{porst2019colimits}.
So the result follows from \cref{thm.cofree}.
\end{proof}

\begin{corollary} \label{cor.comon_cocomp}
The category $\smcat^\sharp$ has all small colimits.
They are created by the forgetful functor $\smcat^\sharp\to\poly$.
\end{corollary}
\begin{proof}
A comonadic functor creates all colimits that exist in its codomain (see \cite{nlab:created-limit}), and by \cref{thm.poly_colimits}, the category $\poly$ has all small colimits.
\end{proof}

\begin{example}[Coproducts in $\smcat^\sharp$]
Probably the most familiar kind of colimit in $\smcat^\sharp$ is the coproduct, as \cref{cor.comon_cocomp} tells us that it agrees with the usual coproduct from $\smcat$.
Here's why.

For concreteness, let $I$ be a set and $(\cat{C}_i)_{i\in I}$ be categories with carriers $(\car{c}_i)_{i\in I}$.
Then the coproduct of $(\cat{C}_i)_{i\in I}$ in $\smcat$ is the category $\sum_{i\in I}\cat{C}_i$, whose objects are given by the disjoint union of the objects in each summand, so that
\[
    \Ob\left(\sum_{i\in I}\cat{C}_i\right)\iso\sum_{i\in I}\Ob\cat{C}_i=\sum_{i\in I}\car{c}_i(\1)\iso\left(\sum_{i\in I}\car{c}_i\right)(\1),
\]
and whose morphisms out of each $c\in\Ob\cat{C}_j\ss\Ob\sum_{i\in I}\cat{C}_i$ are just the morphisms out of $c$ in the summand $\cat{C}_j$, so
\[
    \left(\sum_{i\in I}\cat{C}_i\right)[c]\iso\cat{C}_j[c]=\car{c}_j[c]\iso\left(\sum_{i\in I}\car{c}_i\right)[c]
\]
Hence $\sum_{i\in I}\cat{C}_i$ is carried by the coproduct of polynomials $\sum_{i\in I}\car{c}_i$.

It remains to show that $\sum_{i\in I}\cat{C}_i$ is also the coproduct of $(\cat{C}_i)_{i\in I}$ in $\smcat^\sharp$.
We already know from \cref{cor.comon_cocomp} that it has the right carrier: the coproduct of carriers $\sum_{i\in I}\car{c}_i$. **

% ** give inclusions as cofunctors

% For each $j\in J$, we define an inclusion cofunctor $\iota_j\colon\cat{C}_j\cof\sum_{i\in I}\cat{C}_i$ as follows: it is the canonical inclusion on objects, **. %**show all fully faithful functors can be interp as cofunctors first??

% Suppose we have a category $\cat{D}$ and cofunctors $F_i\colon\cat{C}_i\cof\cat{D}$ for $i\in I$.
% For every object $c\in\Ob\cat{C}_j\ss\Ob\sum_{i\in I}\cat{C}_i$, we have an object $F_j c\in\Ob\cat{D}$, so we can set $Fc\coloneqq F_j c$.
% Then for every morphism $g\colon Fc\to\_$ in $\cat{D}$, we have a morphism $\left(F_j\right)^\sharp_c g\colon c\to\_$, so we can set $F^\sharp_c g\coloneqq\left(F_j\right)^\sharp_c g$.
% As each $F_j$ satisfies the cofunctor laws, so does $F$.

% % ** check cofunctor laws
% % ** check commutes
% % ** check uniqueness


% % It is easy to check that the cofunctor laws hold for $f$. Uniqueness of $f$ given $f_1,f_2$ is also straightforward.
\end{example}

\begin{exercise}\label{exc.0_initial_com}
\begin{enumerate}
	\item Show that $\0$ has a unique comonoid structure.
	\item Explain why $\0$ with its comonoid structure is initial in $\smcat^\sharp$ in two ways: by explicitly showing it has the required universal property, or by invoking \cref{cor.comon_cocomp}.
\qedhere
\end{enumerate}
\begin{solution}
\begin{enumerate}
    \item We actually already showed that $\0$ has a unique comonoid structure, corresponding to the empty category (which we will also denote by $\0$), in \cref{exc.not_state_cat_but_same_carrier}, for the case of $S\coloneqq\0$.
    \item We show that $\0$ has the universal property of the initial object in $\smcat^\sharp$ as follows.
    For any category $\cat{D}$, there is a unique cofunctor $\0\cof\cat{D}$: it vacuously sends each object in $\0$ to an object in $\cat{D}$, and since there are no objects in $\0$, it does nothing to morphisms.
    
    Alternatively, we know by \cref{cor.comon_cocomp} that $\smcat^\sharp$ has an initial object, and that the forgetful functor $\smcat^\sharp\to\poly$ sends it to the initial object in $\poly$, which is $\0$ (by \cref{prop.poly_coprods} and the following discussion).
    So the initial object in $\smcat^\sharp$ must be the unique comonoid carried by $\0$.
\end{enumerate}
\end{solution}
\end{exercise}

\begin{exercise}
Given a comonoid $(\car{c},\epsilon,\delta)\in\smcat^\sharp$, show that there is an induced comonoid structure on the polynomial $\2\car{c}$.
\begin{solution}
** % sum with itself
\end{solution}
\end{exercise}

% ** refer back to relevant cofunctor example
\begin{exercise}
Let $\cat{C}$ be a category with carrier $\car{c}$.
\begin{enumerate}
	\item Give a category $\cat{D}$ carried by the polynomial $\sum_{i\in\car{c}(\1)}\car{c}[i]\yon^{\car{c}[i]}$, and give a cofunctor $\cat{D}\cof\cat{C}$.
	\item Is the underlying lens $\sum_{i\in\car{c}(\1)}\car{c}[i]\yon^{\car{c}[i]}\cof\car{c}$ of this cofunctor an epimorphism?
\qedhere
\end{enumerate}
\begin{solution}
\begin{enumerate}
    \item **
    \item **
\end{enumerate}
\end{solution}
\end{exercise}

\subsubsection{Limits in $\smcat^\sharp$}

As in the case of colimits, there is a rather technical result showing that the forgetful-cofree adjunction implies the existence of all small limits of comonoids, which we summarize here.

\begin{corollary}
The category $\smcat^\sharp$ has all small limits.
\end{corollary}
\begin{proof}
By \cref{thm.cofree}, the forgetful functor $U\colon\smcat^\sharp\to\poly$ has a right adjoint, and by \cref{thm.poly_limits}, $\poly$ itself has all small limits.
Furthermore equalizers in $\poly$ are connected limits, so by \cref{thm.connected_limits}, they are preserved by $\tri$ on either side.
Then the result follows from \cite[Fact~3.4]{porst2019colimits}.
\end{proof}


%-------- Section --------%
\subsection{Parallel product comonoids}

The usual product of categories is not the categorical product in $\smcat^\sharp$. %**show this with small counterexample
It is, however, a \emph{monoidal} product on $\smcat^\sharp$, coinciding with the parallel product $\otimes$ on $\poly$.

\begin{proposition}\label{prop.parallel_on_catsharp}
The parallel product $(\yon,\otimes)$ on $\poly$ extends to a monoidal structure $(\yon,\otimes)$ on $\smcat^\sharp$, such that the forgetful functor
$U\colon\smcat^\sharp\to\poly$
is strong monoidal with respect to $\otimes$.
The parallel product of two categories is their product in $\smcat$.
\end{proposition}
\begin{proof}
Let $\cat{C},\cat{D}\in\smcat^\sharp$ be categories corresponding to comonoids $(\car{c},\epsilon_{\car c},\delta_{\car c})$ and $(\car{d},\epsilon_{\car d},\delta_{\car d})$.



The carrier of $\cat{C}\otimes\cat{D}$ is defined to be $\car{c}\otimes\car{d}$. A position in it is a pair $(c,d)$ of objects, one from $\cat{C}$ and one from $\cat{D}$; a direction there is a pair $(f,g)$ of a morphism emanating from $c$ and one emanating from $d$. 

We define $\epsilon_{\cat{C}\otimes\cat{D}}\colon\car{c}\otimes\car{d}\to\yon$ as
\[
\car{c}\otimes\car{d}\To{\epsilon_{\car{C}}\otimes\epsilon_{\car{D}}}\yon\otimes\yon\cong\yon.
\]
This says that the identity at $(c,d)$ is the pair of identities.

We define $\delta_{\cat{C}\otimes\cat{D}}\colon(\car{c}\otimes\car{d})\to(\car{c}\otimes\car{d})\tri(\car{c}\otimes\car{d})$ using the duoidal property:
\[
\car{c}\otimes\car{d}\To{\delta_{\car{c}}\otimes\delta_{\car{d}}}(\car{c}\tri\car{c})\otimes(\car{d}\tri\car{d})\to(\car{c}\otimes\car{d})\tri(\car{c}\otimes\car{d}).
\]
One can check that this says that codomains and composition are defined coordinate-wise, and that $(\car{c}\otimes\car{d},\epsilon_{\car{c}\otimes\car{d}},\delta_{\car{c}\otimes\car{d}})$ forms a comonoid. One can also check that this is functorial in $\cat{C},\cat{D}\in\smcat^\sharp$. See \cref{exc.parallel_on_catsharp}.
\end{proof}

\begin{exercise}\label{exc.parallel_on_catsharp}
We complete the proof of \cref{prop.parallel_on_catsharp}.
\begin{enumerate}
	\item Show that $(\car{c}\otimes\car{d},\epsilon_{\car{c}\otimes\car{d}},\delta_{\car{c}\otimes\car{d}})$, as described in \cref{prop.parallel_on_catsharp}, forms a comonoid.
	\item Check that the construction $(\cat{C},\cat{D})\mapsto\cat{C}\otimes\cat{D}$ is functorial in $\cat{C},\cat{D}\in\smcat^\sharp$.
\qedhere
\end{enumerate}
\begin{solution}
\begin{enumerate}
    \item **
    \item **
\end{enumerate}
\end{solution}
\end{exercise}

The cofree construction works nicely with this monoidal product.

\begin{proposition}\label{prop.cofree_lax_monoidal}
The cofree functor $p\mapsto\cofree{p}$ is lax monoidal; in particular there is a map of polynomials $\yon\to\car{t}_\yon$, and for any $p,q\in\poly$ there is a natural map
\[
	\car{t}_p\otimes\car{t}_q\to\car{t}_{p\otimes q}.
\]
satisfying the usual conditions.
\end{proposition}
\begin{proof}
By \cref{prop.parallel_on_catsharp}, the left adjoint $U\colon\smcat^\sharp\to\poly$ is strong monoidal. A consequence of Kelly's doctrinal adjunction theorem \cite{kelly1974doctrinal} says that the right adjoint of an oplax monoidal functor is lax monoidal.
\end{proof}

\begin{exercise}
\begin{enumerate}
	\item What polynomial is $\car{t}_\yon$?
	\item What is the map $\yon\to\car{t}_\yon$ from \cref{prop.cofree_lax_monoidal}?
	\item Explain in words how to think about the map $\car{t}_p\otimes\car{t}_q\to\car{t}_{p\otimes q}$ from \cref{prop.cofree_lax_monoidal}, for arbitrary $p,q\in\poly$.
\qedhere
\end{enumerate}
\begin{solution}
\begin{enumerate}
    \item **
    \item **
    \item **
\end{enumerate}
\end{solution}
\end{exercise}


\section{Comodules over polynomial comonoids}

Just as we can define a category of comonoids within any monoidal category, we can further define a notion of comodules over such comonoids.
And much like how polynomial comonoids are categories, these comodules can also be described in category-theoretic terms we are already familiar with.
There is much more to say about comodules over polynomial comonoids than we have room for here---we will merely give a glimpse of the theory and applications.

\subsection{Left and right comodules}

When the monoidal category is not symmetric, left comodules and right comodules may differ significantly, so we define them separately (but notice that the diagrams for one are analogous to the diagrams for the other).

\begin{definition}[Left comodule]\label{def.left_comod}
In a monoidal category $(\Cat{C},\yon,\tri)$, let $\cat{C}=(\car{c},\epsilon,\delta)$ be a comonoid.
A \emph{left $\cat{C}$-comodule} is
\begin{itemize}
    \item an object $m\in\Cat{C}$, called the \emph{carrier}, equipped with
    \item a morphism $\car{c}\tri m\From{\lambda}m$ called the \emph{left coaction},
\end{itemize}
such that the following diagrams, collectively known as the \emph{left comodule laws}, commute:
\begin{equation} \label{eqn.left_comod_laws}
\begin{tikzcd}[ampersand replacement=\&]
	\car{c}\tri m\ar[d, "\epsilon\:\tri\:m"']\&
	m\ar[l, "\lambda"']\ar[dl, equal, bend left]\\
	m
\end{tikzcd}
\hspace{.6in}
\begin{tikzcd}[ampersand replacement=\&]
	\car{c}\tri m\ar[d, "\delta\:\tri\:m"']\&
	m\ar[l, "\lambda"']\ar[d, "\lambda"]\\
	\car{c}\tri\car{c}\tri m\&
	\car{c}\tri m\ar[l, "\car{c}\:\tri\:\lambda"]
\end{tikzcd}
\end{equation}
When referring to a left $\cat{C}$-comodule, we may omit its coaction if it can be inferred from context (or simply unspecified), identifying the comodule with its carrier.

A \emph{morphism} of left $\cat{C}$-comodules $m$ and $n$ is a morphism $\alpha\colon m\to n$ such that the following diagram commutes:
\[
\begin{tikzcd}
	\car{c}\tri m \ar[d, "\car{c}\:\tri\:\alpha"'] &
	m \ar[l] \ar[d, "\alpha"] \\
	\car{c}\tri n &
	n \ar[l]
\end{tikzcd}
\]
Here the top and bottom morphisms are the left coactions of $m$ and $n$.
\end{definition}

\begin{exercise} \label{exc.coalg_is_const_l_comod}
Show that the category of $\cat{C}$-coalgebras from \cref{def.coalgebra} is exactly the category of \textit{constant} left $\cat{C}$-comodules---i.e.\ the full subcategory of the category of left $\cat{C}$-comodules spanned by those left $\cat{C}$-comodules whose carriers are constant polynomials.
\begin{solution}
In \cref{def.left_comod}, if the carrier of the left $\cat{C}$-comodule is always chosen to be a constant polynomial, i.e.\ a set, then we recover \cref{def.coalgebra}.
Hence constant left $\cat{C}$-comodules are precisely left $\cat{C}$-coalgebras; their notions of morphisms coincide as well, so the categories they form are isomorphic.
\end{solution}
\end{exercise}

\begin{definition}[Right comodule]\label{def.right_comod}
In a monoidal category $(\Cat{C},\yon,\tri)$, let $\cat{D}=(\car{d},\epsilon,\delta)$ be a comonoid.
A \emph{right $\cat{D}$-comodule} is
\begin{itemize}
    \item an object $m\in\Cat{C}$, called the \emph{carrier}, equipped with
    \item a morphism $m\To{\rho}m\tri\car{d}$ called the \emph{right coaction},
\end{itemize}
such that the following diagrams, collectively known as the \emph{right comodule laws}, commute:
\begin{equation} \label{eqn.right_comod_laws}
\begin{tikzcd}[ampersand replacement=\&]
	m\ar[r, "\rho"]\ar[dr, equal, bend right]\&
	m\tri\car{d}\ar[d, "m\:\tri\:\epsilon"]\\\&
	m
\end{tikzcd}
\hspace{.6in}
\begin{tikzcd}[ampersand replacement=\&]
	m\ar[r, "\rho"]\ar[d, "\rho"']\&
	m\tri\car{d}\ar[d, "m\:\tri\:\delta"]\\
	m\tri\car{d}\ar[r, "\rho\:\tri\:\car{d}"']\&
	m\tri\car{d}\tri\car{d}
\end{tikzcd}
\end{equation}
When referring to a right $\cat{D}$-comodule, we may omit its coaction if it can be inferred from context (or unspecified), identifying the comodule with its carrier.

A \emph{morphism} of right $\cat{D}$-comodules $m$ and $n$ is a morphism $\alpha\colon m\to n$ such that the following diagram commutes:
\[
\begin{tikzcd}
	m \ar[r] \ar[d, "\alpha"'] &
	m\tri\car{d} \ar[d, "\alpha\:\tri\:\car{d}"] \\
	n \ar[r] &
	n\tri\car{d}
\end{tikzcd}
\]
Here the top and bottom morphisms are the right coactions of $m$ and $n$.
\end{definition}

\begin{exercise}
\begin{enumerate}
	\item Draw the equations of \eqref{eqn.left_comod_laws} using polyboxes.
	\item Draw the equations of \eqref{eqn.right_comod_laws} using polyboxes.
\qedhere
\end{enumerate}
\begin{solution}
**
\end{solution}
\end{exercise}

We can characterize left comodules as something far more familiar.

\begin{proposition}
Let $\cat{C}$ be a category.
A left $\cat{C}$-comodule can be identified (up to isomorphism) with a functor $\cat{C}\to\poly$.
\end{proposition}
\begin{proof}
**
\end{proof}

Similarly, a right comodule is not a foreign concept.

\begin{proposition}
Let $\cat{D}$ be a category.
A right $\cat{D}$-comodule $m$ can be identified (up to isomorphism) with a functor $\cat{D}\to\smset^{I\yon}$ for some discrete category $I\yon$, such that $m(\1)\iso I$.
\end{proposition}
\begin{proof}
**
\end{proof}


\begin{proposition}\label{prop.all_free_modules}
Let $\com{C}=(\car{c},\epsilon,\delta)$ be a comonoid in $\poly$. For any set $G$, the polynomial $\yon^G\tri\car{c}$ has a natural right $\com{C}$-comodule structure.
\end{proposition}
\begin{proof}
We use the map $(\yon^G\tri\delta)\colon(\yon^G\tri\car{c})\to(\yon^G\tri\car{c}\tri\car{c})$. It satisfies the unitality and associativity laws because $\car{c}$ does.
\end{proof}

We can think of elements of $G$ as ``generators''. Then if $i'\colon G\to\car{c}\tri\1$ assigns to every generator an object of a category $\cat{C}$, then we should be able to find the free $\cat{C}$-set that $i'$ generates.

\begin{proposition}
Functions $i'\colon G\to\car{c}\tri\1$ are in bijection with positions $i\in\yon^G\tri\car{c}\tri\1$. Let $m\coloneqq i^*(\yon^G\tri\car{c})$ and let $\rho_i$ be the induced right $\com{C}$-comodule structure from \cref{prop.right_modules_as_sums}. Then $\rho_i$ corresponds to the free $\cat{C}$-set generated by $i'$. 
\end{proposition}
\begin{proof}
The polynomial $m$ has the following form:
\[
m\cong\yon^{\sum_{g\in G}\car{c}[i'(g)]}
\]
In particular $\rho_i$ is a representable right $\com{C}$-comodule, and we can identify it with a $\cat{C}$-set by \cref{thm.tfae_c_sets}. The elements of this $\cat{C}$-set are pairs $(g, f)$, where $g\in G$ is a generator and $f\colon i'(g)\to\cod(f)$ is a morphism in $\cat{C}$ emanating from $i'(g)$. It is easy to see that the comodule structure induced by \cref{prop.all_free_modules} is indeed the free one.
\end{proof}

\begin{exercise}
Let $\cat{C}$ be a category and $i \in \cat{C}$ an object.
\begin{enumerate}
    \item Consider $i$ as a map $\yon \to \car{c}$.
    Show that the vertical-cartesian factorization of this map is $\yon \to \yon^{\car{c}[i]} \To{\varphi} \car{c}$.
    \item Use \cref{prop.comp_pres_cart} to show that $\yon^{\car{c}[i]} \tri \car{c} \to \car{c} \tri \car{c}$ is cartesian.
    \item Show that there is a commutative square
    \[
    \begin{tikzcd}
        \yon^{\car{c}[i]} \ar[r, "\delta^i"] \ar[d, "\varphi"'] & \yon^{\car{c}[i]} \tri \car{c} \ar[d, "\text{cart}"] \\
        \car{c} \ar[r, "\delta"'] & \car{c} \tri \car{c} \ar[ul, phantom, very near end, "\lrcorner"]
    \end{tikzcd}
    \]
    \item Show that this square is a pullback, as indicated.
    \item Show that $\delta^i$ makes $\yon^{\car{c}[i]}$ a right $\com{C}$-comodule.
    \qedhere
\end{enumerate}
\end{exercise}

The map $\delta^i$ can be seen as the restriction of $\delta \colon \car{c} \to \car{c} \tri \car{c}$ to a single starting position.

We can extend this to a functor $\cat{C} \to \bimod{\yon}{\cat{C}}$ that sends the object $i$ to $\yon^{\car{c}[i]}$. Given a morphism $f \colon i \to i'$ in $\cat{C}$, we get a function $\car{c}[i'] \to \car{c}[i]$ given by composition with $f$, and hence a map of polynomials $\yon^{\car{c}[f]} \colon \yon^{\car{c}[i]} \to \yon^{\car{c}[i']}$.

\begin{exercise}
\begin{enumerate}
    \item Show that $\yon^{\car{c}[f]}$ is a map of right $\com{C}$-comodules.
    \item Show that the construction $\yon^{\car{c}[f]}$ is functorial in $f$. \qedhere
\end{enumerate}
\end{exercise}

\begin{proposition}\label{prop.break_up_right_mods}
Let $\com{C}$ be a comonoid. For any set $I$ and right $\com{C}$-comodules $(m_i)_{i\in I}$, the coproduct $m\coloneqq \sum_{i\in I}m_i$ has a natural right-comodule structure. Moreover, each representable summand in the carrier $m$ of a right $\com{C}$-comodule is itself a right-$\com{C}$ comodule and $m$ is their sum.
\end{proposition}
\begin{proof}
**
\end{proof}

\begin{proposition}
If $m\in\poly$ is equipped with both a right $\com{C}$-comodule and a right $\com{D}$-comodule structure, we can naturally equip $m$ with a $(\com{C}\times\com{D})$-comodule structure.
\end{proposition}
\begin{proof}
It suffices by \cref{prop.break_up_right_mods} to assume that $m=\yon^M$ is representable. But a right $\com{C}$-comodule with carrier $\yon^M$ can be identified with a cofunctor $M\yon^M\to\com{C}$.

Thus if $\yon^M$ is both a right-$\com{C}$ comodule and a right-$\com{D}$ comodule, then we have comonoid morphisms $\com{C}\from M\yon^M\to\com{D}$. This induces a unique comonoid morphism $M\yon^M\to(\com{C}\times\com{D})$ to the product, and we identify it with a right-$(\com{C}\times\com{D})$ comodule on $\yon^M$.
\end{proof}






\subsection{Bicomodules}

We take special note of any object that is both a left comodule and a right comodule in compatible ways.

\begin{definition}[Bicomodule]\label{def.bicomodule}
In a monoidal category $(\Cat{C},\yon,\tri)$, let $\cat{C}$ and $\cat{D}$ be comonoid with carriers $\car{c}$ and $\car{d}$.
A \emph{$(\cat{C},\cat{D})$-bicomodule} is
\begin{enumerate}
	\item an object $m\in\Cat{C}$ that is both
	\item a left $\cat{C}$-comodule, with left coaction $\car{c}\tri m\From{\lambda}m$, and
	\item a right $\cat{D}$-comodule, with right coaction $m\To{\rho}m\tri\car{d}$,
\end{enumerate}
such that the following diagram, known as the \emph{coherence law}, commutes:
\begin{equation} \label{eqn.bimod_coherence}
\begin{tikzcd}[sep=small]
    & m \ar[dl, "\lambda"'] \ar[dr, "\rho"] & \\
    \car{c}\tri m \ar[dr, "\car{c}\:\tri\:\rho"'] & &
    m\tri\car{d} \ar[dl, "\lambda\:\tri\:\car{d}"] \\
    & \car{c}\tri m\tri\car{d}.
\end{tikzcd}
\end{equation}
We may denote such a bicomodule by $\cat{C}\bimodfrom[m]\cat{D}$ when its left and right coactions have yet to be specified or may be inferred from context---or even by $\car{c}\bimodfrom[m]\car{d}$ when the comonoid structures on $\car{c}$ and $\car{d}$ can be inferred from context as well.%
\footnote{The notation $\car{c}\bimodfrom\car{d}$ has a mnemonic advantage, as each $\tri$ goes in the correct direction: $\car{c}\tri m\from m$ and $m\to m\tri\car{d}$.
But it also looks like an arrow going backward from $\car{d}$ to $\car{c}$, which will turn out to have a semantic advantage as well; see \cref{**}.}

A \emph{morphism} of $(\cat{C},\cat{D})$-bicomodules is one that is a morphism of left $\cat{C}$-comodules and a morphism of right $\cat{D}$-comodules.
\end{definition}

We draw the commutativity of \eqref{eqn.bimod_coherence} using polyboxes.
\begin{equation}\label{eqn.bimod_coherence_polybox}
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\node (p1) {
  \begin{tikzpicture}[polybox, tos]
  	\node[poly, dom, "$m$" left] (m) {};
  	\node[poly, right= of m.south, yshift=-1ex, "\tiny$\car{c}$" below] (D) {};
  	\node[poly, above=of D, "\tiny$m$" above] (mm) {};
  	\node[poly, cod, right= of D.south, yshift=-1ex, "$\car{c}$" right] (DD) {};
  	\node[poly, cod, above=of DD, "$m$" right] (mmm) {};
  	\node[poly, cod, above=of mmm, "$\car{d}$" right] (C) {};
%
		\draw (m_pos) to[first] (D_pos);
		\draw (D_dir) to[climb] (mm_pos);
		\draw (mm_dir) to[last] (m_dir);
		\draw[double] (D_pos) to[first] (DD_pos);
		\draw[double] (DD_dir) to[last] (D_dir);
		\draw[double] (mm_pos) to[first] (mmm_pos);
		\draw (mmm_dir) to[climb] (C_pos);
		\draw (C_dir) to[last] (mm_dir);
	\end{tikzpicture}
	};
%
	\node (p2) [right=of p1] {
  \begin{tikzpicture}[polybox, tos]
  	\node[poly, dom, "$m$" left] (m') {};
  	\node[poly, right= of m'.south, yshift=-1ex, "\tiny$m$" below] (mm') {};
  	\node[poly, above=of mm', "\tiny$\car{d}$" above] (C') {};
  	\node[poly, cod, right= of mm'.south, yshift=-1ex, "$\car{c}$" right] (D') {};
  	\node[poly, cod, above=of D', "$m$" right] (mmm') {};
  	\node[poly, cod, above=of mmm, "$\car{d}$" right] (CC') {};
%
		\draw[double] (m'_pos) to[first] (mm'_pos);
		\draw (mm'_dir) to[climb] (C'_pos);
		\draw (C'_dir) to[last] (m'_dir);
		\draw (mm'_pos) to[first] (D'_pos);
		\draw (D'_dir) to[climb] (mmm'_pos);
		\draw (mmm'_dir) to[last] (mm'_dir);
		\draw[double] (C'_pos) to[first] (CC'_pos);
		\draw[double] (CC'_dir) to[last] (C'_dir);
	\end{tikzpicture}
	};	
	\node at ($(p1.east)!.5!(p2.west)$) {$=$};
\end{tikzpicture}
\end{equation}
This polybox equation implies that we can unambiguously write
\[
\begin{tikzpicture}[polybox, tos]
	\node[poly, dom, "$m$" left] (m) {};
	\node[poly, cod, right=of m, "$m$" right] (mm) {};
	\node[poly, cod, above=of mm, "$\car{d}$" right] (C) {};
	\node[poly, cod, below=of mm, "$\car{c}$" right] (D) {};
%
	\draw (m_pos) to[out=0, in=180] (D_pos);
	\draw (D_dir) to[climb] (mm_pos);
	\draw (mm_dir) to[climb] (C_pos);
	\draw (C_dir) to[last] (m_dir);
\end{tikzpicture}
\]
for any bicomodule $\car{c}\bimodfrom[m]\car{d}$.

\begin{exercise}
Let $\cat{C}=(\car{c},\epsilon,\delta)$ be a category. Recall from \cref{**} that $\yon$ has a unique category structure.
\begin{enumerate}
	\item Show that a left $\cat{C}$-module is the same thing as a $(\cat{C},\yon)$-bimodule.
	\item Show that a right $\cat{C}$-module is the same thing as a $(\yon,\cat{C})$-bimodule.
	\item Show that every polynomial $p\in\poly$ has a unique $(\yon,\yon)$-bimodule structure.
	\item Show that there is an isomorphism of categories $\poly\cong\bimod{\yon}{\yon}$.
\qedhere
\end{enumerate}
\begin{solution}
\begin{enumerate}
    \item **
    \item **
    \item **
    \item **
\end{enumerate}
\end{solution}
\end{exercise}

\subsection{More equivalences}

In \cref{**}, we saw that a cofunctor from a state category to a category $\cat{C}$ carries the same data as a $\cat{C}$-coalgebra, which is in turn equivalent to a discrete opfibration over $\cat{C}$ or a copresheaf on $\cat{C}$.
Then in \cref{**}, we showed that cartesian cofunctors to $\cat{C}$ is an equivalent notion as well.
We are now ready to show that several kinds of comodules are also equivalent to all of these concepts.

\begin{theorem}\label{thm.tfae_c_sets}
Given a polynomial comonoid $\cat{C}=(\car{c},\epsilon,\delta)$, the following comprise equivalent categories:
\begin{enumerate}
	\item functors $\cat{C}\to\smset$;
	\item discrete opfibrations over $\cat{C}$;
	\item cartesian cofunctors to $\com{C}$;
	\item $\com{C}$-coalgebras (sets with a coaction by $\com{C}$);
	\item constant left $\com{C}$-comodules;
	\item $(\com{C},\0)$-bicomodules;
	\item linear left $\com{C}$-comodules; and
	\item representable right $\com{C}$-comodules (opposite).
\end{enumerate}
In fact, all but the first comprise isomorphic categories; and up to isomorphism, any one of these can be identified with a cofunctor from a state category to $\cat{C}$.
\end{theorem}
\begin{proof}
\begin{description}
	\item[$1\simeq 2\cong 3$:] This was shown in \cref{prop.tfae_dopf}.
	\item[$3\cong 4$:] Given a cartesian cofunctor $(\pi_1,\pi^\sharp)\colon\cat{S}\cof\cat{C}$, let $S\coloneqq\Ob(\cat{S})$ and define a $\car{c}$-coalgebra structure $\alpha\colon S\to\car{c}\tri S$ on an object $s\in\Ob(\cat{S})$ and an emanating morphism $f\colon\pi_1(s)\to c'$ in $\cat{C}$ by
	\[
  \begin{tikzpicture}[polybox, mapstos]
  	\node[poly, dom, "$S$" left] (yX) {$\varnothing$\nodepart{two}$s$};
  	\node[poly, cod, right=1.8 of yX.south, yshift=-1ex, "$\car{c}$" right] (p) {$f$\nodepart{two}$\pi_1(s)$};
  	\node[poly, above=of p, "$S$" right] (p') {$\varnothing$\nodepart{two}$\cod\pi^\sharp_s(f)$};
  	\draw (yX_pos) to[first] node[below] {$\alpha_1$}(p_pos);
  	\draw (p_dir) to[climb] node[right] {$\alpha_2$} (p'_pos);
  	\draw (p'_dir) to[last] node[above left] {$!$} (yX_dir);
  \end{tikzpicture}
	\]
	We check that this is indeed a coalgebra using properties of cofunctors. For identities in $\com{C}$, we have
	\begin{align*}
  	\alpha_2(s,\id_{\pi_1(s)})&=
  	\cod\pi^\sharp_s(\id_{\pi_1(s)})\\&=
		\cod\id_{s}=s
	\end{align*}
	and for compositions in $\com{C}$ we have
	\begin{align*}
		\alpha_2(s, f\then g)&=
		\cod\left(\pi_s^\sharp(f\then g)\right)\\&=
		\cod\left(\pi_s^\sharp(f)\then\pi^\sharp_{\cod\pi^\sharp_s(f)}g\right)\\&=
		\cod\left(\pi^\sharp_{\cod\pi^\sharp_s(f)}g\right)\\&=
		\alpha_2(\alpha_2(s,f),g).
	\end{align*}
	Going backward, if we're given a coalgebra $\alpha\colon S\to\car{c}\tri S$, we obtain a function $\alpha_1\colon S\to\car{c}\tri\1$ and we define $\car{s}\coloneqq \alpha_1^*\car{c}$ and the cartesian map $\varphi\coloneqq(\alpha_1,\id)\colon\car{s}\to\car{c}$ to be the base change from \cref{prop.basechange}. We need to show $\car{s}$ has a comonoid structure $(\car{s},\epsilon,\delta)$ and that $\varphi$ is a cofunctor. We simply define the eraser $\epsilon\colon\car{s}\to\yon$ using $\alpha_1$ and the eraser on $\car{c}$:
	\[
	\begin{tikzpicture}[polybox, mapstos]
  	\node[poly, dom, "$\car{s}$" below] (c) {$\id_{\alpha_1(s)}$\nodepart{two}$s\vphantom{s_1}$};
  	\node[poly, cod, right=of c, "$\car{c}$" below] (c') {$\id_{\alpha_1{s}}$\nodepart{two}$\alpha_1(s)$};
  	\draw (c_pos) -- node[below] {$\alpha_1$} (c'_pos);
  	\draw[double] (c'_dir) -- (c_dir);
		\draw (c'_pos) to[climb'] node[right] {$\epsilon_\car{c}$} (c'_dir);
	\end{tikzpicture}
	\]
 We give the duplicator $\delta\colon\car{s}\to\car{s}\tri\car{s}$ using $\alpha_2$ for the codomain, and using the composite $\then$ from $\car{c}$:
	\[
  \begin{tikzpicture}[polybox, mapstos]
  	\node[poly, dom, "$\car{s}$" left] (yX) {$f\then g$\nodepart{two}$s$};
  	\node[poly, cod, right=2.5 of yX.south, yshift=-1ex, "$\car{s}$" right] (p) {$f$\nodepart{two}$s$};
  	\node[poly, cod, above=of p, "$\car{s}$" right] (p') {$g$\nodepart{two}$\alpha_2(s,f)$};
  	\draw[double] (yX_pos) to[first] (p_pos);
  	\draw (p_dir) to[climb] node[right] {$\cod$} (p'_pos);
  	\draw (p'_dir) to[last] node[above left] {$\comp$} (yX_dir);
  \end{tikzpicture}	
  \]
  In \cref{exc.tfae_c_sets} we check that $(\car{s},\epsilon,\delta)$ really is a comonoid, that $(\alpha_1,\id)\colon\car{s}\cof\car{c}$ is a cofunctor, that the roundtrips between cartesian cofunctors and coalgebras are identities, and that these assignments are functorial.
	\item[$4\cong5$:]This is straightforward and was mentioned in \cref{def.coalgebra}.
	\item[$5\cong6$:]A right $\0$-comodule is in particular a polynomial $m\in\poly$ and a map $\rho\colon m\to m\tri\0$ such that $(m\tri\epsilon)\circ\rho=\id_m$. This implies $\rho$ is monic, which itself implies by \cref{prop.monics_in_poly} that $m$ must be constant since $m\tri\0$ is constant. This makes $m\tri\epsilon$ the identity, at which point $\rho$ must also be the identity. Conversely, for any set $M$, the corresponding constant polynomial is easily seen to make the diagrams in \eqref{eqn.bimod_right} commute.
	\item[$5\cong7$:] By the adjunction in \cref{prop.adjoint_quadruple} and the fully faithful inclusion $\smset\to\poly$ of sets as constant polynmials, \cref{prop.ff_const_set_to_poly}, we have isomorphisms
	\[\poly(S\yon,\car{c}\tri S\yon)\cong\smset(S,\car{c}\tri S\yon\tri\1)=\smset(S,\car{c}\tri S)\cong\poly(S,\car{c}\tri S).\]
	One checks easily that if $S\yon\to\car{c}\tri S\yon)$ corresponds to $S\to\car{c}\tri S$ under the above isomorphism, then one is a left comodule iff the other is.
	\item[$7\cong8$:] By \eqref{eqn.flip_reps_lins} we have a natural isomorphism
	\[
		\poly(S\yon,\car{c}\tri S\yon)\cong\poly(\yon^S,\yon^S\tri\car{c}).
	\]
	In pictures,
	\[
	\begin{tikzpicture}
		\node (p1) {
		\begin{tikzpicture}[polybox, tos]
			\node[poly, linear dom] (s) {};
			\node[poly, cod, right=of s.south, yshift=-1ex] (c) {};
			\node[poly, linear cod, above=of c] (s') {};
    	\node[left=0pt of s_pos] {$S$};
    	\node[right=0pt of c_pos] {$\car{c}(\1)$};
    	\node[right=0pt of c_dir] {$\car{c}[\ ]$};
    	\node[right=0pt of s'_pos] {$S$};
			\draw (s_pos) to[first] node[below] {$f$} (c_pos);
			\draw (c_dir) to[climb] node[right] {$g$} (s'_pos);
			\draw (s'_dir) to[last] node[above] {$!$} (s_dir);
		\end{tikzpicture}
		};
		\node (p2) [right=2 of p1] {
		\begin{tikzpicture}[polybox, tos]
			\node[poly, pure dom] (s) {};
			\node[poly, pure cod, right=of s.south, yshift=-1ex] (s') {};
			\node[poly, cod, above=of s'] (c) {};
    	\node[left=0pt of s_dir] {$S$};
    	\node[right=0pt of c_pos] {$\car{c}(\1)$};
    	\node[right=0pt of c_dir] {$\car{c}[\ ]$};
    	\node[right=0pt of s'_dir] {$S$};
			\draw (s_pos) to[first] node[below] {$!$} (s'_pos);
			\draw (s'_dir) to[climb] node[right] {$f$} (c_pos);
			\draw (c_dir) to[last] node[above] {$g$} (s_dir);
		\end{tikzpicture}		
		};
	\end{tikzpicture}
	\]
\end{description}
\noindent
The last claim was proven in \cref{prop.ds_dopf}.
\end{proof}

\begin{exercise}\label{exc.tfae_c_sets}
Complete the proof of \cref{thm.tfae_c_sets} ($3\cong 4$) by proving the following.
\begin{enumerate}
	\item Show that $(\car{s},\epsilon,\delta)$ really is a comonoid.
	\item Show that $(\alpha_1,\id)\colon\car{s}\cof\car{c}$ is a cofunctor.
	\item Show that the roundtrips between cartesian cofunctors and coalgebras are identities.
	\item Show that the assignment of a $\com{C}$-coalgebra to a cartesian cofunctor over $\cat{C}$ is functorial.
	\item Show that the assignment of a cartesian cofunctor over $\cat{C}$ to a $\com{C}$-coalgebra is functorial.
\qedhere
\end{enumerate}
\end{exercise}

Let $\cat{C}$ be a category. Under the above correspondence, the terminal functor $\cat{C}\to\smset$ corresponds to the identity discrete opfibration $\cat{C}\to\cat{C}$, the identity cofunctor $\com{C}\to\com{C}$, a certain left $\com{C}$ comodule with carrier $\com{C}(\1)\yon$ which we call the \emph{canonical left $\com{C}$-comodule}, a certain constant left $\com{C}$ comodule with carrier $\com{C}(\1)$ which we call the \emph{canonical $(\com{C},\0)$-bicomodule}, and a certain representable right $\com{C}$-comodule with carrier $\yon^{\com{C}(\1)}$ which we call the \emph{canonical right $\cat{C}$-comodule}.

\begin{exercise}
For any object $c\in \cat{C}$, consider the representable functor $\cat{C}(c,-)\colon\cat{C}\to\smset$. What does it correspond to as a
\begin{enumerate}
	\item discrete opfibration over $\cat{C}$?
	\item cartesian cofunctor to $\com{C}$?
	\item linear left $\com{C}$-comodule?
	\item constant left $\com{C}$-comodule?
	\item $(\com{C},\0)$-bicomodule?
	\item representable right $\com{C}$-comodule?
	\item dynamical system with comonoid interface $\com{C}$?
\qedhere
\end{enumerate}
\end{exercise}

\begin{exercise}
We saw in \cref{thm.tfae_c_sets} that the category $\bimod{\cat{C}}{\0}$ of $(\cat{C},\0)$-bicomodule has a very nice structure: it's the topos of copresheaves on $\cat{C}$. 
\begin{enumerate}
	\item What is a $(\0,\cat{C})$-bicomodule?
	\item What is $\bimod{\0}{\cat{C}}$?
\qedhere
\end{enumerate}
\end{exercise}

\subsection{Bicomodules are parametric right adjoints}

There is an equivalent characterization of bicomodules over a pair of polynomial comonoids due to Richard Garner.

\begin{proposition}[Garner]\label{prop.prafunctor}
Let $\cat{C}$ and $\cat{D}$ be categories; the following conditions on a functor $F\colon\smset^{\cat{C}}\to\smset^{\cat{D}}$ are equivalent.
\begin{enumerate}
	\item $F$ is composition with a $(\cat{D},\cat{C})$-bicomodule.
	\item $F$ is a prafunctor.
	\item $F$ profunctor + discrete opfibration
	\item $F$ preserves connected limits.
\end{enumerate}
\end{proposition}

When a polynomial
\[
m\coloneqq\sum_{i\in m(\1)}\yon^{m[i]}
\]
is given the structure of a $(\cat{D},\cat{C})$-bicomodule, the symbols in that formula are given a hidden special meaning:
\[
  m(\1)\in\smset^{\cat{D}}
  \qqand
	m[i]\in\smset^{\cat{C}}
\]
Thus $m(1)$ is a database instance on $\cat{D}$; in particular, each position in $i\in m(\1)$ is a row in that instance. And each $m[i]$ is a database instance on $\cat{C}$; in particular, each direction $d\in m[i]$ is a row in that instance.

Before we knew about bicomodule structures, what we called positions and directions---and what we often think of as outputs and inputs of a system---were understood as each forming an ordinary set. In the presence of a bicomodule structure, the positions $m(\1)$ have been organized into a $\cat{D}$-set and the directions $m[i]$ have been organized into a $\cat{C}$-set for each position $i$. We are listening for $\cat{C}$-sets and positioning ourselves in a $\cat{D}$-set.


\begin{definition}[Prafunctor]
Let $\cat{C}$ and $\cat{D}$ be categories. A \emph{prafunctor} (also called a \emph{parametric right adjoint functor}) $\smset^{\cat{C}}\to\smset^{\cat{D}}$ is one satisfying any of the conditions of \cref{prop.prafunctor}.
\end{definition}

\subsection{Bicomodules in dynamics}

We conclude with a peek at how bicomodules can model dynamical systems themselves.

\begin{example}[Cellular automata]\label{ex.cellular_bimod}
In \cref{ex.graph_interaction,exc.conway} we briefly discussed cellular automata; here we will discuss another way that cellular automata show up, this time in terms of bicomodules.

Suppose that $\src,\tgt\colon A\tto V$ is a graph, and consider the polynomial
\[
  g\coloneqq\sum_{v\in V}\yon^{\src\inv(v)}
\]
so that positions are vertices and directions are emanating arrows. It carries a natural bicomodule structure
\[
V\yon\bimodfrom[g]V\yon
\]
where the right structure map uses $\tgt$; see \cref{exc.cellular_bimod} for details. A bicomodule
\[
V\yon\bimodfrom[T]\0
\]
can be identified with a functor $T\colon V\to\smset$, i.e.\ it assigns to each vertex $v\in V$ a set. Let's call $T(v)$ the color set at $v$; for many cellular automata we will put $T(v)\cong\2$ for each $v$.

Then a cellular automata on $g$ with color sets $T$ is given by a map
\[
\begin{tikzcd}
	V\yon\ar[r, bimr-biml, "g"]\ar[rr, bend right=40pt, bimr-biml, "T"', "" name=T]&
	V\yon\ar[r, bimr-biml, "T"]\ar[to=T, Rightarrow, "\alpha"]&
	\0
\end{tikzcd}
\]
Indeed, for every vertex $v\in V$ the map $\alpha$ gives a function
\[
\prod_{\src(a)=v}T(\tgt(a))\Too{\alpha_v} T(v),
\]
which we call the \emph{update} function. In other words, given the current color at the target of each arrow emanating from $v$, the function $\alpha_v$ returns a new color at $v$.

Note that if $V\in\bimod{V\yon}{\0}$ is the terminal object, then the composite $V\yon\bimodfrom[g]V\yon\bimodfrom[V]\0$ is again $V$.
\end{example}

\begin{exercise}\label{exc.cellular_bimod}
Let $\src,\tgt\colon A\tto V$ and $g$ and $T$ be as in \cref{ex.cellular_bimod}.
\begin{enumerate}
	\item Give the structure map $\lambda\colon g\to V\yon\tri g$
	\item Give the structure map $\rho\colon g\to g\tri V\yon$.
	\item Give the set $T$ and the structure map $T\to V\yon\tri T$ corresponding to the functor $V\to\smset$ that assigns $\2$ to each vertex.
\qedhere
\end{enumerate}
\begin{solution}
\begin{enumerate}
    \item **
    \item **
    \item **
\end{enumerate}
\end{solution}
\end{exercise}

\begin{example}[Running a cellular automaton]
Let $g$ be a graph on vertex set $V$, let $T$ assign a color set to each $v\in V$, and let $\alpha$ be the update function for a cellular automaton. As in \cref{ex.cellular_bimod}, this is all given by a diagram
\[
\begin{tikzcd}
	V\yon\ar[r, bimr-biml, "g"]\ar[rr, bend right=40pt, bimr-biml, "T"', "" name=T]&
	V\yon\ar[r, bimr-biml, "T"]\ar[to=T, Rightarrow, "\alpha"]&
	\0
\end{tikzcd}
\]
To run the cellular automaton, one simply chooses a starting color in each vertex. We call this an initialization; it is given by a map of bicomodules
\begin{equation}\label{eqn.starting_color_v}
\begin{tikzcd}
	V\yon
		\ar[r, bimr-biml, bend left, "V\yon"]
		\ar[r, bimr-biml, bend right, "T"']\ar[r, phantom, "\hphantom{\scriptstyle\sigma}\Downarrow\scriptstyle\sigma"]&
	V\yon
\end{tikzcd}
\end{equation}

Now to run the cellular automaton on that initialization for $k\in\nn$ steps is given by the composite
\[
\begin{tikzcd}
	V\yon\ar[d, equal]\ar[r, bimr-biml, "g"]\ar[rrrr, bend left, "V"]&
	\cdots\ar[r, bimr-biml, "g"]&
	V\yon\ar[d, equal]\ar[r, bimr-biml, "g"]&
	V\yon\ar[d, equal]\ar[r, bimr-biml, "g"]&
	\0\ar[d, equal]\ar[dl, phantom, "\Downarrow\scriptstyle\sigma"]\\
	V\yon\ar[d, equal]\ar[r, bimr-biml, "g"]&	
	\cdots\ar[r, bimr-biml, "g"]&
	V\yon\ar[d, equal]\ar[r, bimr-biml, "g"]&
	V\yon\ar[r, bimr-biml, "T"]&
	\0\ar[d, equal]\ar[dll, phantom, "\Downarrow\scriptstyle\alpha"]\\
	V\yon\ar[d, equal]\ar[r, bimr-biml, "g"]&
	\cdots\ar[r, bimr-biml, "g"]&|[alias=V]|
	V\yon\ar[rr, bimr-biml, "T"]&&
	\0\ar[d, equal]\\
	V\yon\ar[rrrr, bimr-biml, "T"', "" name=T]&&&&
	\0
	\ar[from=V, to=V|-T, Rightarrow, "\alpha\circ\cdots\circ\alpha"]
\end{tikzcd}
\]
\end{example}

\begin{exercise}
Explain why \eqref{eqn.starting_color_v} models an initialization, i.e.\ a way to choose a starting color in each vertex.
\begin{solution}
**
\end{solution}
\end{exercise}


%-------- Section --------%
\section{Summary and further reading}

In this chapter we gave more of the theory of $\tri$-comonoids, sometimes called polynomial comonads. We began by defining an adjunction
\[
\adj{\smcat^\sharp}{U}{\cofree{-}}{\poly}
\]
where $\cofree{p}$ is the cofree comonoid $\cofree{p}$ associated to any polynomial $p$, and we gave intuition for it in terms of $p$-trees. A $p$-tree is a (possibly infinite) tree for which each vertex is labeled by a position $i\in p(\1)$ and its outgoing arrows are each labeled by an element of $p[i]$. The category corresponding to $\cofree{p}$ has $p$-trees as its objects; the morphisms emanating from such a $p$-tree are the finite rooted paths up the tree, and the codomain of such a path is the tree rooted at its endpoint.

We then briefly discussed some other properties of $\smcat^\sharp$ including a formal proof of the fact that it has all limits and colimits. Colimits in $\smcat^\sharp$ are created by, i.e.\ fit nicely with, colimits in $\poly$, but limits are quite strange; we did not really discuss them here, but for example the product in $\smcat^\sharp$ of the walking arrow \fbox{$\bullet\to\bullet$} with itself has infinitely-many objects! 

We then moved on to left-, right-, and bicomodules between polynomial comonoids. In particular, we showed that left $\cat{C}$-comodules can be identified with functors $\cat{C}\to\poly$, and that $(\cat{C},\cat{D})$-bicomodules correspond to parametric right adjoint functors $\smset^\cat{D}\to\smset^\cat{C}$. This idea was due to Richard Garner; it is currently unpublished, but can be found in video form here: \url{https://www.youtube.com/watch?v=tW6HYnqn6eI}.



%-------- Section --------%
\section{Exercise solutions}
\Closesolutionfile{solutions}
{\footnotesize
\input{solution-file7}}

\end{document}