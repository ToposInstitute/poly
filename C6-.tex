\documentclass[DynamicalBook]{subfiles}
\begin{document}
%


\setcounter{chapter}{5}%Just finished 4.


\chapter{A different category of categories}\label{chapter.5}

We have seen that the category of polynomial functors---sums of representables $\smset\to\smset$ and the natural transformations between them---has quite a bit of well-interoperating mathematical structure. Further, it is an expressive way to talk about dynamical systems that can change their interface and wiring pattern based on their internal states.

In this chapter we will discuss a monoidal structure on $\poly$ that is quite easy from the mathematical point of view---it is simply composition---but which is again remarkable both in terms of its semantics and the phenomena that emerge mathematically. 

In particular, we will see that the comonoids for the composition monoidal structure on $\poly$ are precisely categories. However, the morphisms are different---they are often called \emph{cofunctors}---and so we get a second category $\smcat^\sharp$ of categories and cofunctors. But the core groupoids of each---the groupoid of small categories and all functor isomorphisms between them, as well as the groupoid of small categories and all cofunctor isomorphisms between them---are isomorphic as groupoids. In other words, the following slogan is justified:
\slogan{Polynomial comonads are precisely categories.}

Cofunctors are not too familiar, but we will explain how to think of them in a variety of ways. We will see that whereas a functor $\cat{C}\to\cat{D}$ gives a kind of ``picture'' of $\cat{C}$ inside $\cat{D}$, a cofunctor $\cat{C}\cof\cat{D}$ gives a kind of $\cat{D}$-shaped ``crystallization'' of $\cat{C}$, one that is intuitively more geometric, more like creating neighborhoods. We will see in \cref{chapter.6} that there is another kind of morphism between comonoids, namely the bimodules, that are perhaps more familiar: they are the so-called \emph{parametric right adjoints}, or in perhaps more friendly terms, \emph{data migration functors} between copresheaf categories.

The plan for this chapter is to first introduce what is perhaps the most interesting monoidal structure on $\poly$, namely the composition product; we do so in \cref{sec.composition_prod}. We'll give a bunch of examples and ways to think about it in terms that relate to dynamical systems and our work so far. Then in \cref{sec.comonoids_in_poly} we'll discuss comonoids in $\poly$ and explain why they are categories in down-to-earth, set-theoretic terms. We will also discuss the morphisms between them.

Finally in \cref{sec.cofree} we will discuss the cofree comonoid construction that takes any polynomial and returns a category. We will show how it relates to decision trees, as one may see in combinatorial game theory.

%-------- Section --------%
\section{The composition product}\label{sec.composition_prod}

In \cref{chapter.4} we saw that the category $\poly$ of polynomial functors---otherwise known as dependent lenses---is a very well-behaved category in which to think about dynamical systems of quite a general nature.

But we left one thing---what in some sense is the most interesting part of the story---out entirely. That thing is quite simple to state, and yet has profound consequences. Namely: polynomials can be composed:
\[
\yon^\2\circ(\yon+\1)=(\yon+\1)^\2\cong\yon^\2+\2\yon+\1.
\]
What could be simpler?%
\footnote{If you're thinking ``What could be more boring?'', don't forget that our job is to connect this to the material in \cref{sec.c5_intro}. If that payoff doesn't intrigue you, then this chapter is not for you.}

It turns out that this operation, which we'll see soon is a monoidal product, has a lot to do with time. There is a strong sense---made precise in \cref{prop.poly_closed_comp}---in which the polynomial $p\circ q$ represents ``starting at a position $i$ in $p$, choosing a direction in $p[i]$, landing at a position $j$ in $q$, choosing a direction in $q[j]$, and then landing... somewhere.''

The composition product has many surprises up its sleeve, as we'll see. We've told many of them to you already in \cref{subsec.math_theory}. We won't amass them all here; instead, we'll take you through the story step by step. But as a preview, this chapter will get us into decision trees, databases, and more dynamics, and it's all based on $\circ$.

As in \cref{eqn.sum_p1}, we'll continue to denote polynomials with the following notation
\begin{equation}\label{eqn.sum_p1_again}
p\cong\sum_{i\in p(\1)}\yon^{p[i]},
\end{equation}
and refer to $p(\1)$ as the set of positions, and for each $i\in p(\1)$ we'll refer to $p[i]$ as the set of direction at position $i$.

%---- Subsection ----%
\subsection{Defining the composition product}
We begin with the definition of composition product.

\begin{proposition}\label{prop.poly_closed_comp}
Suppose $p,q\in\poly$ are polynomial functors $p,q\colon\smset\to\smset$. Then their composite $p\circ q$ is again a polynomial functor and we have the following isomorphisms
\[
p\circ q\cong\sum_{i\in p(\1)}\prod_{d\in p[i]}\sum_{j\in q(\1)}\prod_{e\in q[j]}\yon.
\]
\end{proposition}
\begin{proof}
We can rewrite \cref{eqn.sum_p1_again} for $p$ and $q$ as
\[
p\cong\sum_{i\in p(\1)}\prod_{d\in p[i]}\yon
\qqand
q\cong\sum_{j\in q(\1)}\prod_{e\in q[j]}\yon.
\]
For any set $X$ we have $(p\circ q)(X)=p(q(X))=p(\sum_j\prod_e X)=\sum_i\prod_d\sum_j\prod_eX$, so \eqref{eqn.composite_formula} is indeed the formula for their composite. To see this is a polynomial, we use \cref{prop.completely_distributive}, which says we can rewrite the $\prod\sigma$ in \eqref{eqn.composite_formula} as a $\sigma\prod$. The result 
\begin{equation}\label{eqn.composition_formula_sums_first}
  p\circ q\cong
  \scalebox{1.3}{$\displaystyle
  \sum_{i\in p(\1)}\sum_{j_i\colon p[i]\to q(\1)}\yon^{\sum_{d\in p[i]}q[j_i(d)]},$}
\end{equation}
(written slightly bigger for clarity) is clearly a polynomial.
\end{proof}

The composition of polynomials will be extremely important in the story that follows. However, we only sometimes think of it as composition; more often we think of it as a certain operation on arenas, or collections of corollas. Because we may wish to use $\circ$ to denote composition in arbitrary categories, we use a special symbol for polynomial composition namely
\[
p\tri q\coloneqq p\circ q.
\]
The symbol $\tri$ looks a bit like the composition symbol, in that it is an open shape, and when handwriting it fast, it's ok if it morphs into a $\circ$, but we'll soon see that it is quite evocative in terms of trees, and again it leaves $\circ$ for other uses.

We repeat the important formulas from \cref{prop.poly_closed_comp} in the new notation:
\begin{equation}\label{eqn.composite_formula}
p\tri q\cong\sum_{i\in p(\1)}\prod_{d\in p[i]}\sum_{j\in q(\1)}\prod_{e\in q[j]}\yon.
\end{equation}

\[
\begin{tikzpicture}[polybox, baseline=(helper)]
	\node[poly] (p) {$d:p[i]$\nodepart{two}$i:p(\1)$};
	\node[poly, above=of p] (q) {$e:q[j]$\nodepart{two}$j:q(\1)$};
	\coordinate (helper) at ($(p.north)!.5!(q.south)$);
\end{tikzpicture}
\quad\cong\quad
\begin{tikzpicture}[polybox, baseline=(p.east)]
	\node[poly] (p) {$(d:p[i], e:q[j(d)]$)\nodepart{two}$(i:p(1), j: p[i]\to q(\1))$};
\end{tikzpicture}
\]

\begin{exercise}
Let's consider \eqref{eqn.composition_formula_sums_first} piece by piece, with concrete polynomials $p\coloneqq\yon^\2+\yon^\1$ and $q\coloneqq \yon^\3+\1$.
\begin{enumerate}
	\item What is $q^\2$?
	\item What is $\yon^2\tri q$? 
	\item What is $\yon^\1\tri q$?
	\item What is $(\yon^\2+\yon)\tri q$? This is what $p\tri q$ ``should be''.
	\item How many functions $j_1\colon p[1]\to q(\1)$ are there?
	\item For each function $j_1$ as above, what is $\sum_{d\in p[1]} q[j_1(d)]$?
	\item How many functions $j_2\colon p[2]\to q(\2)$ are there?
	\item For each function $j_2$ as above, what is $\sum_{d\in p[2]} q[j_2(d)]$?
	\item Write out $\sum_{i\in p(\1)}\sum_{j_i\colon p[i]\to q(\1)}\yon^{\sum_{d\in p[i]}q[j_i(d)]}$.
	\item Does the result agree with what $p\tri q$ should be?
\qedhere
\end{enumerate}
\end{exercise}

\begin{exercise}\label{exc.composites_of_specials}
\begin{enumerate}
	\item If $p$ and $q$ are representable, show that $p\tri q$ is too. Give a formula for it.
	\item If $p$ and $q$ are linear, show that $p\tri q$ is too. Give a formula for it.
	\item If $p$ and $q$ are constant, show that $p\tri q$ is too. Give a formula for it.
\qedhere
\end{enumerate}
\end{exercise}

In terms of corollas, composition product $p\tri q$ is given by glueing $q$-corollas onto the tips of $p$-corollas in every possible way. Let's say $p\coloneqq\yon^\2+\yon$ and $q\coloneqq\yon^\3+\1$, which as in \cref{eqn.trees_for_gazing} we draw as follows
\begin{equation}\label{eqn.pq_misc39}
\begin{tikzpicture}[rounded corners]
	\node (p1) [draw, blue!50!black, "$p$" above] {
	\begin{tikzpicture}[trees, sibling distance=2.5mm]
    \node["\tiny 1" below] (1) {$\bullet$} 
      child {}
      child {};
    \node[right=.5 of 1,"\tiny 2" below] (2) {$\bullet$} 
      child {};
  \end{tikzpicture}
  };
%
	\node (p2) [draw, red!50!black, right=2 of p1, "$q$" above] {
	\begin{tikzpicture}[trees, sibling distance=2.5mm]
    \node["\tiny 1" below] (1) {$\bullet$} 
      child {}
      child {}
      child {};
    \node[right=.5 of 1,"\tiny 2" below] (4) {$\bullet$}
    ;
  \end{tikzpicture}
  };
\end{tikzpicture}
\end{equation}
Then their composite $p\tri q$ would be drawn like so:
\[
\begin{tikzpicture}[rounded corners]
	\node (p1) [draw, "$p\tri q$" above] {
	\begin{tikzpicture}[trees,
		level 1/.style={sibling distance=8mm},
	  level 2/.style={sibling distance=2.5mm}]
    \node[blue!50!black] (1) {$\bullet$} 
      child {node[red!50!black] {$\bullet$} 
      	child
				child
				child
			}
      child {node[red!50!black] {$\bullet$} 
      	child
				child
				child
			};
%
    \node[blue!50!black, right=1.7 of 1] (2) {$\bullet$} 
      child {node[red!50!black] {$\bullet$} 
      	child
				child
				child
			}
      child {node[red!50!black] {$\bullet$} 
			};
%
    \node[blue!50!black, right=1.5 of 2] (3) {$\bullet$} 
      child {node[red!50!black] {$\bullet$} 
			}
      child {node[red!50!black] {$\bullet$} 
      	child
				child
				child
			};
%
    \node[blue!50!black, right=1.5 of 3] (4) {$\bullet$} 
      child {node[red!50!black] {$\bullet$}
			}
      child {node[red!50!black] {$\bullet$} 
			};
%
    \node[blue!50!black, right=1.2 of 4] (5) {$\bullet$} 
      child {node[red!50!black] {$\bullet$} 
      	child
				child
				child
			};
%
    \node[blue!50!black, right=1.2 of 5] (6) {$\bullet$} 
      child {node[red!50!black] {$\bullet$} 
			};
  \end{tikzpicture}
  };
\end{tikzpicture}
\]
It has six positions; the first has six directions, the second, third, and fifth have three directions, and the fourth and sixth have no directions. In total, we read off that $p\tri q$ is isomorphic to $\yon^\6+\3\yon^\3+\2$.

\begin{exercise}
Use $p,q$ as in \cref{eqn.pq_misc39} and $r\coloneqq \yon^\2+\1$ in the following.
\begin{enumerate}
	\item Draw $q\tri p$.
	\item Draw $p\tri p$.
	\item Draw $p\tri p\tri 1$.
	\item Draw $r\tri r$.
	\item Draw $r\tri r\tri r$.
\qedhere
\end{enumerate}
\end{exercise}

\begin{exercise}
Let $A$ and $B$ be arbitrary sets, and let $p$ be an arbitrary polynomial. Which of the following isomorphisms exist?
\begin{enumerate}
	\item $(A\yon)\otimes(B\yon) \cong (A\yon)\tri (B\yon)$?
	\item $\yon^A\otimes\yon^B\cong\yon^A\tri\yon^B$?
	\item $A\otimes B\cong A\tri B$?
	\item $A\yon\otimes p\cong A\yon\tri p$?
	\item $\yon^A\otimes p\cong \yon^A\tri p$?
	\item $p\otimes A\yon\cong p\tri A\yon$?
	\item $p\otimes \yon^A\cong p\tri\yon^A$?
\qedhere
\end{enumerate}
\end{exercise}

\begin{example}
For any $p$ and $q$ there is an interesting map $o_{p,q}\colon p\otimes q\to p\tri q$ that orders the operation. It looks like this:
\[
\begin{tikzpicture}[polybox, mapstos]
	\node[poly, dom] (p) {$(d,e)$\nodepart{two}$(i,j)$};
	\node[poly, cod, right= 1.5cm of p.south, yshift=-1ex] (q) {$d$\nodepart{two}$i$};
	\node[poly, cod, above=of q] (r) {$e$\nodepart{two}$j$};
  	\draw (p_pos) to[first] (q_pos);
  	\draw (q_dir) to[climb] (r_pos);
  	\draw (r_dir) to[last] (p_dir);
\end{tikzpicture}
\]
In other words, $p\tri q$ is allowed to have $j$ depend on $d$, whereas $p\otimes q$ is not; the map is in some sense the inclusion of the order-independent part. And of course we can flip the order using the symmetry $q\otimes p\cong p\otimes q$. This is, we just as well have a map $p\otimes q\to q\tri p$.

Both $\otimes$ and $\tri$ have the same monoidal unit, the identity functor $\yon$, and the identity is the unique map $\yon\to\yon$. The maps $o_{p,q}$ should commute with associators and unitors. 

This can be used in the following way. Maps $p\to q\tri r$ into composites are fairly easy to diagram and understand, whereas maps $q\tri r\to p$ are not so easy to think about. However, given such a map, one may always compose it with $o_{q,r}$ to obtain a map $q\otimes r\to p$; this is quite a bit simpler to think about, more like a wiring diagram.
\end{example}

\begin{example}\label{ex.apply_2}
For any set $X$ and polynomial $p$, we can take $p(X)\in\smset$; indeed $p\colon\smset\to\smset$ is a functor! In particular, by this point you've seen us write $p(\1)$ hundreds of times. But we've also seen that $X$ is itself a polynomial, namely a constant one.

It's not hard to see that $p(X)\cong p\tri X$. Here's a picture, where $p\coloneqq\yon^\3+\yon+\1$ and $X\coloneqq\2$.
\[
\begin{tikzpicture}[rounded corners]
	\node (p1) [draw, blue!50!black, "$p$" left] {
	\begin{tikzpicture}[trees, sibling distance=2.5mm]
    \node["\tiny 1" below] (1) {$\bullet$} 
      child {}
      child {}
      child {};
    \node[right=.5 of 1,"\tiny 2" below] (2) {$\bullet$} 
      child {};
      ;
    \node[right=.5 of 2,"\tiny 3" below] (3) {$\bullet$} 
      ;
  \end{tikzpicture}
  };
%
	\node (p2) [draw, red!50!black, right=2 of p1, "$X$" above] {
	\begin{tikzpicture}[trees, sibling distance=2.5mm]
    \node["\tiny 1" below] (1) {$\bullet$};
    \node[right=.5 of 1,"\tiny 2" below] (4) {$\diamond$};
    \node[above=10pt of 4] {};
    ;
  \end{tikzpicture}
  };
\end{tikzpicture}
\]
Let's see how $(\yon^\3+\yon+\1)\tri\2$ looks.
\[
\begin{tikzpicture}[rounded corners]
	\node (p1) [draw, "$p\tri X$" above] {
	\begin{tikzpicture}[trees, sibling distance=2.5mm]
    \node[blue!50!black] (1) {$\bullet$} 
      child {node[red!50!black] {$\bullet$}}
      child {node[red!50!black] {$\bullet$}}
      child {node[red!50!black] {$\bullet$}};
    \node[blue!50!black, right=of 1] (2) {$\bullet$} 
      child {node[red!50!black] {$\bullet$}}
      child {node[red!50!black] {$\bullet$}}
      child {node[red!50!black] {$\diamond$}};
    \node[blue!50!black, right=of 2] (3) {$\bullet$} 
      child {node[red!50!black] {$\bullet$}}
      child {node[red!50!black] {$\diamond$}}
      child {node[red!50!black] {$\bullet$}};
    \node[blue!50!black, right=of 3] (4) {$\bullet$} 
      child {node[red!50!black] {$\bullet$}}
      child {node[red!50!black] {$\diamond$}}
      child {node[red!50!black] {$\diamond$}};
    \node[blue!50!black, right=of 4] (5) {$\bullet$} 
      child {node[red!50!black] {$\diamond$}}
      child {node[red!50!black] {$\bullet$}}
      child {node[red!50!black] {$\bullet$}};
    \node[blue!50!black, right=of 5] (6) {$\bullet$} 
      child {node[red!50!black] {$\diamond$}}
      child {node[red!50!black] {$\bullet$}}
      child {node[red!50!black] {$\diamond$}};
    \node[blue!50!black, right=of 6] (7) {$\bullet$} 
      child {node[red!50!black] {$\diamond$}}
      child {node[red!50!black] {$\diamond$}}
      child {node[red!50!black] {$\bullet$}};
    \node[blue!50!black, right=of 7] (8) {$\bullet$} 
      child {node[red!50!black] {$\diamond$}}
      child {node[red!50!black] {$\diamond$}}
      child {node[red!50!black] {$\diamond$}};
    \node[blue!50!black, right=.8 of 8] (9) {$\bullet$} 
      child {node[red!50!black] {$\bullet$}};
    \node[blue!50!black, right=.6 of 9] (10) {$\bullet$} 
      child {node[red!50!black] {$\diamond$}};
    \node[blue!50!black, right=.6 of 10] (11) {$\bullet$};
	\end{tikzpicture}
	};
\end{tikzpicture}
\]
It has $11$ positions and no open leaves, which means it's a set (constant polynomial), namely $p\tri X\cong \1\1$.

We could also draw $X\tri p$, since both are perfectly valid polynomials. Here it is:
\[
\begin{tikzpicture}[rounded corners]
	\node (p2) [draw, red!50!black, "$X\tri p$" above] {
	\begin{tikzpicture}[trees, sibling distance=2.5mm]
    \node["\tiny 1" below] (1) {$\bullet$};
    \node[right=.5 of 1,"\tiny 2" below] (4) {$\diamond$};
    \node[above=10pt of 4] {};
    ;
  \end{tikzpicture}
  };
\end{tikzpicture}
\]
Each of the open leaves in $X$---of which there are none---is filled with a corolla from $p$.
\end{example}

\begin{exercise}\label{exc.composing_with_constants}
\begin{enumerate}
	\item Choose a polynomial $p$ and draw $p\tri\1$ in the style of \cref{ex.apply_2}.
	\item Is it true that if $X$ is a set (considered as a constant polynomial) and $p$ is any polynomial, then $X\tri p\cong X$?
	\item Is it true that if $X$ is a set and $p$ is a polynomial then $p\tri X\cong p(X)$, where $p(X)$ is the set given by applying $p$ as a functor to $X$?
\qedhere
\end{enumerate}
\end{exercise}


\begin{proposition}\label{prop.flipping_reps_lins}
For all sets $A,B$, we have the following adjunction:
\[
\poly\left(A\yon\tri p\tri \yon^B, q\right)\cong\poly\left(p,\yon^A\tri q\tri By\right)
\]
Moreover, this isomorphism is natural in $A\in\smset\op$ and $B\in\smset$.
\end{proposition}

\[
\begin{tikzpicture}
	\node (p1) {
  \begin{tikzpicture}[polybox,tos]
  	\node[poly, "$p$" left] (p) {};
  	\node[poly, linear, below=of p, "$A\yon$" left] (Ay) {};
  	\node[poly, pure, above=of p, "$\yon^B$" left] (yB) {};
  	\node[poly, right=2 of p, "$q$" right] (q) {};
  	\node at ($(p.east)!.5!(q.west)$) {$\leftrightarrows$};
  \end{tikzpicture}
  };
 \node[right=4 of p1] (p2) {
 \begin{tikzpicture}[polybox,tos]
  	\node[poly, "$p$" left] (p) {};
  	\node[poly, right=2 of p, "$q$" right] (q) {};
  	\node[poly, linear, above=of q, "$B\yon$" right] (By) {};
  	\node[poly, pure, below=of q, "$\yon^A$" right] (yA) {};
		\draw (p_pos) to[first] (yA_pos);
		\draw (yA_dir) to[climb] (q_pos);
		\draw (q_dir) to[climb] (By_pos);
		\draw (By_dir) to[last] (p_dir);
 \end{tikzpicture}
 };
 \node[align=center] at ($(p1)!.5!(p2)$) {is the\\same as};
\end{tikzpicture} 
\]
Do you see how polyboxes with a black (one-element) part can flip upside-down to go to the other side?
\begin{proof}
We prove this in two pieces: that
\begin{equation} \label{eqn.flipping1}
\poly\left(A\yon\tri p, q\right)\cong\poly\left(p,\yon^A\tri q\right)
\end{equation}
and that
\begin{equation} \label{eqn.flipping2}
\poly\left(p \tri \yon^B, q\right)\cong\poly\left(p, q\tri B\yon\right)
\end{equation}

For \cref{eqn.flipping1}, we have that $A\yon \tri p \cong Ap$, an $A$-fold coproduct of $p$.
Similarly, $\yon^A \tri q \cong q^A$, an $A$-fold product of $q$.
So this follows from the corresponding universal properties.

For \cref{eqn.flipping2}, we first write out the two sets by hand.
To give a map from $p \tri \yon^B$ to $q$, we must provide for every $i \in p(\1)$ an element $j \in q(\1)$ and a function $q[j] \to B \times p[i]$.
Then to give a map from $p$ to $q \tri B\yon$, we must provide for every $i \in p(\1)$ an element $j \in q(\1)$ and for every $n \in q[j]$, an element of $B$ and an element of $p[i]$.
These are clearly isomorphic.
\end{proof}

\begin{exercise}
Let $A,B\in\smset$ be sets, and let $p\in\poly$ be a polynomial. Is it true that the morphisms $A\yon^B\to p$ can be identified with the morphisms $A\to p\tri B$, i.e.\ that there is a bijection:
\begin{equation}\label{eqn.monomials_and_comp}
	\poly(A\yon^B,p)\cong^?\poly(A,p\tri B)
\end{equation}
If so, why? If not, give a counterexample.
\end{exercise}

\begin{exercise}\label{ex.compose_yon}
For any $p\in\poly$ there are natural isomorphisms $p\cong p\tri \yon$ and $p\cong\yon\tri p$.
\begin{enumerate}
	\item Thinking of polynomials as functors $\smset\to\smset$, what functor does $\yon$ represent?
	\item Why is $p\cong\yon$ isomorphic to $p$?
	\item In terms of tree pictures, draw $\yon\tri p$ and $p\tri\yon$, and explain pictorially how to see the isomorphisms $\yon\tri p\cong p\cong p\tri\yon$.
\qedhere
\end{enumerate}
\end{exercise}

%---- Subsection ----%
\subsection{Monoidal structure $(\poly,\tri,\yon)$}\label{subsec.monoidal_struc_tri}

The technical claim is that $\tri$ is a monoidal product, which means that it's well-behaved, in particular it's functorial, associative, and unital. In fact, all of this comes from general theory: for any category $\cat{C}$ the category whose objects are functors $\cat{C}\to\cat{C}$ and whose morphisms are natural transformations is a monoidal category. For us $\cat{C}\coloneqq\smset$, and we are only using polynomial functors, not all functors, so there is a tiny bit to do, but it's accomplished by \cref{rop.poly_closed_comp} and the fact that the identity functor $\smset\to\smset$ is a polynomial (it's $\yon$).

However, even though the formal theory of functors and natural transformations knocks the monoidality of $\tri$ out of the park, it is still useful to discuss how it acts on morphisms in terms of positions and directions.

For any $f\colon p\to p'$ and $g\colon q\to q'$, we want to define a morphism $(f\tri g)\colon(p\tri q)\to(p'\tri q')$. This is actually quite an impressive operation! It threads back and forth in a fascinating way. 

Recall from \cref{ex.practice_with_poly_morphisms} that we can think of $f=(f_1,f^\sharp)$ as a way to delegate decisions from $p$ to $p'$. Every decision (corolla / position) $i\in p(\1)$ is assigned a decision $f_1(i)\in p'(\1)$. Then every option $d\in p'[f_1(i)]$ there is passed back to an option $f^\sharp(d)\in p[i]$. Let's start with an example and then give the general method.

\begin{example}\label{ex.circ_prod_on_morphisms}
Let's take $p\coloneqq \yon^\2+\yon$, $q\coloneqq\yon^\2+\yon$, $p'\coloneqq\yon^\3+\yon$, and $q'\coloneqq\yon+\1$.
\[
\begin{tikzpicture}[rounded corners]
	\node (p) [draw, blue!50!black, "$p=$" left] {
	\begin{tikzpicture}[trees, sibling distance=5mm]
    \node["\tiny 1" below] (1) {$\bullet$} 
      child {}
      child {};
    \node[right=.5 of 1,"\tiny 2" below] (2) {$\bullet$} 
      child {};
  \end{tikzpicture}
  };
%
	\node (q) [draw, red!50!black, above=1 of p, "$q=$" left] {
	\begin{tikzpicture}[trees, sibling distance=2.5mm]
    \node["\tiny 1" below] (1) {$\bullet$} 
      child {}
      child {};
    \node[right=.5 of 1,"\tiny 2" below] (2) {$\bullet$} 
      child {};
  \end{tikzpicture}
  };
	\node (p') [draw, blue, right=3 of p, "$p'=$" left] {
	\begin{tikzpicture}[trees, sibling distance=2.5mm]
    \node["\tiny 1" below] (1) {$\bullet$} 
      child {}
      child {}
      child {};
    \node[right=.5 of 1,"\tiny 2" below] (2) {$\bullet$}
      child {};
  \end{tikzpicture}
  };
	\node (q') [draw, red, above=1 of p', "$q'=$" left] {
	\begin{tikzpicture}[trees, sibling distance=2.5mm]
    \node["\tiny 1" below] (1) {$\bullet$} 
      child {};
    \node[right=.5 of 1,"\tiny 2" below] (2) {$\bullet$}
    ;
  \end{tikzpicture}
  };
\end{tikzpicture}
\]
For any way to delegate from $p$ to $p'$ and $q$ to $q'$, we're supposed to give a way to delegate from $(p\tri q)$ to $(p'\tri q')$. Let's draw $p\tri q$ and $p'\tri q'$.
\[
\begin{tikzpicture}[rounded corners]
	\node (p1) [draw, "$p\tri q$" above] {
	\begin{tikzpicture}[trees,
		level 1/.style={sibling distance=8mm},
	  level 2/.style={sibling distance=2.5mm}]
    \node[blue!50!black] (1) {$\bullet$} 
      child {node[red!50!black] {$\bullet$} 
      	child
				child
			}
      child {node[red!50!black] {$\bullet$} 
      	child
				child
			};
%
    \node[blue!50!black, right=1.7 of 1] (2) {$\bullet$} 
      child {node[red!50!black] {$\bullet$} 
				child
				child
			}
      child {node[red!50!black] {$\bullet$} 
				child
			};
%
    \node[blue!50!black, right=1.5 of 2] (3) {$\bullet$} 
      child {node[red!50!black] {$\bullet$} 
      	child
			}
      child {node[red!50!black] {$\bullet$} 
				child
				child
			};
%
    \node[blue!50!black, right=1.5 of 3] (4) {$\bullet$} 
      child {node[red!50!black] {$\bullet$} 
      	child
			}
      child {node[red!50!black] {$\bullet$} 
				child
			};
%
    \node[blue!50!black, right=1.2 of 4] (5) {$\bullet$} 
      child {node[red!50!black] {$\bullet$} 
      	child
      	child
			};
%
    \node[blue!50!black, right=.8 of 5] (6) {$\bullet$} 
      child {node[red!50!black] {$\bullet$} 
      	child
			};
  \end{tikzpicture}
  };
\end{tikzpicture}
\]
\[
\begin{tikzpicture}[rounded corners]
	\node (p1) [draw, "$p'\tri q'$" above] {
	\begin{tikzpicture}[trees,
		level 1/.style={sibling distance=4mm},
	  level 2/.style={sibling distance=2.5mm}]
    \node[blue] (1) {$\bullet$} 
      child {node[red] {$\bullet$} 
      	child
			}
      child {node[red] {$\bullet$} 
      	child
			}
      child {node[red] {$\bullet$} 
				child
			};
%
    \node[blue, right=1.4 of 1] (2) {$\bullet$} 
      child {node[red] {$\bullet$} 
      	child
			}
      child {node[red] {$\bullet$} 
      	child
			}
      child {node[red] {$\bullet$} 
			};
%
    \node[blue, right=1.4 of 2] (3) {$\bullet$} 
      child {node[red] {$\bullet$} 
      	child
			}
      child {node[red] {$\bullet$} 
			}
      child {node[red] {$\bullet$} 
				child
			};
%
    \node[blue, right=1.4 of 3] (4) {$\bullet$} 
      child {node[red] {$\bullet$} 
      	child
			}
      child {node[red] {$\bullet$} 
			}
      child {node[red] {$\bullet$} 
			};
%
    \node[blue, right=1.4 of 4] (5) {$\bullet$} 
      child {node[red] {$\bullet$} 
			}
      child {node[red] {$\bullet$} 
      	child
			}
      child {node[red] {$\bullet$} 
				child
			};
%
    \node[blue, right=1.4 of 5] (6) {$\bullet$} 
      child {node[red] {$\bullet$} 
			}
      child {node[red] {$\bullet$} 
      	child
			}
      child {node[red] {$\bullet$} 
			};
%
    \node[blue, right=1.4 of 6] (7) {$\bullet$} 
      child {node[red] {$\bullet$} 
			}
      child {node[red] {$\bullet$} 
			}
      child {node[red] {$\bullet$} 
      	child
			};
%
    \node[blue, right=1.4 of 7] (8) {$\bullet$} 
      child {node[red] {$\bullet$} 
			}
      child {node[red] {$\bullet$} 
			}
      child {node[red] {$\bullet$} 
			};
%
    \node[blue, right=1 of 8] (9) {$\bullet$} 
      child {node[red] {$\bullet$} 
      	child
			};
%
    \node[blue, right=.8 of 9] (10) {$\bullet$} 
      child {node[red] {$\bullet$} 
			};
  \end{tikzpicture}
  };
\end{tikzpicture}
\]

Ok, now suppose someone gives us delegations (morphisms / dependent lenses) $f\colon p\to p'$ and $g\colon q\to q'$. Let's just pick something relatively at random
\[
\begin{tikzpicture}
	\node (p1) {\raisebox{.3cm}{$f\colon p\to p'$}\qquad
	\begin{tikzpicture}[trees, sibling distance=2.5mm]
    \node[blue!50!black, "\tiny 1" below] (1) {$\bullet$} 
      child {coordinate (11)}
      child {coordinate (12)};
    \node[right=1.5 of 1, blue, "\tiny 1" below] (2) {$\bullet$} 
      child {coordinate (21)}
      child {coordinate (22)}
      child {coordinate (23)};
    \draw[|->, shorten <= 3pt, shorten >= 3pt] (1) -- (2);
    \begin{scope}[densely dotted, bend right]
      \draw[postaction={decorate}] (21) to (12);
      \draw[postaction={decorate}] (22) to (12);
      \draw[postaction={decorate}] (23) to (11);
    \end{scope}
  \end{tikzpicture}	
	};	
%
	\node (p2) [below right=-1.3 and 1 of p1] {
	\begin{tikzpicture}[trees, sibling distance=2.5mm]
    \node[blue!50!black, "\tiny 2" below] (1) {$\bullet$} 
      child {coordinate (11)};
    \node[right=of 1, blue, "\tiny 2" below] (2) {$\bullet$}
      child {coordinate (21)};
    \draw[|->, shorten <= 3pt, shorten >= 3pt] (1) -- (2);
    \begin{scope}[densely dotted, bend right]
      \draw[postaction={decorate}] (21) to (11);
		\end{scope}
  \end{tikzpicture}	
	};	
	\node [below=.5 of p1] (p3) {\raisebox{.3cm}{$g\colon q\to q'$}\qquad
	\begin{tikzpicture}[trees, sibling distance=2.5mm]
    \node[red!50!black, "\tiny 1" below] (1) {$\bullet$} 
      child {coordinate (11)}
      child {coordinate (12)};
    \node[right=1.5 of 1, red, "\tiny 1" below] (2) {$\bullet$} 
      child {coordinate (21)};
    \draw[|->, shorten <= 3pt, shorten >= 3pt] (1) -- (2);
    \begin{scope}[densely dotted, bend right]
      \draw[postaction={decorate}] (21) to (12);
    \end{scope}
  \end{tikzpicture}	
	};	
%
	\node (p4) [below right=-1.05 and 1 of p3] {
	\begin{tikzpicture}[trees, sibling distance=2.5mm]
    \node[red!50!black, "\tiny 2" below] (1) {$\bullet$} 
      child {coordinate (11)};
    \node[right=of 1, red, "\tiny 2" below] (2) {$\bullet$};
    \draw[|->, shorten <= 3pt, shorten >= 3pt] (1) -- (2);
  \end{tikzpicture}	
	};	
\end{tikzpicture}
\]
Then we can form the induced delegation (morphism / dependent lens) $f\tri g\colon (p\tri q)\to (p'\tri q')$ as follows. For each two-level tree (position in $p\tri q$), we begin by using $f$ to send the $p$-corolla on the bottom to a $p'$-corolla. The second-level nodes (from $q'$) have not been chosen yet, but each of the $p'$-directions is passed back to a $p$-direction via $f^\sharp$. Now we use $g$ to send the $q$-corolla at the second level to a $q'$ corolla (this part is not shown in the diagram below because it would add clutter). Again each of the $q'$-directions is passed back to a $q$ direction via $g^\sharp$.

Our six pictures below leave out the fact that the red corollas on the right are selected according to $g$; hopefully the reader can put it together for themselves.
\[
	\begin{tikzpicture}[trees]
	\begin{scope}[
		level 1/.style={sibling distance=8mm},
	  level 2/.style={sibling distance=2.5mm}]
    \node[blue!50!black] (1) {$\bullet$} 
      child {node[red!50!black] (11') {$\bullet$} 
      	child {coordinate (11)}
				child {coordinate (12)}
			}
      child {node[red!50!black] (12') {$\bullet$} 
      	child {coordinate (13)}
				child {coordinate (14)}
			};
%
    \node[blue!50!black, right=5 of 1] (2) {$\bullet$} 
      child {node[red!50!black] (21') {$\bullet$} 
      	child {coordinate (21)}
				child {coordinate (22)}
			}
      child {node[red!50!black] (22') {$\bullet$} 
      	child {coordinate (23)}
			};
%
    \node[blue!50!black, below=1.3 of 1] (3) {$\bullet$} 
      child {node[red!50!black] (31') {$\bullet$} 
      	child {coordinate (31)}
			}
      child {node[red!50!black] (32') {$\bullet$} 
      	child {coordinate (32)}
				child {coordinate (33)}
			};
%
    \node[blue!50!black] at (2|-3) (4) {$\bullet$} 
      child {node[red!50!black] (41') {$\bullet$} 
      	child {coordinate (41)}
			}
      child {node[red!50!black] (42') {$\bullet$} 
      	child {coordinate (42)}
			};
%
    \node[blue!50!black, below=1.3 of 3] (5) {$\bullet$} 
      child {node[red!50!black] (51') {$\bullet$} 
      	child {coordinate (51)}
				child {coordinate (52)}
			};
%
    \node[blue!50!black] at (4|-5) (6) {$\bullet$} 
      child {node[red!50!black] (61') {$\bullet$} 
      	child {coordinate (61)}
			};
		\end{scope}
%%
		\begin{scope}[		
		level 1/.style={sibling distance=4mm},
	  level 2/.style={sibling distance=2.5mm}]
	    \node[blue, right=2 of 1] (1') {$\bullet$} 
      child {node[red] (1'1') {$\bullet$} 
      	child {coordinate (1'1)}
			}
      child {node[red] (1'2') {$\bullet$} 
      	child {coordinate (1'2)}
			}
      child {node[red] (1'3') {$\bullet$} 
      	child {coordinate (1'3)}
			};
%
    \node[blue, right=2 of 2] (2') {$\bullet$} 
      child {node[red] (2'1') {$\bullet$} 
			}
      child {node[red] (2'2') {$\bullet$} 
			}
      child {node[red] (2'3') {$\bullet$} 
      	child {coordinate (2'1)}
			};
%
    \node[blue, right=2 of 3] (3') {$\bullet$} 
      child {node[red] (3'1') {$\bullet$} 
      	child {coordinate (3'1)}
			}
      child {node[red] (3'2') {$\bullet$} 
      	child {coordinate (3'2)}
			}
      child {node[red] (3'3') {$\bullet$} 
			};
%
    \node[blue, right=2 of 4] (4') {$\bullet$} 
      child {node[red] (4'1') {$\bullet$} 
			}
      child {node[red] (4'2') {$\bullet$} 
			}
      child {node[red] (4'3') {$\bullet$} 
			};
%
    \node[blue, right=2 of 5] (5') {$\bullet$} 
      child {node[red] (5'1') {$\bullet$} 
      	child {coordinate (5'1)}
			};
%
    \node[blue, right=2 of 6] (6') {$\bullet$} 
      child {node[red] (6'1') {$\bullet$} 
			};
%
\draw[|->, shorten <= 3pt, shorten >= 3pt] (1) -- (1');
\draw[|->, shorten <= 3pt, shorten >= 3pt] (2) -- (2');
\draw[|->, shorten <= 3pt, shorten >= 3pt] (3) -- (3');
\draw[|->, shorten <= 3pt, shorten >= 3pt] (4) -- (4');
\draw[|->, shorten <= 3pt, shorten >= 3pt] (5) -- (5');
%\draw[|->, shorten <= 3pt, shorten >= 3pt] (6) -- (6');
    \begin{scope}[densely dotted, bend right=15pt]
      \draw[postaction={decorate}] (1'1') to (12');
      \draw[postaction={decorate}] (1'2') to (12');
      \draw[postaction={decorate}] (1'3') to (11');
      \draw[postaction={decorate}] (1'1) to (14);
      \draw[postaction={decorate}] (1'2) to (14);
      \draw[postaction={decorate}] (1'3) to (12);
%
      \draw[postaction={decorate}] (2'1') to (22');
      \draw[postaction={decorate}] (2'2') to (22');
      \draw[postaction={decorate}] (2'3') to (21');
      \draw[postaction={decorate}] (2'1) to (23);
%
      \draw[postaction={decorate}] (3'1') to (32');
      \draw[postaction={decorate}] (3'2') to (32');
      \draw[postaction={decorate}] (3'3') to (31');
      \draw[postaction={decorate}] (3'1) to (33);
      \draw[postaction={decorate}] (3'2) to (33);
%
      \draw[postaction={decorate}] (4'1') to (42');
      \draw[postaction={decorate}] (4'2') to (42');
      \draw[postaction={decorate}] (4'3') to (41');
%
      \draw[postaction={decorate}] (5'1') to (51');
      \draw[postaction={decorate}] (5'1) to (52);
%
      \draw[postaction={decorate}] (6'1') to (61');
    \end{scope}

	\end{scope}
  \end{tikzpicture}
\]
Again, we're not making up these rules; it's a tree representation of how natural transformations $f$ and $g$ compose to form $f\tri g$.
\end{example}

\begin{exercise}
With $p,q,p',q'$ and $f,g$ as in \cref{ex.circ_prod_on_morphisms}, draw $g\tri f\colon (q\tri p)\to (q'\tri p')$ in terms of trees as in the example.
\end{exercise}

\begin{exercise}
Suppose $p$, $q$, and $r$ are polynomials and you're given arbitrary morphisms $f\colon q\to p\tri q$ and $g\colon q\to q\tri r$. Does the following diagram necessarily commute?
\[
\begin{tikzcd}
	q\ar[r, "g"]\ar[d, "f"']&
	q\tri r\ar[d, "f\tri r"]\\
	p\tri q\ar[r, "p\tri g"']&
	p\tri q\tri r\ar[ul, phantom, "?"]
\end{tikzcd}
\]
That is, do we have $(p\tri g)\circ f=^?(f\tri r)\circ g$?
\end{exercise}

\paragraph{Pronouncing polynomial composites.}

We want to be able to pronounce polynomials like $p$ and $q$ in some way, which is intuitive and which lends itself to pronouncing composites like $p\tri q$ or $p\tri p\tri q\tri p$. We pronounce the polynomial
\[p=\sum_{i\in p(\1)}\prod_{d\in p[i]}\yon\]
as ``a choice of $p$-position $i$ and, for every direction $d\in p[i]$ there, a future.'' Other than the word ``future'' in place of $\yon$, this is just pronouncing dependent sums and products. By saying ``a future'', we indicate that $\yon$ is a functor: for any set $X$ one could put in its place, we'll get an element of that $X$. We know we're getting an element of something, we just don't yet know what.

To pronounce composites of polynomials $p\tri q$, we pronounce almost all of $p$, except we replace ``future'' with $q$. More precisely, to pronounce $p\tri q$, which has the formula
\[p\tri q\cong\sum_{i\in p(\1)}\prod_{d\in p[i]}\sum_{j\in q(\1)}\prod_{e\in q[j]}\yon,
\]
we would say ``a choice of position $i\in p(\1)$ and, for every direction $d\in p[i]$ there, a choice of position $j\in q(\1)$ and, for every direction $e\in q[j]$ there, a future.

\begin{exercise}
\begin{enumerate}
	\item Let $p$ be an arbitrary polynomial. Write out the English pronunciation of $p\tri p\tri p$.
	\item Pronouncing the unique element of $\1$ as ``completion'', write out the pronunciation of $p\tri p\tri \1$.
	\item Pronouncing $\prod_{d\in\varnothing}\yon$ as ``with no directions to travel, a complete dissociation from any purported future'', write out the pronunciation of $p\tri p\tri\yon^\0$.
	\item With the ``dissociation'' language, pronounce $p\tri\1\tri p$, and see if it makes sense with the fact that $p\tri\1\tri p\cong p\tri \1$.
\qedhere
\end{enumerate}
\end{exercise}

For any $n\in\nn$, let $p\tripow{n}$ denote the $n$-fold $\tri$ power of $p$, e.g.\ $p\tripow{3}\coloneqq p\tri p\tri p$. In particular, $p\tripow{1}\coloneqq p$ and $p\tripow{0}\coloneqq\yon$. We might think of $p\tripow{n}$ in terms of length-$n$ strategies, in the sense of game theory, except that the opponent is somehow abstract, having no positions of its own. That is, we pronounce $p\tripow{n}$

\begin{exercise}
Let $p,q\in\poly$ be polynomials and $n\in\nn$; say $n\geq 1$. Pronounce $(p\tri q)\tripow{(n+2)}$, using the exact phrase ``and so on, $n$ times, ending with''.
\end{exercise}


%---- Subsection ----%
\subsection{Working with composites}\label{subsec.working_with_composites}

We need a way of talking about maps to composites.%
\footnote{It would be nice to also have a nice way of talking about maps \emph{out of} composites; however that is more difficult.} 
The set of morphisms $p\to q_1\tri q_2\tri\cdots\tri q_k$ has the following form:
\[
  \poly(p,\, q_1\tri q_2\tri\cdots\tri q_k)
  \cong
  \prod_{i\in p(\1)}\;
  	\sum_{j_1\in q_1(\1)}\;
  \prod_{e_1\in q_1[j_1]}\;
  	\sum_{j_2\in q_2(\1)}\;\cdots
  \prod_{e_k\in q_k[j_{k-1}]}\;
  	\sum_{d\in p[i]}
	\1
\]
We can use this to generalize our notation in the case $k=1$, i.e.\ for morphisms $p\to q$. That is we denoted such a morphism by $\lens{f^\sharp}{f_1}$, where $f_1\colon p(\1)\to q(\1)$ and $f^\sharp_i\colon q[f_1(i)]\to p[i]$. We generalize this to the $k$-ary composite case as
\begin{equation}\label{eqn.notation_f1f2fk}
(f_1,f_2,\ldots,f_k,f^\sharp)\colon p\too q_1\tri q_2\tri\cdots\tri q_k,
\end{equation}
where
\begin{equation}\label{eqn.maps_to_comp}
\begin{aligned}
f_1&:p(\1)\to q_1(\1),\\
f_2&:(i\in p(\1))\to (e_1\in q_1[f_1(i)])\to q_2(\1),\\
f_3&:(i\in p(\1))\to (e_1\in q_1[f_1(i)])\to (e_2\in q_2[f_2(i,e_1)])\to q_3(\1),\\
f_k&:(i\in p(\1))\to (e_1\in q_1[f_1(i)])\to  \cdots\to(e_{k-1}\in q_{k-1}[f_{k-1}(i,e_1,\ldots,e_{k-2})])\to q_k(\1),\\
f^\sharp&:(i\in p(\1))\to (e_1\in q_1[f_1(i)])\to \cdots\to(e_{k}\in q_k[f_{k}(i,e_1,\ldots,e_{k-1})])\to p[i]
\end{aligned}
\end{equation}
Here's a picture for the $k=4$ case:
\[
\begin{tikzpicture}[polybox, tos]
	\node[poly, dom] (p) {};
	\node[left=0pt of p_dir] {$p[-]$};
	\node[left=0pt of p_pos] {$p(\1)$};
	\foreach \i in {1,...,4}
	{
  	\node[poly, cod] (q\i) at (3,1.3*\i-3.25) {};
  	\node[right=0pt of q\i_dir] {$q_{\i}[-]$};
  	\node[right=0pt of q\i_pos] {$q_{\i}(\1)$};
	};
	\draw (p_pos) to[first] node[below] {$f_1$} (q1_pos.west);
	\foreach \i/\j in {1/2,2/3, 3/4}
	{
		\draw 
			(q\i_dir.west) 
			to[climb] 
			node[left] {$f_\j$}
			(q\j_pos.west);
	};
	\draw (q4_dir) to[last] node[above left] {$f^\sharp$} (p_dir);
\end{tikzpicture}
\]


A few considerations might make \eqref{eqn.maps_to_comp} less scary. First of all, we're usually interested in the cases $k=0,1,2$. The case $k=1$ is just our $(f_1,f^\sharp)$ notation
\[
  \begin{tikzpicture}[polybox, tos]
  	\node[poly, dom, "$p$" left] (c) {};
  	\node[poly, cod, right=of c, "$q$" right] (c') {};
  	\draw (c_pos) -- node[below] {$f_1$} (c'_pos);
  	\draw (c'_dir) -- node[above] {$f^\sharp$} (c_dir);
	\end{tikzpicture}
\]
The case $k=0$ says that a map $p\to\yon$ is just a function $f^\sharp\in\prod_{i\in p(\1)}p[i]$
\[
 \begin{tikzpicture}[polybox, tos]
  	\node[poly, dom, "$p$" left] (c) {};
  	\node[poly, identity, right=of c, "$\yon$" right] (c') {};
  	\draw (c_pos) -- node[below] {$!$} (c'_pos);
  	\draw (c'_dir) -- node[above] {$f^\sharp$} (c_dir);
	\end{tikzpicture}
\]
which we can rewrite simply as
\begin{equation}\label{eqn.map_to_0ary_composite}
 \begin{tikzpicture}[polybox, tos]
  	\node[poly, dom, "$p$" left] (c) {};
  	\draw (c_pos) to[climb'] node[right] {$f^\sharp$} (c_dir);
	\end{tikzpicture}
\end{equation}
The case $k=2$ looks like this
\begin{equation}\label{eqn.map_to_2ary_composite}
\begin{tikzpicture}[polybox, mapstos]
	\node[poly, dom] (p) {};
	\node[poly, cod, right= 1.5cm of p.south, yshift=-1ex] (q) {};
	\node[poly, cod, above=of q] (r) {};
  	\draw (p_pos) to[first] (q_pos);
  	\draw (q_dir) to[climb] (r_pos);
  	\draw (r_dir) to[last] (p_dir);
\end{tikzpicture}
\end{equation}
and is considered in \cref{ex.map_to_comp}. But before we get there, let's think about \eqref{eqn.maps_to_comp} in terms of delegating decisions by ``due process''. 

Suppose we're $p$ and someone gives us a decision $i\in p(\1)$ to make: we're supposed to pick an element of $p[i]$. Luckily, by virtue of our morphism $f\colon p\to q_1\tri\cdots\tri q_k$, consisting of steps $f_1,\ldots,f_k$ and an interpretation $f^\sharp$, we have a process to follow by which we can make the decision. Our first step is to ask $q_1$ to make decision $f_1(i)$. It dutifully chooses some option, say $e_1\in q_1[f_1(i)]$. We know exactly what to do: our second step is to ask $q_2$ to make decision $f_2(i,e_1)$. It dutifully chooses some option, say $e_2\in q_2[f_2(i,e_1)]$. We continue with the plan through step $k$, at which point we ask $q_k$ to make decision $f_k(i,e_1,\ldots,e_{k-1})$. It dutifully chooses some option, say $e_k$, which we then interpret via our passback function $f^\sharp$ to obtain the desired decision $f^\sharp(i,e_1,\ldots,e_k)\in p[i]$.

\slogan{A morphism $p\to q_1\tri\cdots\tri q_k$ is a multi-step policy for $p$ to make decisions by asking for decisions from $q_1$ then $q_2$, etc., all the way until $q_k$, and interpreting the results.}

\begin{example}[Maps $p\to q\tri r$]\label{ex.map_to_comp}
By \eqref{eqn.maps_to_comp}, a morphism $p\to q\tri r$ can be specified by a tuple $(f_1,f_2,f^\sharp)$, where $f_1\colon p(\1)\to q(\1)$ and $f_2,f^\sharp$ are a little more involved because they are dependent functions.

The dependent function $f_2$ takes as input a pair $(i,d)$ where $i\in p(\1)$ and $d\in q[f_1(i)]$, and it outputs an element of $r(\1)$.

The dependent function $f^\sharp$ takes as input a tuple $(i,d,e)$, where $i,d$ are as above and $e\in r[f_2(i,d)]$, and it outputs an element of $p[i]$.

For example, let $p\coloneqq\{A\}\yon^{\{R,S\}}+{B}\yon^{\{T\}}$, $q\coloneqq\{C\}\yon^{\{U,V,W\}}+\{D\}\yon^{\{X\}}$, and $r\coloneqq\{E\}\yon^{\{Y,Z\}}+\{F\}$.
\[
\begin{tikzpicture}[rounded corners]
	\node (p) [draw, "$p=$" left] {
	\begin{tikzpicture}[trees, sibling distance=4mm]
    \node["\tiny $A$" below] (1) {$\bullet$} 
      child {node[above, font=\tiny] {$R$}}
      child {node[above, font=\tiny] {$S$}};
    \node[right=.5 of 1,"\tiny $B$" below] (2) {$\bullet$} 
      child {node[above, font=\tiny] {$T$}};
  \end{tikzpicture}
  };
%
	\node (q) [draw, red!50!black, right=2 of p, "$q=$" left] {
	\begin{tikzpicture}[trees, sibling distance=4mm]
    \node["\tiny $C$" below] (1) {$\bullet$} 
      child {node[above, font=\tiny] {$U$}}
      child {node[above, font=\tiny] {$V$}}
      child {node[above, font=\tiny] {$W$}};
    \node[right=.75 of 1,"\tiny $D$" below] (2) {$\bullet$} 
      child {node[above, font=\tiny] {$X$}};
  \end{tikzpicture}
  };
	\node (r) [draw, red, right=2 of q, "$r=$" left] {
	\begin{tikzpicture}[trees, sibling distance=4mm]
    \node["\tiny $E$" below] (1) {$\bullet$} 
      child {node[above, font=\tiny] {$Y$}}
      child {node[above, font=\tiny] {$Z$}};
    \node[right=.5 of 1,"\tiny $F$" below] (2) {$\bullet$};
  \end{tikzpicture}
  };
\end{tikzpicture}
\]
Here is a picture of a map $p\to q\tri r$:
\[
	\begin{tikzpicture}[trees,
		level 1/.style={sibling distance=5mm},
	  level 2/.style={sibling distance=2.5mm}]
    \node["\tiny $A$" below] (1) {$\bullet$} 
      child {coordinate (11')}
      child {coordinate (12')};
    \node[right=2 of 1, red!50!black,"\tiny $C$" below] (1') {$\bullet$}
    	child {node[red] {$\bullet$}
				child {coordinate (1'1)}
				child {coordinate (1'2)}
			}
			child{node[red] {$\bullet$}
			}
			child{node[red] {$\bullet$}
				child {coordinate (1'3)}
				child {coordinate (1'4)}
			}
			;
%
    \node (2) [right=3 of 1',"\tiny $B$" below] {$\bullet$} 
      child {coordinate (21')};
    \node[right=2 of 2, red!50!black,"\tiny $D$" below] (2') {$\bullet$}
			child{node[red] {$\bullet$}
				child {coordinate (2'1)}
				child {coordinate (2'2)}
			}
			;
%
  \draw[|->, shorten <= 3pt, shorten >= 3pt] (1) -- (1');
  \draw[|->, shorten <= 3pt, shorten >= 3pt] (2) -- (2');
  \begin{scope}[densely dotted, bend right=60pt]
  	\draw[postaction={decorate}] (1'1) to (12');
  	\draw[postaction={decorate}] (1'2) to (11');
  	\draw[postaction={decorate}] (1'3) to (11');
  	\draw[postaction={decorate}] (1'4) to (11');
  	\draw[postaction={decorate}] (2'1) to (21');
  	\draw[postaction={decorate}] (2'2) to (21');
  \end{scope}
\end{tikzpicture}
\]
If we write it as $(f_1,f_2,f^\sharp)\colon p\to q\tri r$ then we have
\begin{gather*}
f_1(A)=C,\quad f_1(B)=D,\\
f_2(A,U)=E,\quad f_2(A,V)=F,\quad f_2(A,W)=E,\\
f_2(B,X)=E,\\
f^\sharp(A,U,Y)=S,\quad f^\sharp(A,U,Z)=R,\quad f^\sharp(A,W,Y)=R,\quad f^\sharp(A,W,Z)=R\\
f^\sharp(B,X,Y)=T,\quad f^\sharp(B,X,Z)=T
\end{gather*}
Box-notation uses a slightly different organization to represent the same data:
\[
\begin{tikzpicture}[polybox, mapstos, node distance=2ex and 1.4cm]
  \node (a) {
  \begin{tikzpicture}
  	\node[poly, dom] (p) {$S$\nodepart{two}$A$};
  	\node[poly, cod, right= of p.south, yshift=-1ex] (q) {$U$\nodepart{two}$C$};
  	\node[poly, cod, above=of q] (r) {$Y$\nodepart{two}$E$};
  	\draw (p_pos) to[first] (q_pos);
  	\draw (q_dir) to[climb] (r_pos);
  	\draw (r_dir) to[last] (p_dir);
  \end{tikzpicture}
  };
  \node[right=.6 of a] (b) {
  \begin{tikzpicture}
  	\node[poly, dom] (p) {$R$\nodepart{two}$A$};
  	\node[poly, cod, right= of p.south, yshift=-1ex] (q) {$U$\nodepart{two}$C$};
  	\node[poly, cod, above=of q] (r) {$Z$\nodepart{two}$E$};
  	\draw (p_pos) to[first] (q_pos);
  	\draw (q_dir) to[climb] (r_pos);
  	\draw (r_dir) to[last] (p_dir);
  \end{tikzpicture}
  };
  \node[right=.6of b] (c) {
  \begin{tikzpicture}
  	\node[poly, dom] (p) {\nodepart{two}$A$};
  	\node[poly, cod, right= of p.south, yshift=-1ex] (q) {$V$\nodepart{two}$C$};
  	\node[poly, constant, above=of q] (r) {\nodepart{two}$F$};
  	\draw (p_pos) to[first] (q_pos);
  	\draw (q_dir) to[climb] (r_pos);
		\draw[densely dotted] (r_dir) to[last] (p_dir);
  \end{tikzpicture}
  };
  \node[right=.6 of c] (d) {
  \begin{tikzpicture}
  	\node[poly, dom] (p) {$R$\nodepart{two}$A$};
  	\node[poly, cod, right= of p.south, yshift=-1ex] (q) {$W$\nodepart{two}$C$};
  	\node[poly, cod, above=of q] (r) {$Y$\nodepart{two}$E$};
  	\draw (p_pos) to[first] (q_pos);
  	\draw (q_dir) to[climb] (r_pos);
  	\draw (r_dir) to[last] (p_dir);
  \end{tikzpicture}
	};
  \node[right=.6 of d] (e) {
  \begin{tikzpicture}
  	\node[poly, dom] (p) {$R$\nodepart{two}$A$};
  	\node[poly, cod, right= of p.south, yshift=-1ex] (q) {$W$\nodepart{two}$C$};
  	\node[poly, cod, above=of q] (r) {$Z$\nodepart{two}$E$};
  	\draw (p_pos) to[first] (q_pos);
  	\draw (q_dir) to[climb] (r_pos);
  	\draw (r_dir) to[last] (p_dir);
  \end{tikzpicture}
	};
  \node[below=.6 of a] (f) {
  \begin{tikzpicture}
  	\node[poly, dom] (p) {$T$\nodepart{two}$B$};
  	\node[poly, cod, right= of p.south, yshift=-1ex] (q) {$X$\nodepart{two}$D$};
  	\node[poly, cod, above=of q] (r) {$Y$\nodepart{two}$E$};
  	\draw (p_pos) to[first] (q_pos);
  	\draw (q_dir) to[climb] (r_pos);
  	\draw (r_dir) to[last] (p_dir);
  \end{tikzpicture}
	};
  \node[below=.6 of b] (g) {
  \begin{tikzpicture}
  	\node[poly, dom] (p) {$T$\nodepart{two}$B$};
  	\node[poly, cod, right= of p.south, yshift=-1ex] (q) {$X$\nodepart{two}$D$};
  	\node[poly, cod, above=of q] (r) {$Z$\nodepart{two}$E$};
  	\draw (p_pos) to[first] (q_pos);
  	\draw (q_dir) to[climb] (r_pos);
  	\draw (r_dir) to[last] (p_dir);
  \end{tikzpicture}
	};
\end{tikzpicture}
\]
\end{example}

\begin{example}[Using \eqref{eqn.notation_f1f2fk} to denote positions and directions in a composite]\label{ex.pos_in_composite}
Suppose given polynomials $p_1,\ldots,p_k$. Recall from \cref{exc.positions_maps_yon} that a position in their composite as a map
\[
i\colon \yon^\1\to p_1\tri\cdots\tri p_k.
\]
We can denote $i$ in the notation \eqref{eqn.notation_f1f2fk} as $i=(i_1,\ldots,i_k)$, forgoing the input to $i_1$ because it is always $1\in\1$ and also forgoing $f^\sharp$ because it is always the unique map to $\1$. Then in this notation 
\begin{gather*}
i_1\in p_1(\1),\quad
i_2\colon p_1[i_1]\to p_2(\1),\quad
i_3\colon (d_1\in p_1[i_1])\to(d_2\in p_2[i_2(d_1)])\to p_3(\1),\\
i_k\colon(d_1\in p_1[i_1])\to(d_2\in p_2[i_2(d_1)])\to\cdots(d_{k-1}\in p_{k-1}[i_{k-1}(d_1,\ldots,d_{k-2})])\to p_k(\1)
\end{gather*}

So for example to give a position in $p\tri q\tri r$ we need 
\[
i\in p(\1),\quad
j\colon p[i]\to q(\1),\quad
k:(d\in p[i])\to(e\in q[j(d)])\to r(\1).
\]

The direction-set of $p_1\tri\cdots\tri p_k$ at position $(i_1,\ldots,i_k)$ is 
\[
(p_1\tri\cdots\tri p_k)[(i_1,\ldots,i_k)]\cong\sum_{d_1\in p_1[i_1]}\sum_{d_2\in p_2[i_2(d_1)]}\cdots\sum_{d_k\in p_k[i_k(d_1,\ldots,d_{k-1})]}\1
\]
So for example given a position $(i,j,k)\in p\tri q\tri r$, a direction there consists of a tuple $(d,e,f)$ where $d\in p[i]$, $e\in q[j(d)]$ and $f\in r[k(d,e)]$.
\end{example}

\begin{exercise}
Suppose $A_1,\ldots,A_k$ are sets and $p_i\coloneqq A_i\yon$ for each $i$. Use the notation of \cref{ex.pos_in_composite} to give the set of positions in $p\coloneqq p_1\tri\cdots\tri p_k$.
\end{exercise}

What if I give you a two-step decision to make of shape $p\tri q$: I'll give you a position in $p$, you choose a direction there, and then based on your answer I'll give you a position in $q$, and you choose a direction there too. Now if each of $p$ and $q$ knew how to delegate its decisions to its partner, say $p\to p'$ and $q\to q'$, you should be able to delegate your two-step decision in $p\tri q$ to a two-step decision by the partners $p'\tri q'$. Here's how this looks in box-notation

\begin{example}[$\tri$ on morphisms]
Given maps $f\colon p\to q$ and $f'\colon p'\to q'$, the corresponding map $(f\tri f')\colon (p\tri p')\to (q\tri q')$ looks quite simple---even sterile---in box notation:
\[
\begin{tikzpicture}[polybox, mapstos]
	\node[poly, dom, "$p$" left] (p) {};
	\node[poly, dom, above=of p, "$p'$" left] (p') {};
	\node[poly, cod, right=of p, "$q$" right] (q) {};
	\node[poly, cod, above=of q, "$q'$" right] (q') {};
	\draw (p_pos) -- node[below] {$f_1$} (q_pos);
	\draw (q_dir) -- (p_dir);
	\draw (p'_pos) -- (q'_pos);
	\draw (q'_dir) -- (p'_dir);	
\end{tikzpicture}
\]
But it gets animated when someone chooses a map from an arbitrary representable (or anything else); to do so is to choose a bunch of arrows as to the left:
\[
\begin{tikzpicture}[polybox, mapstos]
	\node[poly, pure dom, "$\yon^X$" left] (yX) {};
	\node[poly, right=1.8 of yX.south, yshift=-1ex] (p) {};
	\node[poly, above=of p] (p') {};
	\node[poly, cod, right=of p, "$q$" right] (q) {};
	\node[poly, cod, above=of q, "$q'$" right] (q') {};
	\draw (p_pos) -- (q_pos);
	\draw (q_dir) -- (p_dir);
	\draw (p'_pos) -- (q'_pos);
	\draw (q'_dir) -- (p'_dir);
	\draw (yX_pos) to[first] node[below] {$i_1$} (p_pos);
	\draw (p_dir) to[climb] node[right] {$i_2$} (p'_pos);
	\draw (p'_dir) to[last] node[above] {$i^\sharp$} (yX_dir);
\end{tikzpicture}
\]
One can now visualize the information flow through this sequence of delegations.
\end{example}



\begin{exercise}
Draw a picture analogous to \eqref{eqn.pic_tri_map} for the map $(f\tri g\tri h)\colon (p\tri q\tri r)\to (p'\tri q'\tri r')$, given $f=(f_1,f^\sharp)\colon p\to p'$, $g=(g_1,g^\sharp)\colon q\to q'$, and $h=(h_1,h^\sharp)\colon r\to r'$. Show what happens when one adds a map $\yon^X\to p\tri q\tri r$ from a representable.
\end{exercise}

%---- Subsection ----%
\subsection{Mathematical aspects of $\tri$}

We now want to get at more subtle aspects of $p\tri q$. We begin with the following.

\begin{proposition}[Left distributivity of $\tri$]\label{prop.left_dist}
For any polynomial $r$, the post-compose-with-$r$ functor $(-\tri r)\colon\poly\to\poly$ commutes---up to natural isomorphism---with addition and multiplication:
\[
  (p+q)\tri r\cong (p\tri r)+(q\tri r)
  \qqand
  pq\tri r\cong (p\tri r)(q\tri r).
\]
\end{proposition} 
\begin{proof}
Formally, this just comes down to the fact that coproducts and products of functors $\smset\to\smset$ are computed pointwise and $\poly$ is a full subcategory of $\smset^\smset$. One could instead give a proof in terms of $\sum$'s and $\prod$'s; this is done in \cref{exc.left_dist}.
\end{proof}

\begin{exercise}\label{exc.left_dist}
Prove \cref{prop.left_dist} in terms of the formula for $\tri$ given in \cref{prop.poly_closed_comp}.
\end{exercise}

\begin{example}[Picturing the left distributivity of $\tri$ over $\times$]\label{ex.picturing_dist}
We want an intuitive understanding of this left-distributivity. Let $p\coloneqq\yon$, $q\coloneqq\yon+\1$, and $r\coloneqq\yon^\2+\1$, as shown here:
\[
\begin{tikzpicture}[rounded corners]
	\node (p) [draw, blue!50!black, "$p$" above] {
	\begin{tikzpicture}[trees, sibling distance=2.5mm]
    \node (p1) {$\bullet$} 
      child {};
  \end{tikzpicture}
  };
	\node (q) [draw, blue!50!black, right=1 of p, "$q$" above] {
	\begin{tikzpicture}[trees, sibling distance=2.5mm]
    \node (q1) {$\bullet$} 
      child {};
    \node[right=.5 of q1] (q2) {$\bullet$};
  \end{tikzpicture}
  };
	\node (r) [draw, red!50!black, right=1 of q, "$r$" above] {
	\begin{tikzpicture}[trees, sibling distance=2.5mm]
    \node (r1) {$\bullet$} 
      child {}
      child {};
    \node[right=.5 of r1] (r2) {$\bullet$};
  \end{tikzpicture}
  };
\end{tikzpicture}
\]
Then $pq\cong\yon^\2+\yon$ and we can draw $pq\tri r$ as follows:
\[
\begin{tikzpicture}[rounded corners]
	\node (p) [draw, "$(p\times q)\tri r\cong$" left] {
	\begin{tikzpicture}[trees,
		level 1/.style={sibling distance=5mm},
	  level 2/.style={sibling distance=2.5mm}]
    \node[blue!50!black] (1) {$\bullet$} 
      child {node[red!50!black] {$\bullet$} 
      	child
				child
			}
      child {node[red!50!black] {$\bullet$} 
      	child
				child
			};
%
    \node[blue!50!black, right=1.3 of 1] (2) {$\bullet$} 
      child {node[red!50!black] {$\bullet$} 
				child
				child
			}
      child {node[red!50!black] {$\bullet$} 
			};
%
    \node[blue!50!black, right=1.3 of 2] (3) {$\bullet$} 
      child {node[red!50!black] {$\bullet$} 
			}
      child {node[red!50!black] {$\bullet$} 
				child
				child
			};
%
    \node[blue!50!black, right=1.3 of 3] (4) {$\bullet$} 
      child {node[red!50!black] {$\bullet$} 
			}
      child {node[red!50!black] {$\bullet$} 
			};
%
    \node[blue!50!black, right=1 of 4] (5) {$\bullet$} 
      child {node[red!50!black] {$\bullet$} 
      	child
      	child
			};
%
    \node[blue!50!black, right=.8 of 5] (6) {$\bullet$} 
      child {node[red!50!black] {$\bullet$}
      };
  \end{tikzpicture}
	};
\end{tikzpicture}
\]
Or we can compute $p\tri r$ and $q\tri r$ seperately:
\[
\begin{tikzpicture}[rounded corners]
	\node (p) [draw, "$p\tri r\cong$" left] {
	\begin{tikzpicture}[trees,
		level 1/.style={sibling distance=5mm},
	  level 2/.style={sibling distance=2.5mm}]
    \node[blue!50!black] (p1) {$\bullet$} 
      child {node[red!50!black] {$\bullet$} 
      	child
				child
			};
    \node[blue!50!black, right=.5 of p1] (p2) {$\bullet$} 
      child {node[red!50!black] {$\bullet$} 
			};
  \end{tikzpicture}
  };
%
	\node (q) [draw, "$q\tri r\cong$" left] at (4,0) {
	\begin{tikzpicture}[trees,
		level 1/.style={sibling distance=5mm},
	  level 2/.style={sibling distance=2.5mm}]
    \node[blue!50!black] (q1) {$\bullet$} 
      child {node[red!50!black] {$\bullet$} 
      	child
				child
			};
    \node[blue!50!black, right=.5 of q1] (q2) {$\bullet$} 
      child {node[red!50!black] {$\bullet$} 
			};
    \node[blue!50!black, right=.5 of q2] (q3) {$\bullet$};		
  \end{tikzpicture}
  };
\end{tikzpicture}
\]
and multiply them together by taking each tree from $p\tri r$ and pairing it with each tree from $q\tri r$:
\[
\begin{tikzpicture}[rounded corners]
	\node (p) [draw, "$(p\tri q)\times(p\tri r)\cong$" left] {
	\begin{tikzpicture}[trees,
		level 1/.style={sibling distance=5mm},
	  level 2/.style={sibling distance=2.5mm}]
    \node[blue!50!black] (1) {$\bullet$} 
      child {node[red!50!black] {$\bullet$} 
      	child
				child
			}
      child {node[red!50!black] {$\bullet$} 
      	child
				child
			};
%
    \node[blue!50!black, right=1.3 of 1] (2) {$\bullet$} 
      child {node[red!50!black] {$\bullet$} 
				child
				child
			}
      child {node[red!50!black] {$\bullet$} 
			};
%
    \node[blue!50!black, right=1 of 2] (3) {$\bullet$} 
      child {node[red!50!black] {$\bullet$} 
      	child
      	child
			};
%
    \node[blue!50!black, right=1 of 3] (4) {$\bullet$} 
      child {node[red!50!black] {$\bullet$} 
			}
      child {node[red!50!black] {$\bullet$} 
				child
				child
			};
%
    \node[blue!50!black, right=1.3 of 4] (5) {$\bullet$} 
      child {node[red!50!black] {$\bullet$} 
			}
      child {node[red!50!black] {$\bullet$} 
			};
%
    \node[blue!50!black, right=.8 of 5] (6) {$\bullet$} 
      child {node[red!50!black] {$\bullet$}
      };	  	
	\end{tikzpicture}
	};
\end{tikzpicture}
\]
\end{example}

\begin{exercise}\label{exc.picturing_dist}
Follow \cref{ex.picturing_dist} with $+$ in place of $\times$: use pictures to give an intuitive understanding of the left-distributivity $(p+q)\tri r\cong (p\tri r)+(q\tri r)$.
\end{exercise}

\begin{exercise}
Show that the distributivities of \cref{ex.picturing_dist,exc.picturing_dist} do not hold on the other side:
\begin{enumerate}
	\item Find polynomials $p,q,r$ such that $p\tri (qr)\not\cong(p\tri q)(p\tri r)$.
	\item Find polynomials $p,q,r$ such that $p\tri (q+r)\not\cong(p\tri q)+(p\tri r)$.
\qedhere
\end{enumerate}
\end{exercise}

A connected limit is one whose indexing category $J$ is (nonempty and) connected. That is, $J$ has at least one object and any two objects are connected by a finite zigzag of arrows.

\begin{example}
The following categories are connected:
\[
\fbox{$\bullet$}
\qquad
\fbox{$\bullet\tto\bullet$}
\qquad
\fbox{$\bullet\to\bullet\from\bullet$}
\qquad
\fbox{$\bullet\from\bullet\from\bullet\from\cdots$}
\]
In particular, equalizers, pullbacks, and directed limits are examples of connected limits. 

The following categories are \emph{not connected}:
\[
\fbox{$\phantom{\bullet}$}
\qquad
\fbox{$\bullet\quad\bullet$}
\qquad
\fbox{$\bullet\quad\bullet\to \bullet$}
\]
In particular, terminal objects and products are \emph{not} examples of connected limits.
\end{example}

\begin{theorem}[Preservation of connected limits]\label{thm.connected_limits}
The operation $\tri$ commutes with connected limits in both variables. That is, if $J$ is a connected category, $p\colon J\to\poly$ is a functor, and $q\in\poly$ is a polynomial, then there are natural isomorphisms
%\[
%	(\lim_{j\in J} p_{j,})\tri q\cong \lim_{j\in J}(p_{j,}\tri q)
%	\qqand
%	q\tri(\lim_{j\in J} p_{j,})\cong \lim_{j\in J}(q\tri p_{j,})
%\]
\[
	\left(\lim_{j\in J} p_j\right)\tri q\cong \lim_{j\in J}(p_j\tri q)
	\qqand
	q\tri\left(\lim_{j\in J} p_j\right)\cong \lim_{j\in J}(q\tri p_j)
\]
\end{theorem}
\begin{proof}[Sketch of proof]
The claim for the left variable follows as in the proof of \cref{prop.left_dist}: limits of functors $\smset\to\smset$ are computed pointwise and $\poly$ is a full subcategory of $\smset^\smset$ closed under limits. The claim for the right-hand variable comes down to the fact that polynomials are sums of representables; representable functors commute with all limits and sums commute with connected limits in $\smset$. See \cite[Proposition 1.6]{kock2012polynomial} for details.
\end{proof}

\begin{exercise}\label{ex.connected_limits_and_tri}
Use \cref{thm.connected_limits} in the following.
\begin{enumerate}
	\item Let $p$ be a polynomial, thought of as a functor $p\colon\smset\to\smset$. Show that $p$ preserves connected limits (of sets).
	\item Show that for any polynomials $p,q,r$ we have an isomorphism:
	\[
	p\tri(qr)\cong (p\tri q)\times_{(p\tri\1)}(p\tri r)
	\]
	\item Show that the distributivity $pq\tri r\cong (p\tri r)(q\tri r)$ is a special case of \cref{thm.connected_limits}.
	\item Show that for any set $A$ and polynomials $p,q$, we have an isomorphism $A(p\tri q)\cong (Ap)\tri q$.
\qedhere
\end{enumerate}
\end{exercise}

While we're here, it will be helpful to record the following.
\begin{proposition}
For any polynomial $q\in\poly$, tensoring with $q$ (on either side) preserves connected limits. That is, if $J$ is connected and $p\colon J\to\poly$ is a functor, then there is a natural isomorphism:
\[
	\left(\lim_{j\in J} p_j\right)\otimes q\cong
	\lim_{j\in J} (p_j\otimes q).
\]
\end{proposition}


\begin{proposition}
For any polynomials $p,p',q,q'$ there are natural maps
\begin{align}\label{eqn.plus_duoidal}
	(p\tri p')+(q\tri q')&\to (p+q)\tri(p'+q')\\\label{eqn.otimes_duoidal}
	(p\tri p')\otimes(q\tri q')&\to(p\otimes pq)\tri(p'\otimes q')\\\label{eqn.times_duoidal}
	(p\tri p')\times (q\tri q')&\from(p\times q)\tri(p'\times q')
\end{align}
making $(+,\tri)$ and $(\otimes,\tri)$ duoidal structures and $(\times,\tri)$ op-duoidal.
\end{proposition}
\begin{proof}
For \eqref{eqn.plus_duoidal} we have inclusion maps $p\to p+q$ and $p'\to p'+q'$, inducing a map $p\tri p'\to(p+q)\tri(p'+q')$. Similarly we obtain a map $q\tri q'\to(p+q)\tri(p'+q')$, so we get the desired map from the universal property of coproducts. It is straightforward to check that this is duoidal. The result for \eqref{eqn.times_duoidal} is similar. 

It remains to give a map \eqref{eqn.times_duoidal}.**
\end{proof}

%\begin{exercise}\label{exc.plus_duoidal}
%\begin{enumerate}
%	\item Give maps $0\to 0+0$, $\yon\to\yon\tri\yon$, and $0\to\yon$.
%	\item Check that the following diagrams commute:
%\[ 
%\begin{tikzcd}
%	(p\tri p')+0\ar[r]&
%	(p\tri p)+(0\tri 0)\ar[d]\\
%	p\tri p'&
%	(p+0)\tri (p'+0)\ar[l]
%\end{tikzcd}
%\hspace{1in}
%\begin{tikzcd}
%	((p\tri p')+(q\tri q'))+(r\tri r')\ar[r]\ar[d]&
%	(p\tri p')+((q\tri q')+(r\tri r'))\ar[r]&
%	(p\tri p')+((q+r)\tri(q'+r'))\ar[d]\\
%	((p+ q)\tri(p'+ q'))+(r\tri r')\ar[r]&
%	((p+q)+r)\tri((p'+q')+r')\ar[r]&
%	(p+(q+r))\tri(p'+(q'+r'))
%\end{tikzcd}
%\]
%\qedhere
%\end{enumerate}
%\end{exercise}


\begin{proposition}[$\tri$ preserves cartesian maps in both variables]\label{prop.comp_pres_cart}
If $f\colon p\to p'$ and $g\colon q\to q'$ are cartesian then so is $(f\tri g)\colon(p\tri q)\to (p'\tri q')$.
\end{proposition}
\begin{proof}
For any $h\colon A\to B$ of sets, all faces of the cube
\[
\begin{tikzcd}[sep=small]
  pqA\ar[rr]\ar[dd]\ar[dr]&&
  pqB\ar[dd]\ar[dr]\\&
  pq'A\ar[rr, crossing over]&&
  pq'B\ar[dd]\\
  pq'A\ar[rr]\ar[dr]&&
  pq'B\ar[dr]\\&
  p'q'A\ar[from=uu, crossing over]\ar[rr]&&
  p'q'B
\end{tikzcd}
\]
are pullbacks by \cref{prop.cart_as_nt,thm.connected_limits}. Hence the diagonal is too by standard properties of pullbacks.
\end{proof}

\begin{exercise}
\begin{enumerate}
	\item Show that if $f$ is an isomorphism and $g$ is vertical then $f\tri g$ is vertical.
	\item Find a polynomial $q$ and a vertical morphism $f\colon p\to p'$ such that $(f\tri\id_q)\colon (p\tri q)\to (p'\tri q)$ is not vertical.
\qedhere
\end{enumerate}
\end{exercise}

%-------- Section --------%
\section{Comonoids in $\poly$}\label{sec.comonoids_in_poly}

\slogan{Imagine a sort of realm, where there are various positions you can be in. From every position, there are a number of moves you can make, possibly infinitely many. But whatever move you make, you'll end up in a new position. Well, technically it counts as a move to simply stay where you are, so you might end up in the same position. But wherever you move to, you can move again, and any number of moves from an original place counts as a single move. What sort of realm is this?}

The most surprising aspects of $\poly$ really begin with its comonoids. In 2018, researchers Daniel Ahman and Tarmo Uustalu showed that comonoids in $(\poly,\yon,\tri)$ can be identified with categories. Every category in the usual sense is a comomonoid in $\poly$ and every comonoid in $\poly$ is a category. We find this revelation to be truly shocking, and suggests some very different ways to think about categories. Let's go through it.

\begin{definition}[Comonoid]\label{def.comonoid}
A \emph{comonoid} in a monoidal category $(\cat{C},I,\lhd)$
is a tuple $(c,\epsilon,\delta)$ where $c\in\cat{C}$ is an object, and $\epsilon\colon c\to I$ and $\delta\colon c\to c\lhd c$ are maps, such that the following diagrams commute:
\begin{equation}\label{eqn.comonoid_diagrams}
\begin{tikzcd}[background color=definitioncolor, row sep=large]
	\yon\lhd c&c\ar[d, "\delta" description]\ar[r, equal]\ar[l, equal]&c\lhd\yon\\&
	c\lhd c\ar[ul, "\epsilon\lhd c"]\ar[ur, "c\lhd\epsilon"']
\end{tikzcd}
\hspace{.6in}
\begin{tikzcd}[row sep=large]
	c\vphantom{\yon}\ar[r, "\delta"]\ar[d, "\delta"']&
	c\lhd c\ar[d, "c\lhd\delta"]\\
	c\lhd c\ar[r, "\delta\lhd c"']&
	c\lhd c\lhd c
\end{tikzcd}
\end{equation}
We refer to a comonoid $P\coloneqq(p,\epsilon,\delta)$ in $(\poly,\yon,\tri)$ as a \emph{polynomial comonoid}.
\end{definition}

Here's a picture of one of the unit laws:
\[
\begin{tikzpicture}
	\node (1) {
  \begin{tikzpicture}[polybox, tos]
  	\node[poly, dom] (yX) {};
  	\node[poly, right=1.8 of yX.south, yshift=-1ex] (p) {};
  	\node[poly, above=of p] (p') {};
  	\node[poly, cod, identity, right=of p] (q) {};
  	\node[poly, cod, above=of q] (q') {};
  	\draw (p_pos) -- (q_pos);
  	\draw (q_dir) -- node[above] {$\epsilon^\sharp$} (p_dir);
  	\draw (p'_pos) -- (q'_pos);
  	\draw (q'_dir) -- (p'_dir);
  	\draw (yX_pos) to[first] node[below] {$\delta_1$} (p_pos);
  	\draw (p_dir) to[climb] node[right] {$\delta_2$} (p'_pos);
  	\draw (p'_dir) to[last] node[above] {$\delta^\sharp$} (yX_dir);
  \end{tikzpicture}
	};
	\node[right=1.8 of 1] (2) {
  \begin{tikzpicture}[polybox, tos]
  	\node[poly, dom] (yX) {};
  	\node[poly, right=1.8 of yX.south, yshift=-1ex] (p) {};
  	\node[poly, cod, above=of p] (p') {};
  	\draw (yX_pos) to[first] node[below] {$\delta_1$} (p_pos);
  	\draw (p_dir) to[climb] node[right] {$\delta_2$} (p'_pos);
  	\draw (p'_dir) to[last] node[above] {$\delta^\sharp$} (yX_dir);
		\draw (p_pos) to[climb'] node[right] {$\epsilon^\sharp$} (p_dir);
  \end{tikzpicture}
	};
	\node[right=1.8 of 2] (3) {
  \begin{tikzpicture}[polybox, tos]
  	\node[poly, dom] (c) {};
  	\node[poly, cod, right=of c] (c') {};
  	\draw[double] (c_pos) -- (c'_pos);
  	\draw[double] (c'_dir) -- (c_dir);
	\end{tikzpicture}
	};
	\node at ($(1.east)!.5!(2.west)$) {=};
	\node at ($(2.east)!.5!(3.west)$) {=};
\end{tikzpicture}
\]
We'll put the associativity and the other unitality picture in the following exercise. The meaning of $\epsilon$ and $\delta$ will become clear; for those who want a hint, see \cref{subsec.understanding_comonoids}.
\begin{exercise}
\begin{enumerate}
	\item Draw the other unitality equation.
	\item Draw the associativity equation.
\qedhere
\end{enumerate}
\end{exercise}

\begin{example}[$\delta^{n}$ notation]\label{ex.delta_n_notation}
Let $(c,\epsilon,\delta)$ be a comonoid. From the associativity of $\delta$, the two ways to get a map $c\to c\tri c\tri c$ have the same result. This is true for any $n\in\nn$: we get an induced map $c\to c\tripow{n+1}$, which by mild abuse of notation we denote $\delta^n$:
\[
	c\To{\delta}c\tri c\To{c\tri\delta}c\tri c\tri c\To{c\tripow{2}\tri\delta}\cdots\To{c\tripow{n}\tri\delta}c\tripow{(n+1)}.
\]
In particular, we have $\delta^1=\delta$ and we may write $\delta^0\coloneqq\id_c$ and $\delta^{-1}\coloneqq\epsilon$.
\end{example}

Polynomial comonoids are usually called \emph{polynomial comonads}. Though polynomials $p$ can be interpreted as polynomial \emph{functors} $p\colon\smset\to\smset$, we do not generally emphasize this part of the story; we use it when it comes in handy, but generally we think of polynomials more as dependent arenas, or sets of corollas.

\begin{example}[The state comonad $S\yon^S$]\label{ex.state_comonad_1}
Let $S$ be a set, and consider the polynomial $p\coloneqq S\yon^S$. It has a canonical comonoid structure---often called the \emph{state} comonad---as we discussed in \cref{sec.dynam_in_poly}, page~\pageref{page.poly_comonad}. To say it in the current language, we first need to give maps $\epsilon\colon p\to \yon$ and $\delta\colon p\to p\tri p$. By \cref{eqn.composite_formula,eqn.monomials_and_comp}, this is equivalent to giving functions
\begin{align}\nonumber
	S&\To{\epsilon'} S&
	S&\To{\delta'}\sum_{s'\in S}\prod_{s_1\in S}\sum_{s_1'\in S}\prod_{s_2\in S}S\\
\intertext{We take $\epsilon'$ to be the identity and we take $\delta'$ to be}
	s&\Mapsto{\epsilon'} s&
  s&\Mapsto{\delta'} (s'\coloneqq s, s_1\mapsto (s_1'\coloneqq s_1, s_2\mapsto s_2)).\label{eqn.state_comonoid_eps_del}
\end{align}
If you know how to read such things, you'll see that each element $s\in S$ is just being passed in a straightforward way. But we find this notation cumbersome and prefer the poly-box notation.
\begin{equation}\label{eqn.state_comonoid_eps_del2}
\begin{tikzpicture}
	\node (id) {
  \begin{tikzpicture}[polybox, mapstos]
  	\node[poly, dom, "$S\yon^S$" left] (S) {$s$\nodepart{two}$s$};
  	\node[poly, identity, right=of S, "$\yon$" right] (y) {\pphantom{s}{s}};
  	\draw (S_pos) to[first] (y_pos);
  	\draw (y_dir) to[last] (S_dir);
		\node at ($(S)!.5!(y)$) {$\epsilon$};
  \end{tikzpicture}
  };
  \node[right=of id] (co) {
  \begin{tikzpicture}[polybox, mapstos]
  	\node[poly, dom] (p) {$s_2$\nodepart{two}$s$};
  	\node[poly, cod, right= of p.south, yshift=-1ex] (q) {$s_1$\nodepart{two}$s$};
  	\node[poly, cod, above=of q] (r) {$s_2$\nodepart{two}$s_1$};
  	\draw (p_pos) to[first] (q_pos);
  	\draw (q_dir) to[climb] node[right] {$\delta$} (r_pos);
  	\draw (r_dir) to[last] (p_dir);
  \end{tikzpicture}  
  };
\end{tikzpicture}
\end{equation}
\end{example}

\begin{exercise}
Let $p\coloneqq S\yon^S$. For any $n\in\nn$, write out the morphism of polynomials $\delta^n\colon p\to p\tripow{(n+1)}$ either set-theoretically or in terms of poly-boxes as in \cref{ex.state_comonad_1}
\end{exercise}

\begin{example}[Picturing the comonoid $S\yon^S$]\label{ex.picturing_SyS}
Let's see this whole thing in pictures. First of all, let's take $S\coloneqq\3\cong\{\bul[red],\bul[dgreen],\bul[blue]\}$ and draw $\{\bul[red],\bul[dgreen],\bul[blue]\}\yon^{\{\bul[red],\bul[dgreen],\bul[blue]\}}$:
\[
\begin{tikzpicture}[rounded corners]
	\node (p1) [draw, "$\3\yon^\3=$" left] {
  \begin{tikzpicture}[trees, sibling distance=4mm]
  	\foreach \i/\c in {1/red, 2/dgreen, 3/blue}
  	{
      \node["\tiny \i" below, \c] at (1.8*\i,0) {$\bullet$} 
        child [red]
        child [dgreen]
        child [blue]
      ;
  	};
  \end{tikzpicture}
  };
\end{tikzpicture}
\]
The map $\epsilon\colon S\yon^S\to \yon$ can be drawn as follows:
\[
\begin{tikzpicture}[trees, bend right]
	\foreach \i/\c in {1/red, 2/dgreen, 3/blue}
	{
  	\node["\tiny \i" below, \c] (\i) at (3*\i, 0) {$\bullet$} 
    	child [red] {coordinate (\i1)}
      child [dgreen] {coordinate (\i2)}
      child [blue] {coordinate (\i3)}
     	;
  	\node[right=of \i] (y\i) {$\bullet$}
  		child{coordinate (y\i')}
  		;
	\draw[|->, shorten <= 3pt, shorten >= 3pt] (\i) -- (y\i);
	\draw[densely dotted, postaction={decorate}] (y\i') to (\i\i);
	};
\end{tikzpicture}
\]
It picks out one direction at each position, namely the one of the same color.

The map $\delta\colon S\yon^S\to (S\yon^S)\tripow{2}$ can be drawn as follows:
\begin{equation}\label{eqn.state_comonoid_trees}
\begin{tikzpicture}[trees, 
  level 1/.style={sibling distance=5mm},
  level 2/.style={sibling distance=1.5mm},
	bend right=60]
	\foreach \i/\c in {1/red, 2/dgreen, 3/blue}
	{
  	\node[\c] (\i) at (4*\i, 0) {$\bullet$} 
    	child [red] {coordinate (\i1)}
      child [dgreen] {coordinate (\i2)}
      child [blue] {coordinate (\i3)}
     	;
  	\node[right=1.7 of \i, \c] (SS\i) {$\bullet$}
  		child [red] {node (S\i1) {$\bullet$} 
				child [red] {coordinate (\i11)}
				child [dgreen] {coordinate (\i12)} 
				child [blue] {coordinate (\i13)}
				}
  		child [dgreen] {node (S\i2) {$\bullet$} 
				child [red] {coordinate (\i21)}
				child [dgreen] {coordinate (\i22)} 
				child [blue] {coordinate (\i23)}
				}
  		child [blue] {node (S\i3) {$\bullet$} 
				child [red] {coordinate (\i31)}
				child [dgreen] {coordinate (\i32)} 
				child [blue] {coordinate (\i33)}
				}
  		;
	\draw[|->, shorten <= 3pt, shorten >= 3pt] (\i) -- (SS\i);
	\foreach \j in {1,2,3}
	{
		\foreach \k\d in {1/red, 2/dgreen, 3/blue}
		{
			\draw[densely dotted, postaction={decorate}, \d] (\i\j\k) to (\i\k);
		};
	};
	};
\end{tikzpicture}
\end{equation}
Note that $(S\yon^S)\tripow{2}$ has $SS^S$, or in this case $\8\1$ many trees, only three of which are being pointed to by $\delta$. That is, there is in general no rule on trees in that says the color of an arrow should agree in any sense with the color of the node it points to: \eqref{eqn.state_comonoid_trees} shows that the comonoid structure is pointing out the special trees where that does occur.

It remains to check the comonoid laws, the three commutative diagrams in \eqref{eqn.comonoid_diagrams}. The first two say that the composites
\[
S\yon^S\To{\delta}(S\yon^S)\tripow{2}\To{\id\tri\epsilon}S\yon^S
\qqand
S\yon^S\To{\delta}(S\yon^S)\tripow{2}\To{\epsilon\tri \id}S\yon^S
\]
are the identity. Let's return to the case $S=\3$. Then the second map in each case involves 81 different assignments, but only three of them will matter.%
\footnote{To say technically that we can disregard all but three positions in $(S\yon^S)\tripow{2}\cong SS^S\yon^{SS}$, one can use \cref{prop.vert_cart_factorization}.} 
Since all three are strongly similar, we will draw only the red case. We also only draw the relevant passback maps.
\[
\begin{tikzpicture}[trees, 
  level 1/.style={sibling distance=5mm},
  level 2/.style={sibling distance=1.5mm},
	bend right=60, 
	]
	\foreach \i/\c in {1/red}
	{
  	\node[\c] (\i) at (4*\i, 0) {$\bullet$} 
    	child [red] {coordinate (\i1)}
      child [dgreen] {coordinate (\i2)}
      child [blue] {coordinate (\i3)}
     	;
  	\node[right=1.7 of \i, \c] (SS\i) {$\bullet$}
  		child [red] {node (S\i1) {$\bullet$} 
				child [red] {coordinate (\i11)}
				child [dgreen] {coordinate (\i12)} 
				child [blue] {coordinate (\i13)}
				}
  		child [dgreen] {node (S\i2) {$\bullet$} 
				child [red] {coordinate (\i21)}
				child [dgreen] {coordinate (\i22)} 
				child [blue] {coordinate (\i23)}
				}
  		child [blue] {node (S\i3) {$\bullet$} 
				child [red] {coordinate (\i31)}
				child [dgreen] {coordinate (\i32)} 
				child [blue] {coordinate (\i33)}
				}
  		;
  	\node[\c] (\i') at (8*\i, 0) {$\bullet$} 
      child [red] {node[black] {$\bullet$}
      	child [black] {coordinate (11'')}
			}
      child [dgreen] {node[black] {$\bullet$}
      	child [black] {coordinate (12'')}
			}
      child [blue] {node[black] {$\bullet$}
      	child [black] {coordinate (13'')}
			}
     	;
		;
  	\draw[|->, shorten <= 3pt, shorten >= 3pt] (\i) -- (SS\i);
  	\draw[|->, shorten <= 3pt, shorten >= 3pt] (SS\i) -- (\i');
		\foreach \j in {1,2,3}
		{
		\draw[densely dotted, postaction={decorate}] (1\j'') to (1\j\j);
		\draw[densely dotted, postaction={decorate}] (1\j\j) to (1\j);
		};
	};
\end{tikzpicture}
\]
\[
\begin{tikzpicture}[trees, 
  level 1/.style={sibling distance=5mm},
  level 2/.style={sibling distance=1.5mm},
	bend right=60, 
	]
	\foreach \i/\c in {1/red}
	{
  	\node[\c] (\i) at (4*\i, 0) {$\bullet$} 
    	child [red] {coordinate (\i1)}
      child [dgreen] {coordinate (\i2)}
      child [blue] {coordinate (\i3)}
     	;
  	\node[right=1.7 of \i, \c] (SS\i) {$\bullet$}
  		child [red] {node (S\i1) {$\bullet$} 
				child [red] {coordinate (\i11)}
				child [dgreen] {coordinate (\i12)} 
				child [blue] {coordinate (\i13)}
				}
  		child [dgreen] {node (S\i2) {$\bullet$} 
				child [red] {coordinate (\i21)}
				child [dgreen] {coordinate (\i22)} 
				child [blue] {coordinate (\i23)}
				}
  		child [blue] {node (S\i3) {$\bullet$} 
				child [red] {coordinate (\i31)}
				child [dgreen] {coordinate (\i32)} 
				child [blue] {coordinate (\i33)}
				}
  		;
  	\node[black] (\i') at (8*\i, 0) {$\bullet$}
			child {node[red] {$\bullet$} 
        child [red] {coordinate (11'')}
        child [dgreen] {coordinate (12'')}
        child [blue] {coordinate (13'')}
      }
     	;
		;
  	\draw[|->, shorten <= 3pt, shorten >= 3pt] (\i) -- (SS\i);
  	\draw[|->, shorten <= 3pt, shorten >= 3pt] (SS\i) -- (\i');
		\foreach \j in {1,2,3}
		{
		\draw[densely dotted, postaction={decorate}] (1\j'') to (11\j);
		\draw[densely dotted, postaction={decorate}] (11\j) to (1\j);
		};
	};
\end{tikzpicture}
\]
We do not show associativity here, but instead leave it to the reader in \cref{exc.state_comonoid_assoc}.
\end{example}

\begin{exercise}\label{exc.state_comonoid_assoc}
Let $S\coloneqq\2$ and $c\coloneqq \2\yon^\2$.
\begin{enumerate}
	\item Draw $c$ using color if possible.
	\item We know $c$ is supposed to be the carrier of a comonoid $(c,\epsilon,\delta)$. Which two maps $ c\to c\tripow{3}$ are supposed to be equal by associativity?
	\item Draw these two maps in the style of \cref{ex.picturing_SyS}.
	\item Are they equal?
\qedhere
\end{enumerate}
\end{exercise}

\paragraph{Speeding up dynamical systems}

Suppose we have a dynamical system $f\colon S\yon^S\to p$, and we want to make it go $k$-times faster. That is, in every moment, we want it to process $k$-many inputs, rather than one. 

Since $S\yon^S$ has the structure of a comonoid, we know that for every $k\in\nn$ we have a map $\delta^{k-1}\colon S\yon^S\to (S\yon^S)\tripow{k}$ by \cref{ex.delta_n_notation}. But we also have maps $f\tripow{k}\colon (S\yon^S)\tripow{k}\to p\tripow{k}$ because $\tri$ is a monoidal product. Thus we can form the composite
\begin{equation}\label{eqn.speedup}
\begin{tikzcd}
	S\yon^S\ar[r, "\delta^{k-1}"]\ar[rr, bend right, "{\text{Spdup}_k(f)}"']&
	(S\yon^S)\tripow{k}\ar[r, "f\tripow{k}"]&
	p\tripow k
\end{tikzcd}
\end{equation}
For every state $s\in S$, we now have a length-$k$ strategy in $p$, i.e.\ a tree of height $k$ in $p$, or explicitly a choice of $p$-position and, for every direction there, another $p$-position and so on $k$ times. Here is a poly-box drawing for the $k=3$ case:
\[
\begin{tikzpicture}
	\node (given) {
	\begin{tikzpicture}[polybox, tos]
		\node[poly, dom, blue, "$S\yon^S$" left] (S) {};
		\node[poly, cod, dgreen, right=of S, "$p$" right] (p) {};
		\draw (S_pos) to[first] (p_pos);
		\draw (p_dir) to[last]  (S_dir);
		\node at ($(S.east)!.5!(p.west)$) {$f$};
	\end{tikzpicture}
	};
	\node[right=of given] (obtain) {
	\begin{tikzpicture}[polybox, tos]
		\node[poly, dom, blue, "$S\yon^S$" left] (S) {};
		\node[poly, blue, right=of S] (S2) {};
		\node[poly, blue, below=of S2] (S1) {};
		\node[poly, blue, above=of S2] (S3) {};
		\node[poly, dgreen, cod, right=of S1] (p1) {};
		\node[poly, dgreen, cod, right=of S2] (p2) {};
		\node[poly, dgreen, cod, right=of S3] (p3) {};
%
		\draw (S1_pos) to[first] (p1_pos);
		\draw (p1_dir) to[last] (S1_dir);		
		\draw (S2_pos) to[first] (p2_pos);
		\draw (p2_dir) to[last]  (S2_dir);		
		\draw (S3_pos) to[first] (p3_pos);
		\draw (p3_dir) to[last]  (S3_dir);
		\draw[blue] (S_pos) to[first] (S1_pos);
		\draw[blue] (S1_dir) to[climb] (S2_pos);
		\draw[blue] (S2_dir) to[climb] (S3_pos);
		\draw[blue] (S3_dir) to[last] (S_dir);
		\node[blue] at ($(S.east)!.4!(S2.west)$) {$\delta^2$};
		\node at ($(S1.east)!.4!(p1.west)$) {$f$};
		\node at ($(S2.east)!.4!(p2.west)$) {$f$};
		\node at ($(S3.east)!.4!(p3.west)$) {$f$};		
  \end{tikzpicture}	
	};
	\node[above] at (obtain.north) (obtain_lab) {Obtain for $k=3$};
	\node at (given|-obtain_lab) {Given $f\colon S\yon^S\to p$};
\end{tikzpicture}
\]

\begin{example}
Let $p\coloneqq\rr\yon^\1$, let $S\coloneqq\nn$, and let $\lens{f^\sharp}{f_1}\colon S\yon^S\to p$ be given by $f_1(n)\coloneqq n$ and $f^\sharp(n,1)\coloneqq n+1$. What is this speedup map $\text{Spdup}_k(f)$? First of all, its type is 
\[\text{Spdup}_k(f)\colon S\yon^S\to\rr^k\yon,\]
meaning that it has the same set of states as before, but it outputs $k$-many reals in every moment. 

So for example with $k=3$ here is one moment of output:
\[
\begin{tikzpicture}[polybox, mapstos]
		\node[poly, dom, "$S\yon^S$" left] (S) {$n+3$\vphantom{!}\nodepart{two}$n$\vphantom{!}};
		\node[poly, right=of S] (S2) {$n+2$\vphantom{!}\nodepart{two}$n+1\vphantom{!}$};
		\node[poly, below=of S2] (S1) {$n+1$\vphantom{!}\nodepart{two}$n\vphantom{!}$};
		\node[poly, above=of S2] (S3) {$n+3$\vphantom{!}\nodepart{two}$n+2\vphantom{!}$};
		\node[poly, linear cod, right=of S1, "$\rr\yon$" right] (p1) {$!$\nodepart{two}$\hphantom{+}n\hphantom{+}$\vphantom{!}};
		\node[poly, linear cod, right=of S2, "$\rr\yon$" right] (p2) {$!$\nodepart{two}$n+1$\vphantom{!}};
		\node[poly, linear cod, right=of S3, "$\rr\yon$" right] (p3) {$!$\nodepart{two}$n+2$\vphantom{!}};
%
		\draw (S1_pos) to[first] (p1_pos);
		\draw (p1_dir) to[last] (S1_dir);		
		\draw (S2_pos) to[first] (p2_pos);
		\draw (p2_dir) to[last]  (S2_dir);		
		\draw (S3_pos) to[first] (p3_pos);
		\draw (p3_dir) to[last]  (S3_dir);
		\draw (S_pos) to[first] (S1_pos);
		\draw (S1_dir) to[climb] (S2_pos);
		\draw (S2_dir) to[climb] (S3_pos);
		\draw (S3_dir) to[last] (S_dir);
\end{tikzpicture}
\]
So for example starting at initial state $n=0$, we get the following output stream, e.g.\ for 4 seconds:
\[(0,1,2),(3,4,5),(6,7,8),(9,10,11).\]
\end{example}

\paragraph{Other comonoids}

Once you know that these all important $S\yon^S$-things are comonoids in $\poly$, it's interesting to ask ``what are all the comonoids in $\poly$?'' Let's discuss another one before answering the question in generality.

\begin{example}[A simple comonoid that's not $S\yon^S$]\label{ex.walking_arrow}
The polynomial $\yon^\2+\yon$ can be given a comonoid structure. Let's first associate names to its positions and directions. 

Define $w\coloneqq\{A\}\yon^{\{i_A,f\}}+\{B\}\yon^{\{i_B\}}$; it is clearly isomorphic to $\yon^\2+\yon$, but its notation is meant to remind the reader of the walking arrow category
\[
\cat{W}\coloneqq\boxCD{examplecolor}{
$A\Too{f}B$
}
\]
We will use the category $\cat{W}$ as inspiration for equipping $w$ with a comonoid structure $(w,\epsilon,\delta)$. The map $\epsilon$ will pick out identity arrows and the map $\delta$ will tell us about codomains and composition (which is rather trivial in the case of $\cat{W}$). Here's a picture of $w\cong\yon^\2+\yon$:
\[
\begin{tikzpicture}[rounded corners]
	\node (p1) [draw, "$w\coloneqq$" left] {
	\begin{tikzpicture}[trees, sibling distance=5mm]
    \node["\tiny $A$" below, red] (1) {$\bullet$} 
      child  {coordinate (iA) \idchild}
      child {coordinate (f)};
    \node[right=.8 of 1,"\tiny $B$" below, blue] (2) {$\bullet$} 
      child  {coordinate (iB) \idchild};
    \node[below left=0 of iA, font=\tiny] {$i_A$};
    \node[below left=0 of iB, font=\tiny] {$i_B$};
    \node[below right=0 of f, font=\tiny] {$f$};
  \end{tikzpicture}
  };
\end{tikzpicture}
\]

We first need to choose a map of polynomials $\epsilon\colon w\to\yon$; it can be identified with a dependent function $\epsilon^\sharp\colon (o\in w(\1))\to w[o]$, assigning to each position a direction there. Let's take $\epsilon^\sharp(A)\coloneqq i_A$ and $\epsilon^\sharp(B)\coloneqq i_B$:
\[
\begin{tikzpicture}[trees, bend right=60]
  \node[red] (1) {$\bullet$} 
  	child  {coordinate (11) \idchild}
    child {coordinate (12)};
  \node[right=1.5 of 1] (1y) {$\bullet$}
  	child {coordinate (1y1)};
%
  \node[right=2 of 1y, blue] (2) {$\bullet$} 
  	child  {coordinate (21) \idchild};
  \node[right=1.5 of 2] (2y) {$\bullet$}
  	child {coordinate (2y1)};
	\draw[|->, shorten <= 3pt, shorten >= 3pt] (1) -- (1y);
	\draw[|->, shorten <= 3pt, shorten >= 3pt] (2) -- (2y);
	\draw[densely dotted, postaction={decorate}] (1y1) to (11);
	\draw[densely dotted, postaction={decorate}] (2y1) to (21);
\end{tikzpicture}
\]
Now we need a map of polynomials $\delta\colon w\to w\tri w$. Let's draw out $w\tri w$ to see what it looks like.
\[
\begin{tikzpicture}[rounded corners]
	\node (p1) [draw, "$w\tri w=$" left] {
	\begin{tikzpicture}[trees,
	  level 1/.style={sibling distance=5mm},
  	level 2/.style={sibling distance=2.5mm}]
    \node[red] (1) {$\bullet$} 
      child  {
        node [red] {$\bullet$} 
 		    child  {\idchild}
      	child {}
			\idchild
			}
      child  {
        node [red] {$\bullet$} 
 		    child  {\idchild}
      	child {}
			};
    \node[right=1 of 1, red] (2) {$\bullet$} 
      child  {
        node [red]{$\bullet$} 
 		    child  {\idchild}
      	child {}
			\idchild
			}
      child {node [blue] {$\bullet$} 
      	child  {\idchild}
			};
    \node[right=1 of 2, red] (3) {$\bullet$} 
      child {node [blue] {$\bullet$} 
      	child  {\idchild}
				\idchild
			}
      child  {
        node [red] {$\bullet$} 
 		    child {\idchild}
      	child {}
			};
    \node[right=1 of 3, red] (4) {$\bullet$} 
      child {node [blue] {$\bullet$} 
      	child  {\idchild}
			\idchild
			}
      child {node [blue] {$\bullet$} 
      	child  {\idchild}
			};
    \node[right=.8 of 4, blue] (5) {$\bullet$} 
      child  {
        node [red] {$\bullet$} 
 		    child  {\idchild}
      	child {}
			\idchild
			};
    \node[right=.6 of 5, blue] (6) {$\bullet$} 
      child {node [blue] {$\bullet$} 
      	child  {\idchild}
			\idchild
			};
  \end{tikzpicture}
  };
\end{tikzpicture}
\]
The map $\delta$ is going to tell us both about codomains and composition. Here it is:
\[
\begin{tikzpicture}[trees, sibling distance=5mm,	bend right=60]
	\node (1A) [red] {$\bullet$} 
  	child  {coordinate (1A1) \idchild}
    child {coordinate (1A2)};
  \node (2A) [right=1.5 of 1A, red] {$\bullet$} 
      child  {
        node [red] {$\bullet$} 
 		    child  {coordinate (2A1) \idchild}
      	child {coordinate (2A2)}
			\idchild
			}
      child {node [blue] {$\bullet$} 
      	child  {coordinate (2A3) \idchild}
			};
	\draw[|->, shorten <= 3pt, shorten >= 3pt] (1A) -- (2A);
	\draw[densely dotted, postaction={decorate}] (2A1) to (1A1);
	\draw[densely dotted, postaction={decorate}] (2A2) to (1A2);
	\draw[densely dotted, postaction={decorate}] (2A3) to (1A2);
%
  \node[right=2 of 2A, blue] (1B) {$\bullet$} 
  	child  {coordinate (1B1) \idchild};
  \node[right=1.5 of 1B, blue] (2B) {$\bullet$} 
  	child {node [blue] {$\bullet$} 
    child  {coordinate (2B1) \idchild}
		\idchild
	};
	\draw[|->, shorten <= 3pt, shorten >= 3pt] (1B) -- (2B);
	\draw[densely dotted, postaction={decorate}] (2B1) to (1B1);
\end{tikzpicture}
\]
The on-positions map selects, for each position (either $A$ or $B$) the two-level tree starting at that position and having the correct codomains: the identity arrow on $A$ points to the corolla for $A$; the $f$ map points to the corolla for $B$; and the identity arrow on $B$ points to the corolla for $B$. The on-directions maps assign the correct composites. Here is $\delta\colon w\to w\tri w$ again, in terms of poly-boxes.
\[
\begin{tikzpicture}
	\node (p1) {
	  \begin{tikzpicture}[polybox, mapstos]
  	\node[poly, dom] (p) {$i_A$\nodepart{two}$A$};
  	\node[poly, cod, right= of p.south, yshift=-1ex] (q) {$i_A$\nodepart{two}$A$};
  	\node[poly, cod, above=of q] (r) {$i_A$\nodepart{two}$A$};
  	\draw (p_pos) to[first] (q_pos);
  	\draw (q_dir) to[climb] (r_pos);
  	\draw (r_dir) to[last] (p_dir);
  \end{tikzpicture}  
	};
	\node[right=1 of p1] (p2) {
	  \begin{tikzpicture}[polybox, mapstos]
  	\node[poly, dom] (p) {$f$\nodepart{two}$A$};
  	\node[poly, cod, right= of p.south, yshift=-1ex] (q) {$i_A$\nodepart{two}$A$};
  	\node[poly, cod, above=of q] (r) {$f$\nodepart{two}$A$};
  	\draw (p_pos) to[first] (q_pos);
  	\draw (q_dir) to[climb] (r_pos);
  	\draw (r_dir) to[last] (p_dir);
  \end{tikzpicture}  
	};
	\node[right=1 of p2] (p3) {
	  \begin{tikzpicture}[polybox, mapstos]
  	\node[poly, dom] (p) {$f$\nodepart{two}$A$};
  	\node[poly, cod, right= of p.south, yshift=-1ex] (q) {$f$\nodepart{two}$A$};
  	\node[poly, cod, above=of q] (r) {$i_B$\nodepart{two}$B$};
  	\draw (p_pos) to[first] (q_pos);
  	\draw (q_dir) to[climb] (r_pos);
  	\draw (r_dir) to[last] (p_dir);
  \end{tikzpicture}  
	};
	\node[right=1 of p3] (p4) {
	  \begin{tikzpicture}[polybox, mapstos]
  	\node[poly, dom] (p) {$i_B$\nodepart{two}$B$};
  	\node[poly, cod, right= of p.south, yshift=-1ex] (q) {$i_B$\nodepart{two}$B$};
  	\node[poly, cod, above=of q] (r) {$i_B$\nodepart{two}$B$};
  	\draw (p_pos) to[first] (q_pos);
  	\draw (q_dir) to[climb] (r_pos);
  	\draw (r_dir) to[last] (p_dir);
  \end{tikzpicture}  
	};
\end{tikzpicture}
\]

It remains to check that $(w,\epsilon,\delta)$ really is a comonoid, i.e.\ that the diagrams in \eqref{eqn.comonoid_diagrams} commute. We will check unitality only for $A$; it is easier for $B$.
\[
\begin{tikzpicture}[trees, sibling distance=5mm,	bend right=60]
	\node (1A) [red] {$\bullet$} 
  	child  {coordinate (1A1) \idchild}
    child {coordinate (1A2)};
  \node (2A) [right=1.5 of 1A, red] {$\bullet$} 
      child  {
        node [red] {$\bullet$} 
 		    child  {coordinate (2A1) \idchild}
      	child {coordinate (2A2)}
			\idchild
			}
      child {node [blue] {$\bullet$} 
      	child  {coordinate (2A3) \idchild}
			};
	\draw[|->, shorten <= 3pt, shorten >= 3pt] (1A) -- (2A);
	\draw[densely dotted, postaction={decorate}] (2A1) to (1A1);
	\draw[densely dotted, postaction={decorate}] (2A2) to (1A2);
	\draw[densely dotted, postaction={decorate}] (2A3) to (1A2);
	\node (3A) [right=1.5 of 2A, red] {$\bullet$}
		child {
			node {$\bullet$}
			child {coordinate (3A1)}
		\idchild
		}
		child {
			node {$\bullet$}
			child {coordinate (3A2)}
		};
	\draw[|->, shorten <= 3pt, shorten >= 3pt] (2A) -- (3A);
	\draw[densely dotted, postaction={decorate}] (3A1) to (2A1);
	\draw[densely dotted, postaction={decorate}] (3A2) to (2A3);
\end{tikzpicture}
\hspace{1in}
\begin{tikzpicture}[trees, sibling distance=5mm,	bend right=60]
	\node (1A) [red] {$\bullet$} 
  	child  {coordinate (1A1) \idchild}
    child {coordinate (1A2)};
  \node (2A) [right=1.5 of 1A, red] {$\bullet$} 
      child  {
        node [red] {$\bullet$} 
 		    child  {coordinate (2A1) \idchild}
      	child {coordinate (2A2)}
			\idchild
			}
      child {node [blue] {$\bullet$} 
      	child  {coordinate (2A3) \idchild}
			};
	\draw[|->, shorten <= 3pt, shorten >= 3pt] (1A) -- (2A);
	\draw[densely dotted, postaction={decorate}] (2A1) to (1A1);
	\draw[densely dotted, postaction={decorate}] (2A2) to (1A2);
	\draw[densely dotted, postaction={decorate}] (2A3) to (1A2);
	\node (3A) [right=1.5 of 2A] {$\bullet$}
		child {
        node [red] {$\bullet$} 
 		    child  {coordinate (3A1) \idchild}
      	child {coordinate (3A2)}
		};
	\draw[|->, shorten <= 3pt, shorten >= 3pt] (2A) -- (3A);
	\draw[densely dotted, postaction={decorate}] (3A1) to (2A1);
	\draw[densely dotted, postaction={decorate}] (3A2) to (2A2);
\end{tikzpicture}
\]
In both pictures, one can see that the composite map is the identity. We would do associativity here, but because the category $\cat{W}$ is so simple, associativity is guaranteed; this makes the pictures too trivial.
\end{example}


\begin{exercise}
Write out the data $(c,\epsilon,\delta)$ for the comonoid corresponding to the category 
\[\boxCD{exercisecolor}{$B\From{f}A\To{g}C$}\]
For this exercise, you are not being asked to check the unitality or associativity conditions.
\end{exercise}

\begin{exercise}\label{exc.linear_poly_comon}
Show that if $A$ is a set and $p\coloneqq A\yon$ is the associated linear polynomial, then there exists a unique comonoid structure on $p$.
\end{exercise}

%
%\begin{exercise}\label{ex.fleece}
%\begin{enumerate}
%	\item Use \cref{ex.const_to_const} to show that for any polynomial comonoid $(c,\epsilon,\delta)$, the polynomial $c$ is divisible by $\yon$.
%	\item Show that there exists a polynomial $\fl{c}$ and a vertical morphism $\phi_c\colon c\to \fl{c}$ such that the induced map $(\phi_c,\epsilon)\colon c\to \fl{c}\yon$ is an isomorphism, i.e.\ $\phi_c$ is a product projection.
%	\item Show that $\phi_c$ is an epimorphism using \cref{prop.epis_in_poly}.
%\qedhere
%\end{enumerate}
%\end{exercise}
%
%\begin{definition}\label{def.fleece}
%Suppose $\com{C}=(c,\epsilon,\delta)$ is a comonoid, and let $\phi_c\colon c\to \fl{c}$ be as in \cref{ex.fleece}. We refer to the polynomial $\fl{c}$ as the \emph{fleece} of $c$ and $\phi_c$ as the \emph{fleecing map}.
%
%If there exists a map $\fl{\delta}\colon \fl{c}\to \fl{c}\tri \fl{c}$ making the diagram
%\[
%\begin{tikzcd}
%	c\ar[r, "\delta"]\ar[d, "\phi_c"']&
%	c\tri c\ar[d, "\phi_c\tri\phi_c"]\\
%	\fl{c}\ar[r, "\fl{\delta}"']&
%	\fl{c}\tri \fl{c}
%\end{tikzcd}
%\]
%commute,%
%\footnote{Note that such a morphism $\fl{\delta}$ must be unique since $\phi_c$ is an epimorphism.}
%we say that $(\fl{c},\fl{\delta})$ is the \emph{fleece comagma} of $\com{C}$.
%\end{definition}
%
%By using just the fleece, we can leave off identity arrows, making things just that much easier to draw. (We call it ``fleece'' because to some extent we're cheating the comonoid of its identities, and also because we're taking just its wool, leaving the identity behind.)
%
%\begin{example}[Associativity]\label{ex.associativity_pics}
%Consider the non-category drawn here:
%\[
%\boxCD{examplecolor}{
%\begin{tikzcd}[ampersand replacement=\&]
%	A\ar[r, "f"]\ar[rrr, bend left, "i"]\ar[rrr, bend right, "j"]\&
%	B\ar[r, "g"]\&
%	C\ar[r, "h"]\&
%	D
%\end{tikzcd}
%\leavevmode\\\bigskip
%$(f\then g)\then h=i\qqand f\then(g\then h)=j$
%}
%\]
%We can see represent this in a polynomial $p$ with a map $\delta\colon p\to p\tri p$, and see that it is not associative. To show this it suffices to consider the fleece comagma $\fl{\delta}\colon \fl{p}\to \fl{p}\tri \fl{p}$; see \cref{def.fleece}, so that $\fl{p}\cong \yon^\4+\yon^\2+\yon+\1$. Let's rename $\fl{p}$ to an isomorphic polynomial with more names around:
%\[
%\fl{p}\coloneqq\{A\}\yon^{\{f,f\then g, i, j\}}+\{B\}\yon^{\{g,g\then h\}}+C\yon^{\{h\}}+\{D\}.
%\]
%Every symbol used there, excluding $\yon$, +, $\{$, and $\}$, but including ``$f$'' and ``$f\then g$'', etc., is just a variable name. Below is a picture of $\fl{p}$, where we use arrow lengths to help us remember which arrow is which: $f$, $g$, and $h$ are small, $f\then g$ and $g\then h$ are longer, and $i$ and $j$ are longest:
%\[
%\begin{tikzpicture}[rounded corners]
%\node[draw, "$\fl{p}$" above] {
%\begin{tikzpicture}[trees, sibling distance=1cm]
%	\node["\tiny $A$" below, red] (A) {$\bullet$}
%  	child[level distance=4mm] {coordinate (1)}
%		child[level distance=8mm] {coordinate (2)}
%		child[level distance=12mm] {coordinate (3)}
%		child[level distance=12mm] {coordinate (4)};
%%
%	\node["\tiny $B$" below, blue, right=3 of A] (B) {$\bullet$}
%		child[level distance=4mm] {coordinate (B1)}
%		child[level distance=8mm] {coordinate (B2)};
%%
%	\node["\tiny $C$" below, dgreen, right=2 of B] (C) {$\bullet$}
%		child[level distance=4mm] {coordinate (C1)};
%%
%	\node["\tiny $D$" below, right=1 of C] (D) {$\bullet$};
%	\begin{scope}[font=\scriptsize]
%  	\node[below left=1mm of 1] {$f$};
%  	\node[below left=1mm of 2] {$f\then g$};
%  	\node[below right=1mm of 3] {$i$};
%  	\node[below right=1mm of 4] {$j$};
%  	\node[below left=1mm of B1] {$g$};
%  	\node[below right=1mm of B2] {$g\then h$};
%  	\node[below left=1mm of C1] {$h$};
%	\end{scope}
%\end{tikzpicture}
%};
%\end{tikzpicture}
%\]
%Here's a picture of our map $\fl{\delta}\colon \fl{p}\to \fl{p}\tri \fl{p}$.
%\begin{equation}\label{eqn.delta_misc33}
%\begin{tikzpicture}[trees, bend right=60,
%level 1/.style={sibling distance=5mm},
%level 2/.style={sibling distance=2.5mm}]
%	\node [red] (A1) {$\bullet$}
%		child[level distance =4mm] {coordinate (A11)}
%		child[level distance =8mm] {coordinate (A12)}
%		child[level distance =12mm] {coordinate (A13)}
%		child[level distance =12mm] {coordinate (A14)};
%	\node [right=2.5 of A1, red] (A2) {$\bullet$}
%		child[level distance =4mm] {node [blue]{$\bullet$}
%			child[level distance=4mm] {coordinate (A21)}
%			child[level distance=8mm] {coordinate (A22)}
%		}
%		child[level distance =8mm] {node [dgreen] {$\bullet$}
%			child[level distance=4mm] {coordinate (A23)}
%		}
%		child[level distance =12mm] {node {$\bullet$}}
%		child[level distance =12mm] {node {$\bullet$}};			
%	\draw[|->, shorten <= 3pt, shorten >= 3pt] (A1) -- (A2);
%	\draw[densely dotted, postaction={decorate}] (A21) to (A12);
%	\draw[densely dotted, postaction={decorate}] (A22) to (A14);
%	\draw[densely dotted, postaction={decorate}] (A23) to (A13);
%%
%	\node [blue, right=1.5 of A2] (B1) {$\bullet$}
%		child[level distance=4mm] {coordinate (B11)}
%		child[level distance=8mm] {coordinate (B12)};
%	\node [blue, right=1.5 of B1] (B2) {$\bullet$}
%		child[level distance=4mm] {node[dgreen] {$\bullet$}
%			child {coordinate (B21)}
%		}
%		child[level distance=8mm] {node {$\bullet$}};
%	\draw[|->, shorten <= 3pt, shorten >= 3pt] (B1) -- (B2);
%	\draw[densely dotted, postaction={decorate}] (B21) to (B12);
%%
%	\node [dgreen, right=1.5 of B2] (C1) {$\bullet$}
%		child[level distance=4mm] {coordinate (C11)};
%	\node[right=1 of C1, dgreen] (C2) {$\bullet$}
%		child[level distance=4mm] {node {$\bullet$}
%	};
%	\draw[|->, shorten <= 3pt, shorten >= 3pt] (C1) -- (C2);
%%
%	\node [right=1 of C2] (D1) {$\bullet$};
%	\node [right=1 of D1] (D2) {$\bullet$};
%	\draw[|->, shorten <= 3pt, shorten >= 3pt] (D1) -- (D2);	
%\end{tikzpicture}
%\end{equation}
%One should check in the red position that $(f\then g)\then h$ is going to $i$ and that $f\then (g\then h)$ is going to $j$. This should cause a failure in the associativity of $\delta$ and hence of $\fl{\delta}$.%
%\footnote{Note that if $\fl{\delta}$ is not associative, then $\delta$ cannot be associative either; see \cref{ex.fleece_assoc}.}
%
%Now we draw $\delta\then(\delta\tri \fl{p})$ and $\delta\then(\fl{p}\tri\delta)$ and see that they disagree at the $A$ position. Here is $\delta\then(\delta\tri \fl{p})$ whose second map $\delta\tri \fl{p}$ does $\delta$ as in \eqref{eqn.delta_misc33} on the bottom layer and copies the top layer; to differentiate the intermediary $\delta$, which comes before the top layer, we use dashed lines:
%\[
%\begin{tikzpicture}[trees, bend right=60,
%level 1/.style={sibling distance=5mm},
%level 2/.style={sibling distance=2.5mm}]
%	\node [red] (A1) {$\bullet$}
%		child[level distance =4mm] {coordinate (A11)}
%		child[level distance =8mm] {coordinate (A12)}
%		child[level distance =12mm] {coordinate (A13)}
%		child[level distance =12mm] {coordinate (A14)};
%%
%	\node [right=2.5 of A1, red] (A2) {$\bullet$}
%		child[level distance =4mm] {node [blue]{$\bullet$}
%			child[level distance=4mm] {coordinate (A21)}
%			child[level distance=8mm] {coordinate (A22)}
%		}
%		child[level distance =8mm] {node [dgreen] (A23') {$\bullet$}
%			child[level distance=4mm] {coordinate (A23)}
%		}
%		child[level distance =12mm] {node (A24') {$\bullet$}}
%		child[level distance =12mm] {node (A25') {$\bullet$}};			
%%
%	\node [right=3.5 of A2, red] (A3) {$\bullet$}
%		child[level distance =4mm] {node [blue]{$\bullet$}
%			child[level distance=4mm] {node [dgreen] (A31') {$\bullet$}
%				child [level distance=4mm] {coordinate (A31)}}
%			child[level distance=8mm] {node (A32') {$\bullet$}}
%		}
%		child[level distance =8mm] {node [dgreen] {$\bullet$}
%			child[level distance=4mm] {node (A33') {$\bullet$}}
%		}
%		child[level distance =12mm] {node {$\bullet$}}
%		child[level distance =12mm] {node {$\bullet$}};			
%%
%	\draw[|->, shorten <= 3pt, shorten >= 3pt] (A1) -- (A2);
%	\draw[|->, shorten <= 3pt, shorten >= 3pt] (A2) -- (A3);
%	\draw[densely dotted, postaction={decorate}] (A21) to (A12);
%	\draw[densely dotted, postaction={decorate}] (A22) to (A14);
%	\draw[densely dotted, postaction={decorate}] (A23) to (A13);
%	\draw[densely dotted, bend right=20, dashed] (A31') to (A23');
%	\draw[densely dotted, bend right=20, dashed] (A32') to (A25');
%	\draw[densely dotted, bend right=20, dashed] (A33') to (A24');
%	\draw[densely dotted, postaction={decorate}] (A31) to (A23);
%\end{tikzpicture}
%\]
%We can see that the unique leaf of $\fl{p}\tri \fl{p}\tri \fl{p}$ is mapping to $i$. Now we draw $\delta\then(\fl{p}\tri\delta)$. Its second map $\fl{p}\tri\delta$ copies the bottom layer and does $\delta$ as in \eqref{eqn.delta_misc33} on the top layer; we have no need for dashed lines.
%\[
%\begin{tikzpicture}[trees, bend right=60,
%level 1/.style={sibling distance=5mm},
%level 2/.style={sibling distance=2.5mm}]
%	\node [red] (A1) {$\bullet$}
%		child[level distance =4mm] {coordinate (A11)}
%		child[level distance =8mm] {coordinate (A12)}
%		child[level distance =12mm] {coordinate (A13)}
%		child[level distance =12mm] {coordinate (A14)};
%%
%	\node [right=2.5 of A1, red] (A2) {$\bullet$}
%		child[level distance =4mm] {node [blue]{$\bullet$}
%			child[level distance=4mm] {coordinate (A21)}
%			child[level distance=8mm] {coordinate (A22)}
%		}
%		child[level distance =8mm] {node [dgreen]  {$\bullet$}
%			child[level distance=4mm] {coordinate (A23)}
%		}
%		child[level distance =12mm] {node {$\bullet$}}
%		child[level distance =12mm] {node {$\bullet$}};			
%%
%	\node [right=3.5 of A2, red] (A3) {$\bullet$}
%		child[level distance =4mm] {node [blue]{$\bullet$}
%			child[level distance=4mm] {node [dgreen] {$\bullet$}
%				child [level distance=4mm] {coordinate (A31)}}
%			child[level distance=8mm] {node {$\bullet$}}
%		}
%		child[level distance =8mm] {node [dgreen] {$\bullet$}
%			child[level distance=4mm] {node {$\bullet$}}
%		}
%		child[level distance =12mm] {node {$\bullet$}}
%		child[level distance =12mm] {node {$\bullet$}};			
%%
%	\draw[|->, shorten <= 3pt, shorten >= 3pt] (A1) -- (A2);
%	\draw[|->, shorten <= 3pt, shorten >= 3pt] (A2) -- (A3);
%	\draw[densely dotted, postaction={decorate}] (A21) to (A12);
%	\draw[densely dotted, postaction={decorate}] (A22) to (A14);
%	\draw[densely dotted, postaction={decorate}] (A23) to (A13);
%	\draw[densely dotted, postaction={decorate}] (A31) to (A22);
%\end{tikzpicture}
%\]
%We can see that the unique leaf of $\fl{p}\tri \fl{p}\tri \fl{p}$ is mapping to $j$.
%\end{example}
%
%\begin{exercise}\label{ex.fleece_assoc}
%Let $p$, $\delta$, $\fl{p}$, and $\fl{\delta}$ be as in \cref{ex.associativity_pics}.
%\begin{enumerate}
%	\item Redraw \cref{eqn.delta_misc33} using $\delta\colon p\to p\tri p$ in place of the fleeced version $\fl{\delta}\colon \fl p\to \fl p$ shown there.
%	\item Use \cref{ex.fleece,def.fleece} to show that if $\delta$ is associative then $\fl{\delta}$ must be too.
%\qedhere
%\end{enumerate}
%\end{exercise}
%
%\begin{exercise}
%In \cref{ex.associativity_pics} we have maps $\delta\then(\delta\tri c)$ and $\delta\then(c\tri\delta)$ $c\to c\tri c\tri c$. Which of these corresponds to composing from the left, e.g.\ $(f\then g)\then h$, and which corresponds to composing to the right, e.g.\ $f\then (g\then h)$?
%\end{exercise}
%

\begin{example}[The category of $A$-streams]\label{ex.streams_category}
For any set $A$, the set $A^\nn$ of $A$-streams
\[
s=(a_0\leadsto a_1\leadsto a_2\leadsto a_3\leadsto\cdots)
\]
are the objects of a category, where the set of morphisms emanating from each stream $s\in A^\nn$ is $\nn$. The identity on $s$ is given by $0$ and the composite of two morphisms is the sum of the corresponding natural numbers.

We will see this category again in \cref{ex.streams_cofree}.
\end{example}

\subsection{Comonoids in $\poly$ are categories}

It turns out that comonoids in $\poly$ are precisely categories. Strangely, however, the a morphism between comonoids is not a functor but something people are calling a \emph{cofunctor}.

\begin{definition}[Cofunctor]\label{def.cofunctor}
Let $\cat{C}$ be a category with object set $C_0$, morphism set $C_1$, $\dom,\cod\colon C_1\to C_0$ the domain and codomain,%
\footnote{We privilege the domain function $\dom\colon C_1\to C_0$ in the sense that an unnamed map $C_1\to C_0$ will be assumed to be $\dom$.}
 and similarly for $\cat{D}$. A \emph{cofunctor} $F\colon \cat{C}\coto \cat{D}$ consists of
\begin{enumerate}[itemsep=0pt]
  \item a function  $F\colon C_0\to D_0$ \emph{on objects} and
  \item a function $F^\sharp\colon C_0\times_{D_0}D_1\to C_1$ \emph{backwards on morphisms},
\end{enumerate}
satisfying the following conditions:
\begin{enumerate}[itemsep=0pt, label=\roman*.]
	\item $F^\sharp(c,\id_{F_0c})=\id_c$ for any $c\in C_0$;
	\item $F_0\cod F^\sharp(c,g)=\cod g$ for any $c\in C_0$ and $g\in D_{F_0(c)}$;
	\item $F^\sharp(\cod F^\sharp(c,g_1),g_2)\circ F^\sharp(c,g_1)=F^\sharp(c,g_1\then g_2)$ for composable arrows $g_1,g_2$ out of $F_0 c$.
\end{enumerate}
In other words, $F^\sharp$ preserves identities, codomains, and compositions.

We denote by $\smcat^\sharp$ the category of categories and cofunctors.
\end{definition}

The cofunctor laws can be written in commutative diagram form as follows:
\begin{gather*}
\begin{tikzcd}[column sep=15pt, ampersand replacement=\&]
  C_0\times_{D_0}D_0\ar[r, "\cong"]\ar[d, "\id_D"']\&
  C_0\ar[d, "\id_C"]\\
  C_0\times_{D_0}D_1\ar[r, "F^\sharp"']\&
  C_1\ar[ul, phantom, shift right=2pt, "\text{(i)}"]
\end{tikzcd}
\quad
\begin{tikzcd}[column sep=15pt, ampersand replacement=\&]
	C_0\times_{D_0}D_1\ar[r, "F^\sharp"]\ar[d, "\pi_2"']\&
	C_1\ar[r, "\cod"]\&
	C_0\ar[d, "F_0"]\\
	D_1\ar[rr, "\cod"']\ar[urr, phantom, "\text{(ii)}"]\&\&
	D_0
\end{tikzcd}
\\
\begin{tikzcd}[column sep=15pt, ampersand replacement=\&]
	C_0\times_{D_0}D_1\times_{D_0}D_1\ar[r, "\then_D"]\ar[d, "F^\sharp"']\&[-15pt]
	C_0\times_{D_0}D_1\ar[r, "F^\sharp"]\&
	C_1\\
	C_1\times_{D_0}D_1\ar[r, "\cong"']\&
	C_1\times_{C_0}C_0\times_{D_0}D_1\ar[r, "F^\sharp"']\ar[u, phantom, "\text{(iii)}"]\&
	C_1\times_{C_0}C_1\ar[u, "\then_C"']
\end{tikzcd}
\end{gather*}

\begin{example}[Systems of ODEs]
A system of ordinary differentrial equations (ODEs) in $n$ variables, e.g.
\begin{align*}
    \dot{x}_1 &= f_1(x_1, \ldots, x_n) \\
    \dot{x}_2 &= f_2(x_1, \ldots, x_n) \\
    & \; \; \; \vdots \\
    \dot{x}_n &= f_n(x_1, \ldots, x_n)
\end{align*}
can be understood as a vector field on $\rr^n$. Usually, we are interested in integrating this vector field to get flow lines, or integral curves. In other words, for each point $x = (x_1, \ldots, x_n)$ and each amount of time $t \in \rr$, we can go forward from $x$ for time $t$ and arrive at a new point $x^{+t}$. These satisfy the equations
\begin{equation} \label{eqn.cofunctor_ode}
    x^{+0} = x \qqand x^{+t_1+t_2} = (x^{+t_1})^{+t_2}. 
\end{equation}
Let's call such things \emph{dynamical systems} with time domain $(T, 0, +)$; above, we used $T = \rr$, but any monoid will do.

Dynamical systems in the above sense are cofunctors $F \colon \rr^n \yon^{\rr^n} \cof \yon^T$.
In order to say this, we first need to say how both $\cat{C} := \rr^n \yon^{\rr^n}$ and $\yon^T$ are being considered as categories.
The category $\cat{C}$ has objects $\rr^n$, and for each object $x \in \rr^n$ and outgoing arrow $v \in \rr^n$, the codomain of $v$ is $x + v$; in other words, $v$ is a vector emanating from $x$.
The identity is $v = 0$, and composition is given by addition.
The category $\yon^T$ is the monoid $T$ considered as a category with one object, $\bullet$.

The cofunctor assigns to every object $x \in \rr^n$ the unique object $F(x) = \bullet$, and to each element $t \in T$ the morphism $F^\sharp(x, t) = x^{+t} - x \in \rr^n$, which can be interpreted as a vector emanating from $x$.
Its codomain is $\cod F^\sharp(x, t) = x^{+t}$, and we will see that \eqref{eqn.cofunctor_ode} ensures the cofunctoriality properties.

The codomain law ii is vacuously true, since $\yon^T$ only has one object.
Law i follows because $F^\sharp(x, 0) = x^{+0} - x = 0$, and law iii follows as
\[
    F^\sharp(x^{+t_1}, t_2) + F^\sharp(x, t_1) = (x^{+t_1})^{+t_2} - x^{+t_1} + x^{+t_1} - x = x^{+t_1 + t_2} - x = F^\sharp(x, t_1+t_2).
\]
\end{example}

\begin{theorem}[Ahman-Uustalu]\label{thm.ahman_uustalu}
There is an equivalence of categories
\[
\Cat{Comon}(\poly)\cong\smcat^\sharp.
\]
\end{theorem}
\begin{proof}
This will be proved as \cref{prop.copointing,thm.cofree}.
\end{proof}

Our first goal is to understand how one translates between categories $\cat{C}$ and comonoids $\com{C}=(\ema{c},\epsilon,\delta)$ in $\poly$. The idea is pretty simple: the objects of $\cat{C}$ are the positions of $\ema{c}$
\[
\Ob(\cat{C})\cong\ema{c}(\1)
\]
and for each such object $i$, the morphisms $\{f\colon i\to j\mid j\in\Ob(\cat{C})\}$ emanating from $i$ in $\cat{C}$ are the directions $\ema{c}[i]$ there.

\begin{definition}
Let $\cat{C}$ be a category. The \emph{emanation polynomial for $\cat{C}$} is the polynomial
\[
\ema{c}\coloneqq\sum_{i\in\Ob(\cat{C})}\yon^{\sum_{j\in\Ob(\cat{C})}\cat{C}(i,j)}
\]
\end{definition}

\begin{exercise}
What is the emanation polynomial for each of the following categories?
\begin{enumerate}
	\item \boxCD{exercisecolor}{$A\Too{f}B$}?
	\item \boxCD{exercisecolor}{$B\From{f}A\To{g}C$}?
	\item The empty category?
	\item The monoid $(\nn,0,+)$?
	\item A monoid $(M, e, *)$?
	\item The poset $(\nn,\leq)$?
	\item The poset $(\nn,\geq)$?
\qedhere
\end{enumerate}
\end{exercise}

A category $\cat{C}$ is more than its emanation polynomial $\ema{c}$, and a comonoid $(\ema{c},\epsilon,\delta)$ in $\poly$ is more than its carrier polynomial $\ema{c}$. The identities of $\cat{C}$ are all captured by the counit $\epsilon\colon\ema{c}\to\yon$ and the codomain and composition information of $\cat{C}$ are all captured by the comultiplication map $\delta\colon\ema{c}\to\ema{c}\tri\ema{c}$. Our goal is to make this clear so that we can justly proclaim:

\slogan{Comonoids in $\poly$ are precisely categories!}


We want to understand how the counit $\epsilon$ and comultiplication $\delta$ in a comonoid $\com{C}=(\ema{c},\epsilon,\delta)$ relate to identities, codomains, and composites in a category. We first use our work in \cref{subsec.working_with_composites} to get a better handle on $\epsilon$ and $\delta$. For example, since $\epsilon\colon\ema{c}\to\yon$ maps to the empty composite, we know by \eqref{eqn.map_to_0ary_composite} that it is of the form
\[
 \begin{tikzpicture}[polybox, mapstos]
  	\node[poly, dom, "$\ema{c}$" left] (c) {$\epsilon^\sharp(i)$\nodepart{two}$i$};
  	\draw (c_pos) to[climb'] node[right] {$\epsilon^\sharp$} (c_dir);
	\end{tikzpicture}
\]
i.e.\ for every $i\in \ema{c}(\1)$, a choice of element $\epsilon^\sharp(i)\in \ema{c}[i]$. Rather than call it $\epsilon^\sharp$, we will refer to this map as $\idy$. Similarly, we know by \eqref{eqn.map_to_2ary_composite} that $\delta$ is of the form
\[
  \begin{tikzpicture}[polybox, tos]
  	\node[poly, dom] (yX) {};
  	\node[poly, cod, right=1.8 of yX.south, yshift=-1ex] (p) {};
  	\node[poly, above=of p] (p') {};
  	\draw (yX_pos) to[first] node[below] {$\delta_1$}(p_pos);
  	\draw (p_dir) to[climb] node[right] {$\delta_2$} (p'_pos);
  	\draw (p'_dir) to[last] node[above left] {$\delta^\sharp$} (yX_dir);
  \end{tikzpicture}
 \]
We've said that this secretly holds information about the codomains and composites for a category structure on $\ema{c}$. How does that work? We will soon find that $\delta_1$ is forced to be an identity, that $\delta_2$ holds codomain information, and that $\delta^\sharp$ holds composite information. So we will use that notation here
\[
  \begin{tikzpicture}[polybox, tos]
  	\node[poly, dom] (yX) {};
  	\node[poly, cod, right=1.8 of yX.south, yshift=-1ex] (p) {};
  	\node[poly, cod, above=of p] (p') {};
  	\draw (yX_pos) to[first] node[below] {$\delta_1$}(p_pos);
  	\draw (p_dir) to[climb] node[right] {$\cod$} (p'_pos);
  	\draw (p'_dir) to[last] node[above, sloped] {$\comp$} (yX_dir);
  \end{tikzpicture}
 \]
and our goal now is to see that the $\cod$ map really has something to do with codomains and that the $\comp$ map really has something to do with composites, as advertised. What makes these true are the unitality and associativity equations required for $(\ema{c},\epsilon,\delta)$ to be a comonoid; see \cref{def.comonoid}.

To get started, we consider the first unitality equation from \eqref{eqn.comonoid_diagrams}:
\[
\begin{tikzpicture}
	\node (1) {
  \begin{tikzpicture}[polybox, tos]
  	\node[poly, dom] (yX) {};
  	\node[poly, cod, right=1.8 of yX.south, yshift=-1ex] (p) {};
  	\node[poly, above=of p] (p') {};
  	\node[poly, cod, right=of p] (q) {};
  	\node[poly, cod, identity, above=of q] (q') {};
  	\draw (p_pos) -- (q_pos);
  	\draw (q_dir) -- (p_dir);
  	\draw (p'_pos) -- (q'_pos);
  	\draw (q'_dir) -- node[above] {$\idy$} (p'_dir);
  	\draw (yX_pos) to[first] node[below] {$\delta_1$}(p_pos);
  	\draw (p_dir) to[climb] node[right] {$\cod$} (p'_pos);
  	\draw (p'_dir) to[last] node[above, sloped] {$\comp$} (yX_dir);
  \end{tikzpicture}
	};
	\node[right=1.6 of 1] (2) {
  \begin{tikzpicture}[polybox, tos]
  	\node[poly, dom] (yX) {};
  	\node[poly, cod, right=2.5 of yX.south, yshift=-1ex] (p) {};
  	\node[poly, above left=.5 of p] (p') {};
  	\draw (yX_pos) to[first] node[below] {$\delta_1$}(p_pos);
  	\draw (p_dir) to[climb] node[right] {$\cod$} (p'_pos);
  	\draw (p'_dir) to[last] node[above, sloped] {$\comp$} (yX_dir);
		\draw (p'_pos) to[climb'] node[right] {$\idy$} (p'_dir);
  \end{tikzpicture}
	};
	\node[right=1 of 2] (3) {
  \begin{tikzpicture}[polybox, tos]
  	\node[poly, dom] (c) {};
  	\node[poly, cod, right=of c] (c') {};
  	\draw[double] (c_pos) -- (c'_pos);
  	\draw[double] (c'_dir) -- (c_dir);
	\end{tikzpicture}
	};
	\node at ($(1.east)!.5!(2.west)$) {=};
	\node at ($(2.east)!.5!(3.west)$) {=};
\end{tikzpicture}
\]

Let's add some arbitrary fillers $i\in \ema{c}(\1)$ and $d\in \ema{c}[i]$ to the open slots, and hence obtain an equation:
\[
\begin{tikzpicture}
	\node (2) {
  \begin{tikzpicture}[polybox, tos]
  	\node[poly, dom] (yX) {$d\then\idy(\cod(d))$\nodepart{two}$i$};
  	\node[poly, cod, right=5 of yX.south, yshift=-1ex] (p) {$d$\nodepart{two}$\delta_1(i)$};
  	\node[poly, above left=1 and 0 of p] (p') {$\idy(\cod(d))$\nodepart{two}$\cod(d)$};
  	\draw (yX_pos) to[first] node[below] {$\delta_1$}(p_pos);
  	\draw (p_dir) to[climb] node[right] {$\cod$} (p'_pos);
  	\draw (p'_dir) to[last] node[above, sloped] {$\comp$} (yX_dir);
		\draw (p'_pos) to[climb'] node[right] {$\idy$} (p'_dir);
  \end{tikzpicture}
	};
	\node[right=2 of 2] (3) {
  \begin{tikzpicture}[polybox, tos]
  	\node[poly, dom] (c) {$d$\nodepart{two}$i$};
  	\node[poly, cod, right=of c] (c') {$d$\nodepart{two}$i$};
  	\draw[double] (c_pos) -- (c'_pos);
  	\draw[double] (c'_dir) -- (c_dir);
	\end{tikzpicture}
	};
	\node at ($(2.east)!.5!(3.west)$) {=};
\end{tikzpicture}
\]
First it's saying that $\delta_1(i)=i$. This is great news; it means we can forget about $\delta_1$, just as we said earlier. Second it's saying that $d\then\idy(\cod(d))=d$. Unpacking, this means that composing a morphism $d$ with the identity morphism on its codomain returns $d$. It's neat to watch the comonoid laws declaring the standard laws of categories. It's like meeting a like-minded toad; we never knew toads could be like-minded, but the phenomena don't lie.

Before moving on, we redraw $\delta\colon c\to c\tri c$ with the information-lacking $\delta_1$ (which the first unitality equation said was always identity) and replace it with a double arrow:
\begin{equation}\label{eqn.cod_comp}
  \begin{tikzpicture}[polybox, tos]
  	\node[poly, dom] (yX) {};
  	\node[poly, right=1.8 of yX.south, yshift=-1ex] (p) {};
  	\node[poly, cod, above=of p] (p') {};
  	\draw[double] (yX_pos) to[first] (p_pos);
  	\draw (p_dir) to[climb] node[right] {$\cod$} (p'_pos);
  	\draw (p'_dir) to[last] node[above, sloped] {$\comp$} (yX_dir);
  \end{tikzpicture}
\end{equation}

Now we can write the other unitality equation.
\[
\begin{tikzpicture}
	\node (1) {
  \begin{tikzpicture}[polybox, tos]
  	\node[poly, dom] (yX) {};
  	\node[poly, right=1.8 of yX.south, yshift=-1ex] (p) {};
  	\node[poly, above=of p] (p') {};
  	\node[poly, cod, identity, right=of p] (q) {};
  	\node[poly, cod, above=of q] (q') {};
  	\draw (p_pos) -- (q_pos);
  	\draw (q_dir) -- node[above] {$\idy$} (p_dir);
  	\draw (p'_pos) -- (q'_pos);
  	\draw (q'_dir) -- (p'_dir);
  	\draw[double] (yX_pos) to[first] (p_pos);
  	\draw (p_dir) to[climb] node[right] {$\cod$} (p'_pos);
  	\draw (p'_dir) to[last] node[above, sloped] {$\comp$} (yX_dir);
  \end{tikzpicture}
	};
	\node[right=1.6 of 1] (2) {
  \begin{tikzpicture}[polybox, tos]
  	\node[poly, dom] (yX) {};
  	\node[poly, right=1.8 of yX.south, yshift=-1ex] (p) {};
  	\node[poly, cod, above=of p] (p') {};
  	\draw[double] (yX_pos) to[first] (p_pos);
  	\draw (p_dir) to[climb] node[right] {$\cod$} (p'_pos);
  	\draw (p'_dir) to[last] node[above, sloped] {$\comp$} (yX_dir);
		\draw (p_pos) to[climb'] node[right] {$\idy$} (p_dir);
  \end{tikzpicture}
	};
	\node[right=1.6 of 2] (3) {
  \begin{tikzpicture}[polybox, tos]
  	\node[poly, dom] (c) {};
  	\node[poly, cod, right=of c] (c') {};
  	\draw[double] (c_pos) -- (c'_pos);
  	\draw[double] (c'_dir) -- (c_dir);
	\end{tikzpicture}
	};
	\node at ($(1.east)!.5!(2.west)$) {=};
	\node at ($(2.east)!.5!(3.west)$) {=};
\end{tikzpicture}
\]
Let's add some arbitrary fillers $i\in c(\1)$ and $d\in c[i]$ to get some equations:
\[
\begin{tikzpicture}
	\node (2) {
  \begin{tikzpicture}[polybox, tos]
  	\node[poly, dom] (yX) {$\idy(i)\then d$\nodepart{two}$i$};
  	\node[poly, right=3 of yX.south, yshift=-1ex] (p) {$\idy(i)$\nodepart{two}$i$};
  	\node[poly, cod, above right=1 and 0 of p] (p') {$d$\nodepart{two}$\cod(\idy(i))$};
  	\draw[double] (yX_pos) to[first] (p_pos);
  	\draw (p_dir) to[climb] node[right] {$\cod$} (p'_pos);
  	\draw (p'_dir) to[last] node[above, sloped] {$\comp$} (yX_dir);
		\draw (p_pos) to[climb'] node[right] {$\idy$} (p_dir);
  \end{tikzpicture}
	};
	\node[right=2 of 2] (3) {
  \begin{tikzpicture}[polybox, tos]
  	\node[poly, dom] (c) {$d$\nodepart{two}$i$};
  	\node[poly, cod, right=of c] (c') {$d$\nodepart{two}$i$};
  	\draw[double] (c_pos) -- (c'_pos);
  	\draw[double] (c'_dir) -- (c_dir);
	\end{tikzpicture}
	};
	\node at ($(2.east)!.5!(3.west)$) {=};
\end{tikzpicture}
%\begin{tikzpicture}
%\node (2) {
%  \begin{tikzpicture}[polybox, tos]
%  	\node[poly, dom] (c) {$\idy(i)\then d$\nodepart{two}$i$};
%  	\node[poly, right=1.2 of c] (c1) {$\idy(i)$\nodepart{two}$i$};
%  	\node[poly, cod, above right=.3 and .2 of c1] (c2) {$d$\nodepart{two}$\cod(\idy(i))$};
%  	\draw[double] (c_pos) -- (c1_pos);
%  	\draw (c1_dir) to[climb] node[right] {cod} (c2_pos);
%  	\draw (c2_dir) to[last] node[above] {com} (c_dir);
%  	\draw (c1_pos) to[out=0, in=0, looseness=2] node[right] {idy} (c1_dir);
%	\end{tikzpicture}
%	};
%	\node[right=2 of 2] (3) {
%  \begin{tikzpicture}[polybox, tos]
%  	\node[poly, dom] (c) {$d$\nodepart{two}$i$};
%  	\node[poly, cod, right=of c] (c') {$d$\nodepart{two}$i$};
%  	\draw[double] (c_pos) -- (c'_pos);
%  	\draw[double] (c'_dir) -- (c_dir);
%	\end{tikzpicture}
%	};
%	\node at ($(2.east)!.5!(3.west)$) {=};
%\end{tikzpicture}
\]
Ah, it's saying that it wants $\cod(\idy(i))=i$, which makes sense---the codomain of the identity on $i$ should be $i$---and that it wants $\idy(i)\then d=d$, i.e.\ that composing the identity on $i$ with $d$ should return $d$. We couldn't have said it better ourselves; thanks like-minded toad!

Finally we draw the associativity equation.
\[
\begin{tikzpicture}
	\node (p1) {
  \begin{tikzpicture}[polybox, tos, font=\tiny]
  	\node[poly, dom, "$c$" left] (m) {};
  	\node[poly, right= of m.south, yshift=-1ex, "$c$" below] (D) {};
  	\node[poly, above=of D, "$c$" above] (mm) {};
  	\node[poly, cod, right= of D.south, yshift=-1ex, "$c$" right] (DD) {};
  	\node[poly, cod, above=of DD, "$c$" right] (mmm) {};
  	\node[poly, cod, above=of mmm, "$c$" right] (C) {};
%
		\draw[double] (m_pos) to[first] (D_pos);
		\draw (D_dir) to[climb] node[right] {$\cod$} (mm_pos);
		\draw (mm_dir) to[last] node[above, sloped] {$\comp$} (m_dir);
		\draw[double] (D_pos) to[first] (DD_pos);
		\draw[double] (DD_dir) to[last] (D_dir);
		\draw[double] (mm_pos) to[first] (mmm_pos);
		\draw (mmm_dir) to[climb] node[right] {$\cod$} (C_pos);
		\draw (C_dir) to[last] node[above, sloped] {$\comp$} (mm_dir);
	\end{tikzpicture}
	};
%
	\node (p2) [right=of p1] {
  \begin{tikzpicture}[polybox, tos, font=\tiny]
  	\node[poly, dom, "$c$" left] (m') {};
  	\node[poly, right= of m'.south, yshift=-1ex, "$c$" below] (mm') {};
  	\node[poly, above=of mm', "$c$" above] (C') {};
  	\node[poly, cod, right= of mm'.south, yshift=-1ex, "$c$" right] (D') {};
  	\node[poly, cod, above=of D', "$c$" right] (mmm') {};
  	\node[poly, cod, above=of mmm, "$c$" right] (CC') {};
%
		\draw[double] (m'_pos) to[first] (mm'_pos);
		\draw (mm'_dir) to[climb] node[right] {$\cod$} (C'_pos);
		\draw (C'_dir) to[last] node[above, sloped] {$\comp$} (m'_dir);
		\draw[double] (mm'_pos) to[first] (D'_pos);
		\draw (D'_dir) to[climb] node[right] {$\cod$} (mmm'_pos);
		\draw (mmm'_dir) to[last] node[above, sloped] {$\comp$} (mm'_dir);
		\draw[double] (C'_pos) to[first] (CC'_pos);
		\draw[double] (CC'_dir) to[last] (C'_dir);
	\end{tikzpicture}
	};	
	\node at ($(p1.south)!.5!(p2.north)$) {$=$};
\end{tikzpicture}
\]
Let's fill it in with $i\in c(\1)$ and a sequence $i\To{m}\To{m'}\To{m''}$ of emanating morphisms:
\[
\begin{tikzpicture}
	\node (p1) {
  \begin{tikzpicture}[polybox, mapstos, font=\tiny]
  	\node[poly, dom] (m) {$m\then(m'\then m'')$\nodepart{two}$i$};
  	\node[poly, right=3 of m.south, yshift=-1ex] (D) {$m$\nodepart{two}$i$};
  	\node[poly, above=of D] (mm) {$m'\then m''$\nodepart{two}$\cod(m)$};
  	\node[poly, cod, right=2.5 of D.south, yshift=-1ex] (DD) {$m$\nodepart{two}$i$};
  	\node[poly, cod, above=of DD] (mmm) {$m'$\nodepart{two}$\cod(m)$};
  	\node[poly, cod, above=of mmm] (C) {$m''$\nodepart{two}$\cod(m')$};
%
		\draw[double] (m_pos) to[first] (D_pos);
		\draw (D_dir) to[climb] (mm_pos);
		\draw (mm_dir) to[last]  (m_dir);
		\draw[double] (D_pos) to[first] (DD_pos);
		\draw[double] (DD_dir) to[last] (D_dir);
		\draw[double] (mm_pos) to[first] (mmm_pos);
		\draw (mmm_dir) to[climb] (C_pos);
		\draw (C_dir) to[last] (mm_dir);
	\end{tikzpicture}
	};
%
	\node (p2) [below=of p1] {
  \begin{tikzpicture}[polybox, mapstos, font=\tiny]
  	\node[poly, dom] (m') {$(m\then m')\then m''$\nodepart{two}$i$};
  	\node[poly, right= 3 of m'.south, yshift=-1ex] (mm') {$m\then m'$\nodepart{two}$i$};
  	\node[poly, above=of mm'] (C') {$m''$\nodepart{two}$\cod(m\then m')$};
  	\node[poly, cod, right= 2.5 of mm'.south, yshift=-1ex] (D') {$m$\nodepart{two}$i$};
  	\node[poly, cod, above=of D'] (mmm') {$m'$\nodepart{two}$\cod(m)$};
  	\node[poly, cod, above=of mmm'] (CC') {$m''$\nodepart{two}$\cod(m\then m')$};
%
		\draw[double] (m'_pos) to[first] (mm'_pos);
		\draw (mm'_dir) to[climb] (C'_pos);
		\draw (C'_dir) to[last] (m'_dir);
		\draw[double] (mm'_pos) to[first] (D'_pos);
		\draw (D'_dir) to[climb] (mmm'_pos);
		\draw (mmm'_dir) to[last] (mm'_dir);
		\draw[double] (C'_pos) to[first] (CC'_pos);
		\draw[double] (CC'_dir) to[last] (C'_dir);
	\end{tikzpicture}
	};	
	\node at ($(p1.south)!.5!(p2.north)$) {$=$};
\end{tikzpicture}
\]
Ah, it's saying that it wants $\cod(m')=\cod(m\then m')$; well yeah, that's how codomains should work. And it wants $m\then(m'\then m'')=(m\then m')\then m''$, classic associativity. Amazing; thanks again toad!

We've seen that all of the data and equations of categories are embedded, though in a very non-standard way, in the data and equations of polynomial comonoids. 

\begin{exercise}
Let $\cat{C}$ be a category, $\ema{c}$ its emanation polynomial, and $i\in\Ob(\cat{C})$ an object. This exercise is for people who know the definition of the coslice category $i/\cat{C}$ of objects under $i$. Is it true that there is an isomorphism
\[\Ob(c/\cat{C})i\cong^?\ema{c}[i]\]
If so, describe it; if not, give a counterexample.
\end{exercise}

\subsection{Examples showing the correspondence between comonoids and categories}

\begin{example}[Monoids]\label{ex.monoids}
Let $(M,e,*)$ be a monoid. Then we can construct a comonoid structure on the representable $\yon^M$. A morphism $\yon^M\to\yon$ can be identified with an element of $M$; under that identification we take $\epsilon\coloneqq e$. Similarly, $\yon^M\tri\yon^M\cong\yon^{M^2}$ and a morphism $\yon^M\to\yon^{M^2}$ can be identified with a function $M^2\to M$; under that identification we take $\delta\coloneqq *$.
\end{example}

\begin{exercise}
Finish \cref{ex.monoids} by showing that if $(M,e,*)$ satisfies the unitality and associativity requirements of a monoid in $(\smset,\1,\times)$ then $(\yon^M,\epsilon,\delta)$ satisfies the unitality and associativity requirements of a comonoid in $(\poly,\yon,\tri)$.
\end{exercise}

\begin{example}[Cyclic lists]
For any $n\in\nn$, consider the monoid (group) $\zz/n$. As a functor $c_n\coloneqq\yon^{\zz/n}$ sends a set $X$ to the set of length-$n$ tuples in $X$. But the comonoid structure lets us think of these as cyclic lists. Indeed, $\epsilon\colon c_n\to\yon$ allows us to pick out the ``current'' element via the map $\epsilon\tri X\colon c_n\tri X\to X$, and $\delta$ lets us move around the list.

We will see later that comonoids are closed under coproducts, so $\sum_{n\in\nn}c_n$ is also a comonoid.
\end{example}

\begin{example}[What category is $S\yon^S$?]
The first comonoid we introduced, back in \cref{ex.state_comonad_1} was $\com{S}=(p,\epsilon,\delta)$, where $p=S\yon^S$ for some set $S$. Now we know that comonoids correspond to categories. So what category $\cat{S}$ corresponds to $\com{S}$?

By the work above, we know that $\cat{S}$ has object set $S=p(\1)$, and that for every object $s\in S$ there are $S$-many emanating morphisms, though we don't yet know their codomains nor the composition formula. 

To calculate the codomains and compositions we examine the map $\delta\colon p\to p\tri p$, which was given set-theoretically in \eqref{eqn.state_comonoid_eps_del} and in terms of poly-boxes in \eqref{eqn.state_comonoid_eps_del2}. We repeat it here for your convenience:
\[
\begin{tikzpicture}
	\node (id) {
  \begin{tikzpicture}[polybox, mapstos]
  	\node[poly, dom, "$S\yon^S$" left] (S) {$s$\nodepart{two}$s$};
  	\node[poly, identity, right=of S, "$\yon$" right] (y) {\pphantom{s}{s}};
  	\draw (S_pos) to[first] (y_pos);
  	\draw (y_dir) to[last] (S_dir);
		\node at ($(S)!.5!(y)$) {$\epsilon$};
  \end{tikzpicture}
  };
  \node[right=of id] (co) {
  \begin{tikzpicture}[polybox, mapstos]
  	\node[poly, dom] (p) {$s_2$\nodepart{two}$s$};
  	\node[poly, cod, right=2 of p.south, yshift=-1ex] (q) {$s_1$\nodepart{two}$s$};
  	\node[poly, cod, above=of q] (r) {$s_2$\nodepart{two}$s_1$};
  	\draw[double] (p_pos) to[first] (q_pos);
  	\draw (q_dir) to[climb] node[right] {$\cod$} (r_pos);
  	\draw (r_dir) to[last] node[above, sloped] {$\comp$} (p_dir);
  \end{tikzpicture}  
  };
\end{tikzpicture}
\]
The $\epsilon$ map is saying that the identity on the object $s$ is the emanating morphism $s$. Remember that both the set of objects and the set of morphisms emanating from any given object are $S$. The map $\cod=\delta_2$ is telling us that the codomain of the morphism $s_1$ emanating from $s$ is the object $s_1$, and that the composite of $s_1$ and $s_2$ is $s_1\then s_2=s_2$. 

What this all means is that $\cat{S}$ is the category with $S$-many objects and a unique morphism $s\to s'$ for any $s,s'\in S$. Here are pictures for $S=\3$ and $S=\1\5$, with all maps (even identities) drawn:
\[
\begin{tikzpicture}
\def\n{3}% how many nodes
\def\size{2cm}
\node[circle,minimum size=\size] (b) {};
\foreach\x in{1,...,\n}{
  \node[minimum size=0.75cm,draw,circle] (n-\x) at (b.{360/\n*\x}){\x};
}
\foreach\x in{1,...,\n}{
  \foreach\y in{1,...,\n}{
    \ifnum\x=\y\draw[->] (n-\x) to [in=360/\n*\x-15,out=360/\n*\x+15,loop] ();\relax\else
      \draw (n-\x) edge[->,bend right=3] (n-\y);
    \fi
  }
}
\def\n{15}% how many nodes
\def\size{4cm}
\node[circle,minimum size=\size, right=4 of b] (b) {};
\foreach\x in{1,...,\n}{
  \node[minimum size=0.75cm,draw,circle] (n-\x) at (b.{360/\n*\x}){\x};
}
\foreach\x in{1,...,\n}{
  \foreach\y in{1,...,\n}{
    \ifnum\x=\y\draw[->] (n-\x) to [in=360/\n*\x-15,out=360/\n*\x+15,loop] ();\relax\else
      \draw (n-\x) edge[->,bend right=3] (n-\y);
    \fi
  }
}
% Source: Asterix: https://tex.stackexchange.com/questions/390647/understanding-complete-graph-example-in-tikz
\end{tikzpicture}
\]
Some people would call this the contractible groupoid, or the terminal category with $S$-elements, or the unique category whose underlying graph is complete on $S$ vertices. The one that's \emph{least} good for us will be ``terminal'' category, because as we'll see, we're going to be interested in different sorts of morphisms between categories than the usual ones, namely cofunctors rather than functors, and $\cat{S}$ is not terminal for cofunctors.  

Anyway, to avoid confusion, we'll refer to $\cat{S}$ as the \emph{state category on $S$}, because we will use these to think about states of dynamical systems, and also because the state comonad in functional programming is $S\yon^S$.
\end{example}

\begin{exercise}
We showed in \cref{exc.linear_poly_comon} that for any set $A$, the linear polynomial $p\coloneqq A\yon$ has a unique comonoid structure. What category does it correspond to?
\end{exercise}

\begin{definition}
Let $\cat{C}$ be a category and $c\in\Ob(\cat{C})$ an object. The \emph{degree of $c$}, denoted $\deg(c)$ is the set of arrows in $\cat{C}$ that emanate from $c$.

If $\deg(c)\cong \1$, we say that $c$ is \emph{linear} and if $\deg(c)\cong\ord{n}$ for $n\in\nn$, we say $c$ has \emph{degree $n$}.
\end{definition}

\begin{exercise}
\begin{enumerate}
	\item If every object in $\cat{C}$ is linear, what does it mean about $\cat{C}$?
	\item Is it possible for an object in $\cat{C}$ to have degree $0$?
	\item Find a category that has an object of degree $\nn$.
	\item How many categories are there that have just one linear and one quadradic (degree 2) object?
	\item Is the above the same as asking how many comonad structures on $\yon^\2+\yon$ there are?
\end{enumerate}
\end{exercise}

\begin{exercise}\label{ex.star_shaped}
\begin{enumerate}
	\item Find a category structure for the polynomial $\yon^{\ord{n}+1}+\ord{n}\yon$.
	\item Would you call your category ``star-shaped''?
\qedhere
\end{enumerate}
\end{exercise}

\begin{exercise}
Let $S$ be a set. Is there any comonoid structure on $S\yon^S$ other than that of the state category?
\end{exercise}


%---- Subsection ----%
\subsection{Morphisms of comonoids are cofunctors}

Our next goal is to understand morphisms $\com{C}\to\com{D}$ between comonoids and what they look like as maps between categories $\cat{C}\to\cat{D}$.


\slogan{Cofunctors $F$ are forward on objects, and backwards on morphisms. It's good to remember: Codomains are objects, so $F$ preserves them going forwards; identities and composites are morphisms, so $F$ preserves them going backwards.}
 
Let's begin with a definition.

\begin{definition}[Morphisms of comonoids]\label{def.morphism_comonoids}
Let $\com{C}\coloneqq(c,\epsilon,\delta)$ and $\com{C}'\coloneqq(c',\epsilon',\delta')$ be polynomial comonoids as in \cref{def.comonoid}. A \emph{morphism} $\com{C}\to\com{C}'$ consists of a morphism $f\colon c\to c'$ of polynomials that commutes with the structure maps:
\begin{equation}\label{eqn.morphism_comonoids}
\begin{tikzcd}
  c\ar[r, "f"]\ar[d, "\epsilon"']&
	c'\ar[d, "\epsilon'"]\\
	\yon\ar[r, equal]&
	\yon
\end{tikzcd}
\hspace{.5in}
\begin{tikzcd}
  c\ar[r, "f"]\ar[d, "\delta"']&
	c'\ar[d, "\delta'"]\\
	c\tri c\ar[r, "f\tri f"']&
	c'\tri c'
\end{tikzcd}
\end{equation}
\end{definition}

Let's see the two laws of comonoid morphisms using poly-boxes. First the counit law:
\begin{equation}\label{eqn.unit_law_draw}
\begin{tikzpicture}
	\node (id1) {
	\begin{tikzpicture}[polybox, tos]
		\node[poly, dom, blue, "$c$" above] (p) {};
		\node[poly, dgreen, right=1 of p, "$c'$" above] (q) {};
		\draw (p_pos) to[first] (q_pos);
		\draw (q_dir) to[last] (p_dir);
		\draw[dgreen] (q_pos) to[climb'] node[right] {$\idy$} (q_dir);
		\node at ($(p.east)!.5!(q.west)$) {$f$};
	\end{tikzpicture}
	};
	\node[right=of id1] (id2) {
	\begin{tikzpicture}[polybox, tos]
		\node[poly, dom, blue, "$c\vphantom{c'}$" above] (p) {};
		\draw[blue] (p_pos) to[climb'] node[right] {$\idy$} (p_dir);
	\end{tikzpicture}	
	};
	\node at ($(id1.east)!.5!(id2.west)-(0,6pt)$) {$=$};
\end{tikzpicture}
\end{equation}
Then the comultiplication law:
\begin{equation}\label{eqn.comult_law_draw}
\begin{tikzpicture}
	\node (sp1) {
	\begin{tikzpicture}[polybox, tos]
		\node[poly, dom, blue] (c) {};
		\node[poly, dgreen, right=1 of c] (c') {};
		\node[poly, cod, dgreen, right=2 of c'.south, yshift=-1ex] (c'1) {};
		\node[poly, cod, dgreen, above=of c'1] (c'2) {};
		\node at ($(c.east)!.5!(c'.west)$) {$f$};
	%
		\draw (c_pos) to[first] (c'_pos);
		\draw (c'_dir) to[last] (c_dir);
		\draw[dgreen,double] (c'_pos) to[first] (c'1_pos);
		\draw[dgreen] (c'1_dir) to[climb] node[right] {$\cod$} (c'2_pos);
		\draw[dgreen] (c'2_dir) to[last] node[above,sloped] {$\comp$} (c'_dir);
	\end{tikzpicture}
	};
	\node[right=of sp1] (sp2) {
	\begin{tikzpicture}[polybox, tos]
		\node[poly, dom, blue] (c) {};
		\node[poly, blue, right=2 of c.south, yshift=-1ex] (c1) {};
		\node[poly, blue, above=of c1] (c2) {};
		\node[poly, cod, dgreen, right=1 of c1] (c'1) {};
		\node[poly, cod, dgreen, right=1 of c2] (c'2) {};
		\node at ($(c1.east)!.3!(c'1.west)$) {$f$};
		\node at ($(c2.east)!.3!(c'2.west)$) {$f$};
	%
		\draw[blue,double] (c_pos) to[first] (c1_pos);
		\draw[blue] (c1_dir) to[climb] node[right] {$\cod$} (c2_pos);
		\draw[blue] (c2_dir) to[last] node[above,sloped] {$\comp$} (c_dir);
		\draw (c1_pos) to[first] (c'1_pos);
		\draw (c'1_dir) to[last] (c1_dir);
		\draw (c2_pos) to[first] (c'2_pos);
		\draw (c'2_dir) to[last] (c2_dir);
  \end{tikzpicture}	
	};
	\node at ($(sp1.east)!.5!(sp2.west)-(0,4pt)$) {$=$};
\end{tikzpicture}
\end{equation}
If we fill in \cref{eqn.unit_law_draw} with an object $i\in\ema{c}(\1)$, we obtain the equation
\[f^\sharp(i,\idy(f_1(i)))=\idy(i),\]
which is the first law of \cref{def.cofunctor}. If we fill in \cref{eqn.comult_law_draw} with $i\in\ema{c}(\1)$ and $m\in\ema{c}'[f(i)]$ and $m'\in\ema{c}'[\cod(m)]$, we obtain the equations
\begin{gather*}
  \cod(m)=f_1\big(\cod\big(f^\sharp(i,m)\big)\big)\\
  f^\sharp(i,\comp(m,m'))=\comp(f^\sharp(i,m),f^\sharp(\cod(f^\sharp(i,m)),m'))
\end{gather*}
and these are the second and third laws of \cref{def.cofunctor}.

\begin{exercise}\label{ex.cofunctors_comon_homs}
Summarize the proof of \cref{thm.ahman_uustalu}, developed above. You may cite anything written in the text so far.
\end{exercise}

\begin{proposition}\label{prop.cofunctors_isos}
Let $F\colon\cat{C}\cof\cat{D}$ be a cofunctor, $c,c'\in\Ob(\cat{C})$ objects, and $g\colon F(c)\to F(c')$ a morphism in $\cat{D}$. Then if $g$ is an isomorphism, so is $F^\sharp_{c}(g)$.
\end{proposition}
\begin{proof}
With $d\coloneqq F(c)$, $d'\coloneqq F(c')$, and $g'$ the inverse of $g$, we have
\begin{align*}
	\id_c&=
	F^\sharp_c(\id_d)\\&=
	F^\sharp_c(g\then g')\\&=
	F^\sharp_c(g)\then F^\sharp_{c'}(g')
\end{align*}
Thus $F^\sharp_{c}(g)$ is a section of $F^\sharp_{c'}(g')$. The opposite is true similarly, completing the proof.
\end{proof}


\paragraph{Examples of cofunctors.}

We saw in \cref{thm.ahman_uustalu}, summarized in \cref{ex.cofunctors_comon_homs}, that cofunctors $\cat{C}\cof\cat{D}$ are the same thing as morphisms of comonoids $\com{C}\to\com{D}$, so we elide the difference. The question we're interested in now is: how do we think about cofunctors? What is a map of polynomial comonoids like?

The rough idea is that a cofunctor $\cat{C}\cof\cat{D}$ is, in particular, a morphism $\ema{c}\to\ema{d}$ in $\poly$ between their emanation polynomials. This map preserves identities, codomains, and composition, which is great, but you still feel like you've got a map of polynomials on your hands: it goes forwards on objects and backwards on morphisms.

\slogan{
If a functor $\cat{C}\to\cat{D}$ is a \emph{picture} of $\cat{C}$ in $\cat{D}$, then a cofunctor $\cat{C}\cof\cat{D}$ is a \emph{$D$-shaped crystallization of $C$}.
}

Let's look at some examples to see how cofunctors look like crystallizations, or perhaps partitions.

\begin{example}\label{ex.BGEG}
Let $(G,e,*)$ be a group and $(\yon^G,\epsilon,\delta)$ the corresponding comonoid. There is a cofunctor $G\yon^G\to\yon^G$ given by
\[
\begin{tikzpicture}[polybox, mapstos]
	\node[poly, dom] (p) {$g_1*g_2$\nodepart{two}$g_1$};
	\node[poly, pure cod, right=of p] (q) {$g_2$\nodepart{two}\vphantom{$g_1$}};
	\draw (p_pos) to[first] (q_pos);
	\draw (q_dir) to[last] (p_dir);
\end{tikzpicture}
\]
To see this is a cofunctor, we check that identities, codomains, and compositions are preserved. For any $g_1$, the identity $e$ is passed back to $g_1*e=g_1$, and this is the identity on $g_1$ in $G\yon^G$. Codomains are preserved because there is only one object in $\yon^G$. Composites are preserved because for any $g_2,g_3$, we have $g_1*(g_2*g_3)=(g_1*g_2)*g_3$.
\end{example}

\begin{exercise}\label{exc.BGEG}
Does the idea of \cref{ex.BGEG} work when $G$ is merely a monoid, or does something go subtly wrong somehow?
\end{exercise}

\begin{proposition}\label{prop.monoids_ff}
There is a fully faithful functor $\Cat{Mon}\op\to\smcat^\sharp$, whose image is precisely those categories whose emanation polynomial is representable.
\end{proposition}
\begin{proof}
Given a monoid $(M,e,*)$, we think of it as a category with one object; its emanation polynomial $\yon^M$ is representable. A cofunctor between such categories carries no data in its on-objects part, and codomains are automatically preserved. Cofunctors $\yon^M\to\yon^N$ simply carry elements of $N$ to elements of $M$, preserving identity and composition, exactly the description of monoid homomorphisms.
\end{proof}

\begin{proposition}
There is an adjunction
\[
\smcat^\sharp(\cat{C},A\yon)\cong\smset(\Ob(\cat{C}),A)
\]
where $\cat{C}\in\smcat^\sharp$ is a comonoid and $A\in\smset$ is a set.  
\end{proposition}

\begin{example}\label{ex.cof_to_rr}
Consider the category $\rr\yon^\rr$, where the codomain of $r$ emanating from $x$ is $x+r$, identities are $0$, and composition is given by addition. What are cofunctors into $\rr\yon^\rr$?

Let $\cat{C}$ be a category and $|\cdot|\colon\cat{C}\cof\rr\yon^\rr$ a cofunctor. It assigns to every object $c$ both a real number $|c|\in\rr$ and a choice of emanating morphism $|c|^\sharp(r)\colon c\to c_r$ such that $|c|+r=|c_r|$. This assignment satisfies some laws. Namely we have $c_0=c$ and, given reals $r,s\in\rr$, we have $(c_r)_s=c_{r+s}$. 
\end{example}

\begin{exercise}
\begin{enumerate}
	\item Do you think a cofunctor $\cat{C}\cof\rr\yon^\rr$ as in \cref{ex.cof_to_rr} should be called an $(\rr,0,+)$-action on the objects of $\cat{C}$, or a filtration, or a valuation, or something else?
	\item Why?
\qedhere
\end{enumerate}
\end{exercise}

\begin{exercise}
\begin{enumerate}
	\item Over two discrete objects $\{A,B\}$, how many cofunctors are there
\[
\yon^\2+\yon\cong\fbox{$A\to B$}\too\fbox{$A\tto B$}\cong\yon^\3+\yon
\]
from the walking arrow category to the walking parallel-arrows category?
	\item What is meant more precisely by ``over two discrete objects $\{A,B\}$'' above?
\qedhere
\end{enumerate}
\end{exercise}

\begin{exercise}
Let $\com{C}=(\ema{c},\epsilon,\delta)$ be a comonoid in $\poly$. We have a state category $\ema{c}(\1)\yon^{\ema{c}(\1)}$ on the set of objects of $\com{C}$. There is a map of polynomials $\ema{c}(\1)\yon^{\ema{c}(\1)}\to\ema{c}$ given by
\[
\begin{tikzpicture}[polybox, mapstos]
	\node[poly, dom] (s) {$\cod(m)$\nodepart{two}$i$};
	\node[poly, cod, right=of s] (c) {$m\vphantom{d}$\nodepart{two}$i$};
	\draw[double] (s_pos) -- (c_pos);
	\draw (c_dir) -- node[above] {$\cod$} (s_dir); 
\end{tikzpicture}
\]
for an object $i\in\ema{c}(\1)$ and an outgoing morphism $m\in\ema{c}[i]$. Is this map a cofunctor?
\end{exercise}

\begin{example}[Canonical cofunctors from state categories]\label{ex.cof_from_state}
Let $\com{C}=(\ema{c},\epsilon,\delta)$ be a comonoid, where $\delta=(\id,\cod,\comp)$ as in \eqref{eqn.cod_comp}. For any position $i\in\ema{c}(\1)$, there is a cofunctor
\[
	(\cod,\comp)\colon\ema{c}[i]\yon^{\ema{c}[i]}\cof\ema{c}.
\]
That is, an object $f\in \ema{c}[i]$ is also a morphism in $\cat{C}$ and we send it to its codomain $\cod(f)$. A morphism in $\cat{C}$ emanating from $\cod(f)$ is passed back to its composite with $f$. 
\end{example}

\begin{exercise}
Suppose $\cat{C}=(\ema{c},\epsilon,\delta)$ is a comonoid.
\begin{enumerate}
	\item Show that the map $(\cod,\comp)\colon\ema{c}[i]\yon^{\ema{c}[i]}\cof\ema{c}$ from \cref{ex.cof_from_state} satisfies the conditions necessary for being a cofunctor (identities, codomains, and composites).
	\item Find a comonoid structure on the polynomial $p\coloneqq\sum_{i\in\ema{c}(\1)}\ema{c}[i]\yon^{\ema{c}[i]}$ and a cofunctor $p\to\ema{c}$.
	\item Is the polynomial map $p\to\ema{c}$ an epimorphism?
\qedhere
\end{enumerate}
\end{exercise}

\begin{exercise}
Suppose $\ema{c},\ema{d},\ema{e}$ are polynomials, each with a comonoid structure, and that $f\colon \ema{c}\to\ema{d}$ and $g\colon\ema{d}\to\ema{e}$ are maps of polynomials.
\begin{enumerate}
	\item If $f$ and $f\then g$ are each cofunctors, is $g$ automatically a cofunctor? If so, sketch a proof; if not sketch a counterexample.
	\item If $g$ and $f\then g$ are each cofunctors, is $f$ automatically a cofunctor? If so, sketch a proof; if not sketch a counterexample.
\qedhere
\end{enumerate}
\end{exercise}

\begin{exercise}
\begin{enumerate}
	\item For any category $\cat{C}$ with emanation polynomial $\ema{c}$, find a category with emanation polynomial $\ema{c}\yon$.
	\item Show your construction is functorial; i.e.\ given a cofunctor $\ema{c}\cof\ema{d}$, find one $\ema{c}\yon\cof\ema{d}\yon$, preserving identity and composition.
	\item Is your functor either a monad or a comonad on $\smcat^\sharp$?
	\item What category do you get by repeatedly applying this functor to $\yon$?
\qedhere
\end{enumerate}

\end{exercise}

\begin{exercise}
Are cofunctors between posets interesting?
\begin{enumerate}
	\item Consider the chain poset $[n]\cong\sum_{i=1}^n\yon^i$. How many cofunctors are there from $[m]\to[n]$ for all $m,n\in\{0,1,2,3\}$?
	\item What does a cofunctor from $\yon$ into a poset represent? Is there anything you'd call ``asymmetric'' about it?
\qedhere
\end{enumerate}
\end{exercise}

\begin{exercise}
\begin{enumerate}
	\item What is the finite set $\{\com{Q}_1,\ldots,\com{Q}_n\}$ of comonoids (defined up to isomorphism) for which the carrier polynomial is $\yon^\2+\yon$?
	\item For each category $\com{Q}_i$, describe how to imagine a cofunctor $\com{C}\to\com{Q}_i$ from an arbitrary category into it.
	\item What cofunctors exist between the various $\com{Q}_i$?
\qedhere
\end{enumerate}
\end{exercise}

\begin{exercise}
Let $S$ be a set. Describe a way to visualize cofunctors from categories into the state category $S\yon^S$. Feel free to focus on the case where $S$ is a small finite set. Hint: use \cref{prop.cofunctors_isos}.
\end{exercise}

\begin{exercise}
\begin{enumerate}
	\item Recall the star-shaped category $\yon^{\ord{n}+\1}+\ord{n}\yon$ from \cref{ex.star_shaped}. Describe cofunctors into it.
	\item Describe cofunctors into $A\yon$ for a set $A$.
	\item Describe cofunctors into $(\nn,\leq)$.
	\item Describe cofunctors into $(\nn,\geq)$.
	\item Let $\yon^\4+2\yon^\2+\yon$ denote the commutative square category. List the cofunctors from it to the walking arrow category $\yon^\2+\yon$? There should be six or so.
\qedhere
\end{enumerate}
\end{exercise}

\begin{example}[Objects aren't representable in $\smcat^\sharp$]\label{ex.rep_objects}
For categories and ordinary functors, there is a category $\cat{T}$ that \emph{represents objects}, in the sense that functors $\cat{T}\to\cat{C}$ are the same as objects in $\cat{C}$; indeed, take $\cat{T}=\fbox{$\bullet$}$ to be the terminal (one morphism) category.

This does not work for cofunctors, as we'll see in \cref{exc.rep_objects}. The comonoid corresponding to $\cat{T}$ is $\yon$ with its unique comonoid structure. Cofunctors $\cat{T}\cof\cat{C}$ are somewhat strange beasts: they can be identified with objects $c\in\cat{C}$ for which the codomain of every emanating morphism $c\to c'$ is $c'=c$ itself. The reason is the codomain condition (\cref{def.cofunctor}, condition 2).
\end{example}

\begin{exercise}\label{exc.rep_objects}
We saw in \cref{exc.linear_poly_comon} that $\2\yon$ has a unique comonoid structure.
\begin{enumerate}
	\item Show that for any category $\cat{T}$, there are $2^{\#\Ob(\cat{T})}$-many cofunctors $\cat{T}\cof\2\yon$.
	\item Use the case of $\cat{C}\coloneqq\2\yon$ to show that if a category $\cat{T}$ is going to represent objects as in \cref{ex.rep_objects} then $\cat{T}$ must have one object.
	\item Now use a different $\cat{C}$ to show that if a category $\cat{T}$ is going to represent objects, it must have more than one object.
\qedhere
\end{enumerate}
\end{exercise}

\begin{example}[Policies are co-representable]\label{ex.trajectories_corep}
For a category $\cat{C}$, let's say that a \emph{policy in $\cat{C}$} is a choice, for each object $c\in\cat{C}$, of an emanating morphism $f\colon c\to c'$. For example, consider the category $(\nn,\leq)\times(\nn,\leq)$:
\[
\begin{tikzpicture}[shorten <=4pt, shorten >=4pt]
	\foreach \i in {0,1,2,3} 
	{
		\foreach \j in {0,1,2}
		{
			\node (\i\j) at (\i,\j) {$\bullet$};
			\draw[->] (\i,\j) -- (\i+1,\j);
			\draw[->] (\i,\j) -- (\i,\j+1);
		};
	};
	\begin{scope}[red, thick]
		\draw[->] (0,0) -- (0,1);
		\draw[->] (0,1) -- (1,3);
		\draw[->] (0,2) -- (1,2);
		\draw[->] (1,0) -- (1,1);
		\draw[->] (1,1) edge[in=30, out=60, loop] (1,1);
		\draw[->] (1,2) -- (2,2);
		\draw[->] (2,0) to[bend right] (2,2);
		\draw[->] (2,1) -- (2,2);
		\draw[->] (2,2) -- (3,2);
		\draw[->] (3,0) -- (3,1);
		\draw[->] (3,1) -- (3,2);
		\draw[->] (3,2) edge[in=30, out=60, loop] (3,2);
	\end{scope}
\end{tikzpicture}
\]
In red we have drawn a policy: every object has been assigned an emanating morphism to another object; there doesn't need to be any rhyme or reason to our choice.

For any category $\cat{C}$, the set of trajectories in $\cat{C}$ is in bijection with the set of cofunctors
\[
\cat{C}\cof\cat{N}
\]
where $\cat{N}=\yon^\nn$ is the monoid of natural numbers under addition.
\end{example}

\begin{exercise}
At the end of \cref{ex.trajectories_corep} we said that a policy on $\cat{C}$ can be identified with a cofunctor $F\colon\cat{C}\cof\cat{N}$. But at first it appears that $F$ includes more than just a policy: for every object $c\in\Ob(\cat{C})$ and natural number $n\in\nn$, we have a morphism $F^\sharp_c(n)$ emanating from $c$. That's infinitely many emanating morphisms per object, whereas a policy seems to include only one emanating morphism per object.

Explain why looks are deceiving in this case: why is a policy on $\cat{C}$ the same as a cofunctor $\cat{C}\cof\cat{N}$?
\end{exercise}

We will see later in \cref{prop.traj_mon_poly} that the trajectories on a category form a monoid, and that this operation $\smcat^\sharp\to\Cat{Mon}\op$ is functorial and in fact an adjoint.

\begin{exercise}[Continuous trajectories]
Suppose we say that a continuous policy in $\cat{C}$ is a cofunctor $\cat{C}\cof\cat{R}$, where $\cat{R}$ is the monoid of real numbers under addition, considered as a category with one object. 

Describe continuous trajectories in $\cat{C}$ using elementary terms, i.e.\ to someone who doesn't know what a cofunctor is and isn't yet ready to learn.
\end{exercise}

\begin{exercise}
Let $\rr/\zz\cong[0,1)$ be the quotient of $\rr$ by the $\zz$-action sending $(r,n)\mapsto r+n$. More down to earth, it's the set of real numbers between 0 and 1, including 0 but not 1.%]
\begin{enumerate}
	\item Find a comonoid structure on $(\rr/\zz)\yon^\rr$.
	\item Is it a groupoid?
\qedhere
\end{enumerate}
\end{exercise}

\begin{exercise}
\begin{enumerate}
	\item If two categories are isomorphic in $\smcat$, does that imply they are isomorphic in $\smcat^\sharp$?
	\item If so, prove it; if not, give a counterexample.
	\item Is it true that for any two categories $\cat{C},\cat{D}$, there is a bijection between the set of isomorphisms $\cat{C}\To{\cong}\cat{D}$ in $\smcat$ and the set of isomorphisms $\cat{C}\overset{\cong}{\cof}\cat{D}$ between them in $\smcat^\sharp$?
	\item If so, prove it; if not, give a counterexample.
\qedhere
\end{enumerate}
\end{exercise}


\paragraph{Very well behaved lenses}

In the functional programming community, there is an important notion of very well-behaved lenses. These turn out to be precisely the cofunctors between state categories. Since state categories $S\yon^S$ play an important role in our theory, we take a bit of time to consider cofunctors between them.

\begin{example}[Very well-behaved lenses]\label{ex.well_behaved}
Recall from \cref{ex.state_comonad_1} that for any set $S$, we have the ``state'' category with emanation polynomial $S\yon^S$. What are the comonoid morphisms---cofunctors---between different state categories?

First, such a comonoid morphism includes a morphism of polynomials $f\colon S\yon^S\to T\yon^T$; we'll use the standard terminology of ``get'' and ``put'':
\[
\begin{tikzpicture}[polybox, tos]
	\node[poly, dom] (s) {};
	\node[poly, cod, right=of s] (t) {};
	\node[left=0pt of s_pos] {$S$};
	\node[left=0pt of s_dir] {$S$};
	\node[right=0pt of t_pos] {$T$};
	\node[right=0pt of t_dir] {$T$};
	%
	\draw (s_pos) to[first] node[below] {$\lensget$} (t_pos);
	\draw (t_dir) to[last] node[above] {$\lensput$} (s_dir);
\end{tikzpicture}
\]
Let's apply the unit-homomorphism property \eqref{eqn.unit_law_draw}
\[
\begin{tikzpicture}
	\node (id1) {
	\begin{tikzpicture}[polybox, tos]
  	\node[poly, dom] (s) {put$($get$(s))$\nodepart{two}$s\vphantom{(}$};
  	\node[poly, right=of s] (t) {get$(s$)\nodepart{two}get$(s$)};
  	%
  	\draw (s_pos) to[first] node[below] {get} (t_pos);
  	\draw (t_dir) to[last] node[above] {put} (s_dir);
  	\draw (t_pos) to[climb'] (t_dir);
	\end{tikzpicture}
	};
	\node[right=of id1] (id2) {
	\begin{tikzpicture}[polybox, tos]
		\node[poly, dom] (s) {$s$\nodepart{two}$s$};
		\draw (s_pos) to[climb'] (s_dir);
	\end{tikzpicture}	
	};
	\node at ($(id1.east)!.5!(id2.west)-(0,6pt)$) {$=$};
\end{tikzpicture}
\]
It says that $\lensput(\lensget(s))=s$. This is typically called the get-put law.

We leave the comultiplication-homomorphism law to \cref{exc.well_behaved}, where we will see that it specifies that get and put must satisfy two other properties, called the put-put and the put-get laws.
\end{example}

\begin{exercise}\label{exc.well_behaved}
Complete \cref{ex.well_behaved}.
\begin{enumerate}
	\item Write out the comultiplication law from \eqref{eqn.unit_law_draw} in terms of poly-boxes.
	\item What set-theoretic equations are forced by the comultiplication law?
	\item Can you see why they might be called put-put and put-get?
\qedhere
\end{enumerate}
\end{exercise}

\begin{example}[Very well-behaved lenses are kinda boring]\label{ex.well_behaved_boring}
We saw in \cref{exc.well_behaved} that a comomonoid homomorphism (cofunctor) $S\yon^S\cof T\yon^T$ between state comonoids can be characterized as a pair of functions $\lensget\colon S\to T$ and $\lensput\colon S\times T\to S$ satisfying get-put, put-get, and put-put. 

In fact, it turns out that this happens if and only if $\lensget$ is a product projection! For example, if the cardinalities $|S|$ and $|T|$ of $S$ and $T$ are finite and $|S|$ is not divisible by $|T|$, then there are no cofunctors $S\yon^S\cof T\yon^T$. A stringent condition, no? We'll explore it in  \cref{exc.how_many_vwbls} below.

Let's explain why cofunctors between state categories are just product projections. A product projection $A\times B\to A$ always has another factor ($B$); if every cofunctor between state categories is a product projection, what is the other factor†? It turns out that the other factor will be:
\[
F\coloneqq\{f\colon T\to S\mid t\in T,\;\lensget(f(t))=t\text{ and }\lensput(f(t),t)=f(t)\}.
\]
In other words we will see that if $(\lensget,\lensput)$ is a comonoid homomorphism then there is a bijection $S\cong T\times F$ and that $\lensget\colon S\to T$ is one of the projections. We will see that the converse is true in \cref{exc.well_behaved_boring}

So assume $(\lensget,\lensput)\colon S\yon^S\cof T\yon^T$ is a comonoid homomorphism, in particular that it satisfies put-get, get-put, and put-put. We obtain a function $\pi\colon S\to T\times F$ given by
\[s\mapsto\big(\lensget(s),t\mapsto\lensput(s,t)\big)\]
and it is well-defined since for all $s\in S$ and $t,t'\in T$ we have $\lensget(\lensput(s,t))=t$ by put-get and $\lensput(\lensput(s,t),t')=\lensput(s,t')$ by put-put. We also obtain a function $\pi'\colon T\times F\to S$ given by
\[
(t,f)\mapsto f(t).
\]
The two functions $\pi,\pi'$ are mutually inverse: the roundtrip on $S$ is identity because $\lensput(s,\lensget(s))=s$ by get-put; the roundtrip on $T\times F$ is identity because $\lensget(f(t))=t$ and $\lensput(f(t),t)=f(t)$ by assumption on $f\in F$.
\end{example}

\begin{exercise}\label{exc.well_behaved_boring}
Let $S,T,F$ be sets and suppose given an isomorphism $\alpha\colon S\to T\times F$.
\begin{enumerate}
	\item Show that there exists a very well behaved lens $\lensget\colon S\to T$ and $\lensput\colon S\times T\to S$.
	\item Show that there exists a cofunctor between the state category on $S$ and the state category on $T$.
	\item Show that there exists a comonoid homomorphism $S\yon^S\to T\yon^T$ between the state comonoids.
\qedhere
\end{enumerate}
\end{exercise}

\begin{exercise}\label{exc.how_many_vwbls}
\begin{enumerate}
	\item Suppose $|S|=3$. How many cofunctors are there $S\yon^S\to S\yon^S$?
	\item Suppose $|S|=4$ and $|T|=2$. How many cofunctors are there $S\yon^S\cof T\yon^T$?
\qedhere
\end{enumerate}
\end{exercise}

\begin{exercise}
Let $S,T$ be sets and $\lensget\colon S\to T$ and $\lensput\colon S\times T\to S$ the parts of a very well behaved lens, i.e.\ a cofunctor $S\yon^S\to T\yon^T$ between state categories. Is it possible that $\lensput\colon S\times T\to S$ is itself a product projection, i.e.\ sends $(s,t)\mapsto s$?
\end{exercise}

When we get to cofree comonoids, we'll obtain a whole new class of cofunctors that are interesting to consider. But for now, we move on to more theory.

\paragraph{Some math about $\smcat^\sharp$}
We refer to morphisms between polynomial comonoids as cofunctors, again eliding the difference between comonoids in $\poly$ and categories.


\begin{proposition}[Niu]
The coproduct of polynomial comonoids agrees with the coproduct of categories. In particular, the initial comonoid is $0$.
\end{proposition}
\begin{proof}
We refer the claim about $0$ to \cref{exc.0_initial_com}.

Let $\cat{C}_1$ and $\cat{C}_2$ be categories and $\ema{c}_1,\ema{c}_2$ their emanation polynomials, i.e.\ the carriers of the corresponding comonoids $\com{C}_1$ and $\com{C}_2$. We first notice that $\ema{c}\coloneqq\ema{c}_1+\ema{c}_2$ is the carrier for the comonoid $\com{C}$ corresponding to the sum category $\cat{C}\coloneqq\cat{C}_1+\cat{C}_2$. Indeed, the object-set of the sum is given by the sum of the object-sets
\[
	\Ob(\cat{C}_1+\cat{C}_2)
  \cong
  \Ob(\cat{C}_1)+\Ob(\cat{C}_2),
\]
and a morphism in $\cat{C}_1+\cat{C}_2$ emanating from any such object is just a morphism in whichever of the categories $\cat{C_1}$ or $\cat{C}_2$ it is from. 

It remains to show that $\com{C}$ is the coproduct of $\com{C}_1$ and $\com{C}_2$ in $\smcat^\sharp$. Suppose given a comonoid $\com{D}$ and comonoid homomorphisms (cofunctors) $f_1\colon\com{C}_1\cof\com{D}$ and $f_2\colon\com{C}_2\cof\com{D}$. Then for any object of $\com{C}$ we have an associated object $f(c)\in\com{D}$, given either by $f(c)\coloneqq f_1(c)$ or by $f(c)\coloneqq f_2(c)$ depending on whether $c\in\com{C}_1$ or $c\in\com{C}_2$. For any morphism $m$ emanating from $f(c)$ we have a morphism $f^\sharp(m)$ emanating from $c$. It is easy to check that the cofunctor laws hold for $f$. Uniqueness of $f$ given $f_1,f_2$ is also straightforward.
\end{proof}

\begin{exercise}\label{exc.0_initial_com}
\begin{enumerate}
	\item Show that $0$ is a comonoid.
	\item Show that $0$ is initial as a comonoid.
\qedhere
\end{enumerate}
\end{exercise}

\begin{exercise}
If $\com{C}=(\ema{c},\epsilon,\delta)$ is a category, show there is an induced category structure on the polynomial $\2\ema{c}$.
\end{exercise}

\begin{exercise}
Check that the terminal comonoid is $\yon$.
\end{exercise}

\begin{proposition}[Niu]
The category $\smcat^\sharp$ has products.
\end{proposition}

\begin{proposition}[Porst]
The forgetful functor $\Cat{Comon}(\poly) \to \poly$ is comonadic.
\end{proposition}
\begin{proof}
The fact that a forgetful functor $\Cat{Comon}(\poly) \to \poly$ is comonadic if it has a right adjoint follows from Beck's monadicity theorem via an obvious generalization of an argument given by Par{\'e} in \cite[pp.~138-9]{pare1969absolute}, as pointed out by Porst in \cite[Fact~3.1]{porst2019colimits}.
\end{proof}

\begin{corollary}
The category $\smcat^\sharp = \Cat{Comon}(\poly)$ has all small colimits.
They are created by the underlying polynomial functor $\Cat{Comon}(\poly) \to \poly$.
\end{corollary}
\begin{proof}
It is well known that a comonadic functor creates all colimits that exist in its codomain \cite{nlab:created-limit}.
By \cref{thm.poly_colimits}, the category $\poly$ has all small colimits.
\end{proof}

\begin{proposition}
Let $\Cat{Comon}(\poly)_{\text{rep}}$ be the full subcategory of comonoids $(c,\epsilon,\delta)$ in $\poly$ for which the carrier $c=\yon^M$ is representable. Then there is an isomorphism of categories
\[
\Cat{Comon}(\poly)_{\text{rep}}\cong\Cat{Mon}\op
\]
where $\Cat{Mon}$ is the category of monoids.
\end{proposition}
\begin{proof}
Let $\cat{C}$ be a category. It has only one object iff its emanation polynomial $\ema{c}$ has only one position, i.e.\ $\ema{c}\cong\yon^M$ for some $M\in\smset$, namely where $M$ is the set of morphisms in $\cat{C}$. It remains to show that cofunctors between monoids are dual---opposite---to morphisms between monoids.

A cofunctor $f\colon\yon^M\to\yon^N$ involves a single function $f^\sharp\colon N\to M$ that must satisfy a law coming from unitality and one coming from composition, as in \cref{def.morphism_comonoids}. The result can now be checked by hand, or seen formally as follows. Each object in the two diagrams \eqref{eqn.morphism_comonoids} is representable by \cref{exc.composites_of_specials}. The Yoneda embedding $\smset\op\to\poly$ is fully faithful, so these two diagrams are equivalent to the unit and composition diagrams for monoid homomorphisms.
\end{proof}

\begin{exercise}\label{exc.lin_comon_set}
Let $\Cat{Comon}(\poly)_{\text{lin}}$ be the full subcategory of comonoids $(c,\epsilon,\delta)$ in $\poly$ for which the carrier $c=M\yon$ is linear. Show that there is an isomorphism of categories
\[
\Cat{Comon}(\poly)_{\text{lin}}\cong\smset.
\qedhere
\]
\end{exercise}

\begin{proposition}
The inclusion of linear comonoids into all comonoids has a left adjoint
\[
\adj{\Cat{Comon}(\poly)}{(\ema{c}\tri\1)\yon}{A\yon}{\Cat{Comon}(\poly)_{\text{lin}}}
\]
denoted by where they send a comonoid $(\ema{c},\epsilon,\delta)$ and a linear comonoid $A\yon$.
\end{proposition}
\begin{proof}
We need to show that for any comonoid $(\ema{c},\epsilon,\delta)$ and set $A$, we have a natural isomorphism
\[
  \smcat^\sharp(\ema{c},A\yon).
  \cong^?
  \smcat^\sharp((\ema{c}\tri\1)\yon,A\yon)
\]
But every morphism in $A\yon$ is an identity, so the result follows from the fact that every cofunctor must pass identities back to identities. 
\end{proof}

A cofunctor (map of polynomial comonoids) is called \emph{cartesian} if the underlying map $f\colon \ema{c}\to \ema{d}$ of polynomials is cartesian (i.e.\ for each position $i\in \ema{c}(\1)$, the map $f^\sharp_i\colon\ema{d}[f_1(i)]\to\ema{c}[i]$ is an isomorphism).

\begin{proposition}\label{prop.factor_cofunctor}
Every cofunctor $f\colon\cat{C}\cof\cat{D}$ factors as a vertical morphism followed by a cartesian morphism
\[
\cat{C}\overset{\text{vert}}{\cof}\cat{C}'\overset{\text{cart}}{\cof}\com{D}.
\]
\end{proposition}
\begin{proof}
A cofunctor $\cat{C}\cof\cat{D}$ is a map of polynomials $\ema{c}\to\ema{d}$ satisfying some properties, and any map of polynomials $f\colon\ema{c}\to\ema{d}$ can be factored as a vertical morphism followed by a cartesian morphism
\[
	\ema{c}\To{g}\ema{c'}\To{h}\ema{d}.
\]
For simplicity, assume $g_1\colon\ema{c}(\1)\to\ema{c}'(\1)$ is identity (rather than merely isomorphism) on positions and similarly that for each $i\in\ema{c}$ the map $h^\sharp_i\colon\ema{c}'[i]\to\ema{d}[h_1(i)]$ is identity (rather than merely isomorphism) on directions. 

It suffices to show that the intermediate object $\ema{c'}$ can be endowed with the structure of a category such that $g$ and $h$ are cofunctors. Given an object $i\in\ema{c}'(\1)$, assign its identity to be the identity on $h_1(i)=f(i)$; then both $g$ and $h$ preserve identities because $f$ does. Given an emanating morphism $m\in\ema{c}'[i]=\ema{d}[f(i)]$, assign its codomain to be $\cod(m)\coloneqq\cod(f^\sharp_i(m))$, and given an emanating morphism $m'\in\ema{c}'[\cod(m)]$, assign the composite $m\then m'$ in $\ema{c}'$ to be $m\then m'$ in $\ema{d}$. In \cref{exc.factor_cofunctor} we will check that with these definitions, $\ema{c}'$ is a category and both $g$ and $h$ are cofunctors.
\end{proof}

\begin{exercise}\label{exc.factor_cofunctor}
We will complete the proof of \cref{prop.factor_cofunctor}, using the same notation.
\begin{enumerate}
	\item Show that composition is associative and unital in $\ema{c}'$.
	\item Show that $g$ preserves codomains.
	\item Show that $g$ preserves compositions.
	\item Show that $h$ preserves codomains.
	\item Show that $h$ preserves compositions.
\qedhere
\end{enumerate}
\end{exercise}


\begin{proposition}
The wide subcategory of cartesian maps in $\smcat^\sharp$ is isomorphic to the category of wide subcategory of discrete opfibrations in $\smcat$.
\end{proposition}
\begin{proof}
Suppose that $\cat{C}$ and $\cat{D}$ are categories. Both a functor and a cofunctor between them involve a map on objects, say $f\colon\Ob(\cat{C})\to\Ob(\cat{D})$. For any object $c\in\Ob(\cat{C})$, a functor gives a function, say $f_\sharp\colon\cat{C}[c]\to\cat{D}[f(c)]$ whereas a cofunctor gives a function $f^\sharp\colon\cat{D}[f(c)]\to\cat{C}[c]$. The cofunctor is cartesian iff $f^\sharp$ is an iso, and the functor is a discrete opfibration iff $f_\sharp$ is an iso. We thus transform our functor into a cofunctor (or vice versa) by taking the inverse function on morphisms. It is easy to check that this inverse appropriately preserves identities, codomains, and compositions.
\end{proof}

\begin{proposition}\label{prop.com_vert_cat_boo}
The wide subcategory of vertical maps in $\smcat^\sharp$ is isomorphic to the opposite of the wide subcategory bijective-on-objects maps in $\smcat$:
\[
\smcat^\sharp_{\text{vert}}\cong(\smcat_{\text{boo}})\op.
\]
\end{proposition}
\begin{proof}
Let $\cat{C}$ and $\cat{D}$ be categories. Given a vertical cofunctor $F\colon\cat{C}\cof\cat{D}$, we have a bijection $F_1\colon\Ob(\cat{C})\to\Ob(\cat{D})$; let $G_1$ be its inverse. We define a functor $G\colon\cat{D}\to\cat{C}$ on objects by $G_1$ and, for any $f\colon d\to d'$ in $\cat{D}$ we define $G(f)\coloneqq F^\sharp_{G_1(d)}$. It has the correct codomain: $\cod(G(f))=G_1(F_1(\cod(G(f)))=G_1(\cod f)$. And it sends identities and compositions to identities and compositions by the laws of cofunctors.

The construction of a vertical cofunctor from a bijective-on-objects functor is analogous, and it is easy to check that the two constructions are inverses.
\end{proof}

\begin{exercise}
Let $S$ be a set and consider the state category $\cat{S}\coloneqq(S\yon^S,\epsilon,\delta)$. Use \cref{prop.com_vert_cat_boo} to show that categories $\cat{C}$ equipped with a vertical cofunctor $\cat{S}\to\cat{C}$ can be identified with categories whose set of objects is $S$.
\end{exercise}

\begin{exercise}
Consider the categories $\cat{C}\coloneqq\fbox{$\bullet\tto\bullet$}$ and $\cat{D}\coloneqq\fbox{$\bullet\to\bullet$}$. There is a unique bijective-on-objects (boo) functor $F\colon\cat{C}\to\cat{D}$ and two boo functors $G_1,G_2\colon\cat{D}\to\cat{C}$.
\begin{enumerate}
	\item Write down the morphism $\ema{d}\to\ema{c}$ of emanation polynomials underlying $F$.
	\item Write down the morphism $\ema{c}\to\ema{d}$ of emanation polynomials underlying either $G_1$ or $G_2$.
\qedhere
\end{enumerate}
\end{exercise}

\paragraph{Dirichlet monoidal product on $\smcat^\sharp$.}

The usual product of categories gives a monoidal operation on comonoids too, even though it is not a product in $\smcat^\sharp$. The carrier polynomial of the product is the $\otimes$-product of the carrier polynomials.


\begin{proposition}\label{prop.dirichlet_on_catsharp}
The Dirichlet monoidal product $(\yon,\otimes)$ on $\poly$ extends to a monoidal structure $(\yon,\otimes)$ on $\smcat^\sharp$, such that the functor
$U\colon\smcat^\sharp\to\poly$
is strong monoidal with respect to $\otimes$. The Dirichlet product of two categories is their product in $\smcat$.
\end{proposition}
\begin{proof}
Let $\cat{C},\cat{D}\in\smcat^\sharp$ be categories with emanation polynomials $\ema{c},\ema{d}\in\poly$. The emanation polynomial of $\cat{C}\otimes\cat{D}$ is defined to be $\ema{c}\otimes\ema{d}$. A position in it is a pair $(c,d)$ of objects, one from $\cat{C}$ and one from $\cat{D}$; a direction there is a pair $(f,g)$ of a morphism emanating from $c$ and one emanating from $d$. 

We define $\epsilon_{\cat{C}\otimes\cat{D}}\colon\ema{c}\otimes\ema{d}\to\yon$ as
\[
\ema{c}\otimes\ema{d}\To{\epsilon_{\ema{C}}\otimes\epsilon_{\ema{D}}}\yon\otimes\yon\cong\yon.
\]
This says that the identity at $(c,d)$ is the pair of identities.

We define $\delta_{\cat{C}\otimes\cat{D}}\colon(\ema{c}\otimes\ema{d})\to(\ema{c}\otimes\ema{d})\tri(\ema{c}\otimes\ema{d})$ using the duoidal property:
\[
\ema{c}\otimes\ema{d}\To{\delta_{\ema{c}}\otimes\delta_{\ema{d}}}(\ema{c}\tri\ema{c})\otimes(\ema{d}\tri\ema{d})\to(\ema{c}\otimes\ema{d})\tri(\ema{c}\otimes\ema{d}).
\]
One can check that this says that codomains and composition are defined coordinate-wise, and that $(\ema{c}\otimes\ema{d},\epsilon_{\ema{c}\otimes\ema{d}},\delta_{\ema{c}\otimes\ema{d}})$ forms a comonoid. One can also check that this is functorial in $\cat{C},\cat{D}\in\smcat^\sharp$. See \cref{exc.dirichlet_on_catsharp}.
\end{proof}

\begin{exercise}\label{exc.dirichlet_on_catsharp}
We complete the proof of \cref{prop.dirichlet_on_catsharp}.
\begin{enumerate}
	\item Show that $(\ema{c}\otimes\ema{d},\epsilon_{\ema{c}\otimes\ema{d}},\delta_{\ema{c}\otimes\ema{d}})$, as described in \cref{prop.dirichlet_on_catsharp}, forms a comonoid.
	\item Check that the construction $(\cat{C},\cat{D})\mapsto\cat{C}\otimes\cat{D}$ is functorial in $\cat{C},\cat{D}\in\smcat^\sharp$.
\qedhere
\end{enumerate}
\end{exercise}
%
%As everyone reading this is probably aware, strict monoidal structure on a category $\cat{C}$ is a functor $1\to\cat{C}$ and a functor $\cat{C}\times\cat{C}\to\cat{C}$ that together satisfy the monoid equations. Here the $\times$ takes place in $\smcat$. 
%
%If we replace $(\smcat,\1,\times)$ with $(\smcat^\sharp,\yon,\otimes)$, then a monoid is a cofunctor $\intercal\colon\yon\cof\cat{C}$, which we call the \emph{terminus}, and a cofunctor $\curlyvee\colon\cat{C}\otimes\cat{C}\cof\cat{C}$, which we call the \emph{team-up product} satisfying the monoid equations. Let's call these $\otimes$-monoids in $\smcat^\sharp$. 
%
%It appears that $\otimes$-monoids $(\cat{C},\intercal,\curlyvee)$ in $\smcat^\sharp$ could be interesting for thinking about the dynamics of something like ``swarms'': collections of dynamical systems that work very well together as a population. Indeed, $\curlyvee$ takes a pair of objects $c_1,c_2$ and returns a single object $c_1\curlyvee c_2$, but it takes a morphism $f\colon c_1\curlyvee c_2\to d$ emanating that object to a pair of morphisms $f_1\colon c_1\to d_1$ and $f_2\colon c_2\to d_2$ with $d_1\curlyvee d_2=d$.
%
%
%\begin{example}[Representable and linear $\otimes$-monoids]
%Representable polynomials have at most one commutative $\otimes$-monoid structure by a theorem of Fox. Category (polynomial comonoid) structures on a representable polynomial $\yon^M$ are just monoid structures on its underlying set $M$. So a commutative monoid $(M,e,*)$ in $\smset$ can be identified with a $\otimes$-monoid in $\smcat^\sharp$ that has carrier $\yon^M$.
%
%A $\otimes$-monoidal structure on a linear $M\yon$ polynomial, on the other hand, can be identified with a monoid structure $(M,e,*)$ on the set $M$. But there is a unique comonoid structure on $M\yon$. So a monoid in $\smset$ can be identified with a $\otimes$-monoid in $\smcat^\sharp$ having carrier $M\yon$.
%\end{example}
%
%\begin{example}\label{ex.monaco_cat}
%Consider the comonoid $\com{C}=(\ema{c},0,+)$ corresponding to the category
%\[
%\fbox{
%\begin{tikzcd}[ampersand replacement=\&]
%	\cdots\ar[r, "-1"']\&
%	\LMO{n}\ar[r, "-1"']\&
%	\cdots\ar[r, "-1"']\&
%	\LMO{2}\ar[r, "-1"']\&
%	\LMO{1}\ar[r, "-1"']\&
%	\LMO{0}
%\end{tikzcd}
%}
%\]
%It is carried by the polynomial $\ema{c}\coloneqq\sum_{n\in\nn}\yon^{\{0,-1,-2\ldots,-n\}}\cong\yon+\yon^\2+\yon^\3+\cdots$, its codomain map is given by $(n,-i)\mapsto n+(-i)$ and its counit and comultiplication are given by $0$ and addition.
%
%This comonoid has a (non-symmetric) $\otimes$-monoid structure. Namely its terminus is $0$ and its team-up product $\curlyvee$ on an object $(n_1,n_2)$ is given by
%\[
%\curlyvee_1(n_1,n_2)\coloneqq n_1+n_2,\]
%and on a morphism $-n_1-n_2\leq i\leq 0$ works as follows:
%\[
%\curlyvee^\sharp_{n_1+n_2}(i)\coloneqq	\big(\min(n_1,n_1+n_2+i),\max(0,n_2+i)\big)
%\]
%For example, say $n_1=3$ and $n_2=2$, so $\curlyvee_1(n_1,n_2)=5$. Let's pick $-5\leq i\geq 0$. 
%\[
%\begin{array}{c|c}
%	i&\curlyvee^\sharp(i)\\\hline
%	0&(3,2)\\
%	1&(3,1)\\
%	2&(3,0)\\
%	3&(2,0)\\
%	4&(1,0)\\
%	5&(0,0)
%\end{array}
%\]
%\end{example}
%
%\begin{exercise}
%Let $\com{C}$ be the comonoid from \cref{ex.monaco_cat}. We need to check that everything works correctly.
%\begin{enumerate}
%	\item Check that the terminus $\intercal\colon\yon\to\com{C}$ is a cofunctor.
%	\item Check that $\curlyvee$ preserves identities.
%	\item Check that $\curlyvee$ preserves codomains and compositions, and hence is a cofunctor.
%\qedhere
%\end{enumerate}
%\end{exercise}
%
%\begin{exercise}
%Consider the polynomial
%\[
%  c\coloneqq
%  \sum_{n\in\nn}\sum_{\ell\colon\ord{n}\to\nn}
%  \yon^{\{\ell'\colon\ord{n}\to\nn\;\mid\; \ell'\leq\ell\}}
%\]
%A position in $c$ is a list of natural numbers, and a direction is a smaller list. 
%\begin{enumerate}
%	\item Find a comonoid structure on $c$.
%	\item Find a $\otimes$-monoid structure $(\intercal,\curlyvee)$ on the comonoid you just found. (If you can't, start over.)
%\qedhere
%\end{enumerate}
%\end{exercise}
%
%\begin{exercise}
%Every $\otimes$-monoid in $\smcat^\sharp$ has an underlying category. This forgetful functor has a left adjoint: to every category $\cat{C}\in\smcat^\sharp$ we can assign a \emph{free} $\otimes$-monoid.
%\begin{enumerate}
%	\item Make the above claim precise, but don't prove it yet.
%	\item We propose that if the emanation polynomial of $\cat{C}$ is $\ema{c}$ then the free $\otimes$-monoid on it has emanation polynomial $\ema{L_c}$ given by
%	\[
%	\ema{L_c}\coloneqq\sum_{[\ell_1,\ldots,\ell_n]\in\Set{List}(\ema{c}(\1))}\yon^{\ema{c}[\ell_1]\times\cdots\times\ema{c}[\ell_n]}.
%	\]
%	This is supposed to be a comonoid in $\poly$; what should be the identities, codomains, and composition?
%	\item	Propose a terminus $\intercal\colon\yon\to\ema{L_c}$.
%	\item Propose a team-up product $\curlyvee\colon\ema{L_c}\otimes\ema{L_c}\to\ema{L_c}$.
%	\item Does it look promising that these will satisfy the monoid laws?
%	\item Sketch an argument that this construction is left adjoint to the forgetful functor sending a $\otimes$-monoid in $\smcat^\sharp$ to its underlying category.
%\qedhere
%\end{enumerate}
%\end{exercise}
%



%-------- Section --------%
\section{Cofree comonoids}\label{sec.cofree}

%---- Subsection ----%
\subsection{Introduction: Cofree comonoids and dynamical systems}

We can now return to dynamical systems. Recall that if $p\in\poly$ is a polynomial, then a dynamical system with interface $p$ consists of a set $S$ and a map of polynomials $f\colon S\yon^S\to p$. We think of positions in $p$ kind of like outputs---others can observe your position---but also as determining the set of inputs---directions---that could be input next.

The way this map $f$ leads to something that seems to ``go on repeatedly'' is that $\ema{s}\coloneqq S\yon^S$ is a comonoid, so we have maps $\ema{s}\To{\delta}\ema{s}\tripow{n}\To{f\tripow{n}}p\tripow{n}$ for all $n$. This says that given any initial position in $S$, we automatically get a position in $p$, and for every direction there, another position in $p$, and for every direction there, another position in $p$, and so on $n$ times. This is the dynamics.

So the above all works because we have a polynomial map $S\yon^S\to p$, where $S\yon^S$ is the underlying polynomial of a polynomial comonad. Since ``underlying polynomial'' is a functor $U\colon\smcat^\sharp\to\poly$, a seasoned category theorist might be tempted to ask, is there an adjunction
\[
\poly(U\com{C},p)\cong\smcat^\sharp(\com{C},\cofree{p}),
\]
for some functor $\cofree{}\colon\poly\to\smcat^\sharp$? In fact, there is; we refer to $\cofree{p}$ as the \emph{cofree comonoid} on $p$, or more descriptively, the \emph{category of $p$-trees.}

Cofree comonoids in $\poly$ are beautiful objects, both in their visualizable structure as a category and in the metaphors we can make about them. They allow us to replace the interface of a dynamical system with a category and get access to a rich theory that exists there.

\begin{theorem}[Cofree comonoid]\label{thm.cofree}
The forgetful functor $\Cat{Comon}(\poly)\to\poly$ has a right adjoint
\[
  \adj{\smcat^\sharp}{\ema{c}}{\cofree{p}}{\poly}
\]
where the functors have been named by where they send $(\ema{c},\epsilon,\delta)\in\smcat^\sharp$ and $p\in\poly$ respectively.
\end{theorem}
This will be proved as \cref{??}.

%---- Subsection ----%
\subsection{Cofree comonoids as trees}\label{subsec.cofree_tree}

\begin{definition}[Cofree comonoid]\label{def.cofree}
Let $p\in\poly$ be a polynomial. The comonoid $\cofree{p}=(\tr_p,\rt,\fs)$ as in \cref{thm.cofree} is called the \emph{cofree comonoid on $p$} or informally the category of \emph{(possibly infinite) $p$-trees}.

An object $t\in \tr_p(\1)$ is a called a \emph{(possibly infinite) tree in $p$.} Given such an object $t$ in the category, an emanating morphism $n\in\tr_p[t]$ is called a \emph{path from root}.
\end{definition}

The terminology of \cref{def.cofree} is alluding to a specific way we like to imagine the comonoid $\cofree{p}=(\tr_p,\rt,\fs)$, namely in terms of trees. To every polynomial $p$, we will associate a new polynomial $\tr_p$ whose positions are (possibly infinite) $p$-trees. To choose such tree we first choose its root to be some position $i\in p(\1)$. Then for every direction $d\in p[i]$ there, we choose another position, and for every direction from each of those we choose another position, and so on indefinitely.

So a position in $\tr_p$ is one of these trees. Such a tree may end, namely if every one of the top-level positions have no directions, but often it will not end. Given such a tree, say $t$, a direction $d\in\tr_p[t]$ there is simply a path from the root to some node in the tree. 

We'll explain the counit $\rt$ and the comultiplication $\fs$ after going through an example.

\begin{example}\label{ex.imagining_trees}
Let $p\coloneqq\{\bul[red],\bul[blue]\}\yon^\2+\bul[dgreen]\yon+\bul[dyellow]$. Here are four trees in $p$:
\begin{equation}\label{eqn.some_trees_misc58}
\begin{tikzpicture}[trees,
  level 1/.style={sibling distance=10mm},
  level 2/.style={sibling distance=5mm},
  level 3/.style={sibling distance=2.5mm}]
	\node[red] (a) {$\bullet$}
		child {node[red] {$\bullet$}
			child {node[dyellow] {$\bullet$}}
			child {node[dyellow] {$\bullet$}}
		}
		child {node[dgreen] {$\bullet$}
			child {node[dgreen] {$\bullet$}
				child
			}
		}
		;
	\node[dgreen, right=2 of a] (b) {$\bullet$}
		child {node[blue] {$\bullet$}
			child {node[blue] {$\bullet$}
				child
				child
			}
			child {node[red] {$\bullet$}
				child
				child
			}
		};
	\node[dyellow, right=2 of b] (c) {$\bullet$};
	\node[red, right=2 of c] {$\bullet$}
		child {node[blue] {$\bullet$}
			child {node[red] {$\bullet$}
				child
				child
			}
			child {node[red] {$\bullet$}
				child
				child
			}
		}
		child {node[red] {$\bullet$}
			child {node[red] {$\bullet$}
				child
				child
			}
			child {node[red] {$\bullet$}
				child
				child
			}
		};
\end{tikzpicture}
\end{equation}
They all represent elements of $p\tripow{3}$, but only the third one---the single yellow dot---would count as an element of $\tr_p$. 

Indeed, in \cref{def.cofree}, when we speak of a (possibly infinite) tree in $p$, we mean at tree for which each node is a position in $p$ with each of its emanating directions filled by another position in $p$, and so on. Since three of the four trees shown in \eqref{eqn.some_trees_misc58} have open leaves---arrows emanating from the top---these trees are not elements of $\tr_p$. However, each of them could be extended to an actual element of $\tr_p$ by continually filling in each open leaf with another position of $p$.

Let's imagine some actual elements of $\tr_p$:
\begin{itemize}
	\item The binary tree that's ``all red all the time''.
	\item The binary tree where odd layers are red and even layers are blue.
	\item The tree where all the nodes are red, except for the right-most branch, which is always green.%
	\footnote{\;Note that branches are actually unordered, so it's technically wrong to think of it as a line of green up the \emph{right side}. Instead, it's just a line of green going up the tree forever.}
	\item Any finite tree, where every branch terminates in a yellow dot.
	\item Completely random: for the root, randomly choose either red, blue, green, or yellow, and at every leaf, loop back to the beginning, i.e.\ randomly choose either red, blue, green, or yellow, etc.
\end{itemize}
These are the positions in the polynomial $\tr_p$ that underlies the cofree comonoid on $p$. There are uncountably many positions in $\cofree{p}$, at least for this particular $p$---in fact, even $\cofree{2\yon}$ has $2^\nn$-many positions---but only finitely many can be described in any finite language like English. Thus most of the elements of $\cofree{p}$ cannot be described.
\end{example}

\begin{exercise}\label{exc.trees_1}
\begin{enumerate}
	\item Interpret each of the five tree examples imagined in \cref{ex.imagining_trees} by drawing three or four layers (your choice) of it.
\end{enumerate}
For each of the following polynomials $p$, describe the set of trees (positions) in $\tr_{p}$.
\begin{enumerate}[resume]
	\item $p=\1$. (What is the set $\tr_p$ of $p$-trees?)
	\item $p=\2$.
	\item $p=\yon$.
	\item $p=\yon^\2$.
	\item $p={\2\yon}$.
	\item $p={\yon+\1}$.
	\item $p={B\yon^A}$ for some sets $A,B\in\smset$.
\qedhere
\end{enumerate}
\end{exercise}

Now that we've explained the underlying polynomial $\tr_p$ of the cofree comonoid $\cofree{p}=(\tr_p,\rt,\fs)$, we just need to explain how identities, codomains, and composition work, i.e.\ we just need to give the counit map $\rt\colon\tr_p\to\yon$ and the comultiplication map $\fs\colon\tr_p\to\tr_p\tri\tr_p$. 

Again, the objects in the category $\cofree{p}$ are $p$-trees, and a morphism emanating from such a tree $t$ is a path from its root $r$ to some node. The map $\rt$, applied to $t$, returns $t$'s root $r$, or more precisely the path from $r$ to itself. The map $\fs$, applied to $t$, first needs to give a codomain (tree) to every path from the root to some other node $n$. It is just the subtree of $t$ whose root is $n$: the tree of all nodes starting at $n$. Now, given a path from the root of that tree (namely $n$) to another node, say $n'$, we need to give a path from $r$ to $n'$; we take it to be the composite of the path $r\to n$ and the path $n\to n'$.

\begin{exercise}
Let $p\coloneqq\{\bul[red],\bul[blue]\}\yon^\2+\bul[dgreen]\yon+\bul[dyellow]$ as in \cref{ex.imagining_trees}.
\begin{enumerate}
	\item Choose an object $t\in \tr_p$, i.e.\ a tree in $p$, and draw a finite approximation of it (say four layers).
	\item What is the identity morphism at $t$?
	\item Choose a nonidentity morphism $f$ emanating from $t$ and draw it.
	\item What is the codomain of $f$? Draw a finite approximation of it.
	\item Choose a morphism emanating from the codomain of $f$ and draw it.
	\item What is the composite of your two morphisms? Draw it on $t$.
\qedhere
\end{enumerate}
\end{exercise}

\begin{example}
Let's take $p\coloneqq\1$. An element in $\tr_p(\1)$ is given by choosing an element $i\in p(\1)$ and filling each of its direction $p[i]$ with another element of $p(\1)$, and so on. But there is only one element of $p(\1)$ and it has no directions. So $\tr_\1$ has only one position, and the only emanating morphism there is the identity. In other words, $\tr_\1=\yon$.

Since $\yon$ has a unique comonoid structure, we've described the cofree comonoid $\cofree(\1)$. It is a single tree consisting of a single node, and the only outgoing morphism is the identity on that node.
\end{example}

\begin{exercise}
Let $A$ be a set.
\begin{enumerate}
	\item What is $\tr_A$? 
	\item How is it given the structure of a category?
\qedhere
\end{enumerate}
\end{exercise}

\begin{example}
Let $p\coloneqq\yon$. An element in $\tr_p(\1)$ is given by choosing an element $i\in p(\1)$ and filling each of its direction $p[i]$ with another element of $p(\1)$, and so on. There is only one way to do this, i.e.\ there is only one such tree, namely $t\coloneqq\fbox{$\bullet\to\bullet\to\bullet\to\cdots$}$.

So $\tr_p$ has a single position, namely $t$. That position has an emanating morphism for each path out of the root, so it has $\nn$-many emanating morphisms: one for every length. Hence $\tr_\yon=\yon^\nn$.

Of course the codomain of each morphism emanating from $t$ is again $t$: that's the only object. The composite of two paths, one of length $m$ and one of length $n$ is $m+n$. Hence we see that the category $\cofree(\yon)$ is the monoid $(\nn,0,+)$ considered as a category with one object.
\end{example}

\begin{exercise}
Let $A$ be a set.
\begin{enumerate}
	\item What is $\tr_{A\yon}$? 
	\item How is it given the structure of a category?
\qedhere
\end{enumerate}
\end{exercise}

\begin{example}
Let $p\coloneqq\nn\yon^\2$. An element of $\tr_p$ might start like this:
\[
\begin{tikzpicture}[trees,
  level 1/.style={sibling distance=10mm},
  level 2/.style={sibling distance=5mm},
  level 3/.style={sibling distance=2.5mm}]
	\node {$17$}
		child {node {$3$}
			child {node {$0$}
				child
				child
			}
			child {node {$3$}
				child
				child
			}
		}
		child {node {$1$}
			child {node {$92$}
				child
				child
			}
			child {node {$6$}
				child
				child
			}
		};
\end{tikzpicture}
\]
Any element of $\tr_p$ goes on forever: it's an infinite binary tree. At each node it has a choice of some natural number, since $\nn=p(\1)$ is the set of positions in $p$.

So such trees are the objects of the category $\cofree{p}=(\tr_p,\rt,\fs)$. A morphism emanating from a tree $t$ is a path from its root to another node, which is an element of $\Set{List}(\2)$, i.e.\ a finite list of choices in $\2$, which you can think of as a finite sequence of left/right choices. The codomain is whatever tree this path ends up on. 

So the emanation polynomial of $\cofree{p}$ is
\[\tr_p\cong\nn^{\Set{List}(\2)}\yon^{\Set{List}(\2)}\]
with identities given by the empty list. An object $t\in\tr_p(\1)$ is a function $t\colon\Set{List}(\2)\to\nn$, a way to put a natural number at every node of the infinite binary tree. An emanating morphism $\ell\in\Set{List}(\2)$ is just a path from the root to another node, and its codomain is the other node. Formally it is the function $t'\colon\Set{List}(\2)\to\nn$ given by $t'(\ell')\coloneqq t(\ell:\ell')$, where $\ell:\ell'$ is the concatenation of these lists. Composition of morphisms is also given by concatenation of the corresponding lists.
\end{example}

\begin{exercise}
Let $p\coloneqq B\yon^A$ for sets $A,B\in\smset$.
\begin{enumerate}
	\item Describe the objects of the cofree category $\cofree{p}$.
	\item For a given such object, describe the emanating morphisms.
	\item Describe how to take the codomain of a morphism.
\qedhere
\end{enumerate}
\end{exercise}

\begin{example}[$\cofree{A\yon}$ for linear polynomials]\label{ex.streams_cofree}
Let $A\in\smset$ be a set. The cofree comonoid $\cofree{A\yon}$ on the associated linear polynomial has as emanation polynomial $\tr_{A\yon}\cong (A\yon)^\nn$. Its objects are $A$-streams. For each stream $t\colon \nn\to A$, an emanating morphism is just an element $n\in\nn$. The identity is $0\in\nn$, the codomain of $n$ is the composite function $\nn\To{+n}\nn\To{t}A$, and if we denote it by $n\colon t\to (t+n)$ then the composite of morphisms $n,n'$ is $(n+n')\colon t\to (t+n+n')$.

We first saw this category in \cref{ex.streams_category}
\end{example}

\begin{exercise}
Let $p\coloneqq \yon+\1$.
\begin{enumerate}
	\item Describe the objects of the cofree category $\cofree{p}$.
	\item For a given such object, describe the emanating morphisms.
	\item Describe how to take the codomain of a morphism.
\qedhere
\end{enumerate}
\end{exercise}

\begin{exercise}
Let $p\coloneqq \{a,b,c,\ldots,z,\text{\textvisiblespace}\}\yon+\1$.
\begin{enumerate}
	\item Describe the objects of the cofree category $\cofree{p}$, and draw one.
	\item For a given such object, describe the emanating morphisms.
	\item Describe how to take the codomain of a morphism.
\qedhere
\end{enumerate}
\end{exercise}


\paragraph{Decision trees.}

When you talk about your future, what exactly might you be talking about? In some sense you can make choices that change what will happen to you, but in another sense it's as though for each such choice there is something beyond your control that makes a new situation for you. You're constantly in the position of needing to make a choice, but its results are beyond your control.

This is very much how positions $t\in\cofree{p}$ look. Such a position is a decision tree: at each stage (node), you have an element $i\in p(\1)$, which we've been calling a decision. It has $p[i]$-many options, each of which, say $d\in p[i]$ results in a new node $\cod(d)$ of the tree.

So a position $t$ is like a future: it is a current decision, and for every option there, a new decision tree. It's all the decisions you could possibly make, and for each actual choice, it's a new future. A direction at $t$ is just a choice of finite path through the tree: a sequence of choices. 

\begin{exercise}
If someone says that they understand a future to be a decision tree $t\in\cofree{p}$, explain in your own words how they're thinking about the term ``future''. How does it agree or disagree with your own intuition about what a ``future'' is?
\end{exercise}

\begin{exercise}
Let $G$ be a finite directed graph, and let $\Cat{Fr}(G)$ be the associated free category. 
\begin{enumerate}
	\item Construct a cofunctor $\Cat{Fr}(G)\cof\cofree{\1+\yon+\yon^\2+\yon^\3+\cdots}$.
	\item Would you say it associates to each node in $G$ its ``future'' decision tree?
\qedhere
\end{enumerate}
\end{exercise}

%---- Subsection ----%
\subsection{Formal construction of $\cofree{p}$}

We will sketch how one can formally construct $\cofree{p}$ from $p$. The first step is called copointing, and it's pretty easy: just multiply $p$ by $\yon$. It adds a kind of ``default'' direction to each position in $p$.

\paragraph{Copointing.}

\begin{definition}[Copointed polynomial]
A \emph{copointed polynomial} is a pair $(p,\epsilon)$, where $p\in\poly$ is a polynomial and $\epsilon\colon p\to\yon$ is a morphism in $\poly$.

A \emph{morphism} of copointed polynomials $f\colon (p,\epsilon)\to(p',\epsilon')$ is a morphism $f\colon p\to p'$ such that $\epsilon=f\then\epsilon'$.
\end{definition}

Comonoids in $\poly$ are triples $(p,\epsilon,\delta)$, with $(p,\epsilon)$ a copointed polynomial, so there are forgetful functors
\[
\Cat{Comon}(\poly)\to\Cat{Cpt}(\poly)\to\poly.
\]
We want to find the right adjoint to the composite---that's the functor $\cofree{-}\colon\poly\to\Cat{Comon}(\poly)$---and we will obtain it in two steps. 

\begin{proposition}\label{prop.copointing}
For any polynomial $p$, the polynomial $p\yon$ is naturally copointed by the projection to $\yon$, and the functor sending $p\mapsto p\yon$ is right adjoint to the forgetful functor
\[
\adj{\Cat{Cpt}(\poly)}{p\yon}{q}{\poly},
\]
where the functors are named by where they send $p\in\poly$ and $(q,\epsilon)\in\Cat{Cpt}(\poly)$.
\end{proposition}
\begin{proof}
Clearly the product $p\yon\cong p\times\yon$ is copointed by the projection map, call it $\pi\colon p\yon\to\yon$, and the map $p\mapsto p\yon$ is functorial in $p$. For any copointed polynomial $q\To{\epsilon}\yon$, there is an obvious bijection between morphisms of polynomials $q\to p$ and commutative triangles
\[
\begin{tikzcd}[column sep=small]
	q\ar[dr, "\epsilon"']\ar[rr]&&
	p\yon\ar[dl, "\pi"]\\&
	\yon
\end{tikzcd}
\]
natural in both $q$ and $p$. This completes the proof.
\end{proof}

\begin{exercise}
Show that the copointing functor is essentially surjective. That is, every polynomial $p$ equipped with a map $\epsilon\colon p\to\yon$ is isomorphic to one of the form $p'\yon$ (equipped with the projection $p'\yon\to\yon$).
\end{exercise}

The reader might not remember any sort of copointing showing up in the tree description of $\cofree{p}=(\tr_p,\rt,\fs)$. Indeed, it was hidden in the fact that we allowed for trivial paths in the tree (e.g.\ the path from the root to itself). But we'll get to that.

The copointing $p\mapsto p\yon$ just adds an extra direction to each position; we can denote this extra direction with an $=$, as we did in \cref{ex.walking_arrow}. So for example if $p=\yon^\3+\yon$, drawn as left, then $p\yon\cong\yon^\4+\yon^\2$ can be drawn as right:
\[
\begin{tikzpicture}
	\node[draw, "$p$" below] (p1) {
	\begin{tikzpicture}[trees, sibling distance=4mm]
    \node (1) {$\bullet$} 
      child 
      child 
      child;
    \node[right=.75 of 1] (2) {$\bullet$} 
      child;
  \end{tikzpicture}
  };
	\node[draw, "$p\yon$" below] (p2) [right=of p1] {
	\begin{tikzpicture}[trees, sibling distance=3mm]
    \node (1) {$\bullet$} 
      child {\idchild}
      child 
      child 
      child;
    \node[right=.75 of 1] (2) {$\bullet$} 
      child {\idchild}
      child;
  \end{tikzpicture}
	};
\end{tikzpicture}
\]
It just adds a default direction to each position. A copointed map from $(q,\epsilon)$ to $(p\yon,\pi)$ must pass the default direction back to the default direction in $q$, but leaves the other directions in $p$ to go wherever they want to.

\begin{example}[Slowing down dynamical systems]
Given a dynamical system $f\colon S\yon^S\to p$, we automatically get a map $S\yon^S\to p\yon$ to the cofree pointing. We called this ``adding a pause button'' in \cref{ex.pause}. Thus we can take any dynamical system and replace it with one whose interface is copointed.

We can use a copointed interface to slow down a dynamical system, in a kind of inverse to how we sped up dynamical systems in \eqref{eqn.speedup}. There we took a dynamical system $f$ with interface $p$ and produced one and produced one with interface $p\tripow{k}$. Here we will take one with interface $p\tripow{k}$ and produce one with interface $p$.

To do this, we need $p$ to be copointed, i.e.\ we need to have in hand a map $\epsilon\colon p\to\yon$, and as we saw above that we can always assume that. Now for any $k\in\nn$ we have $k$-many maps $p\tripow{k}\to p$. For example, if $k=3$, we have
\[
\{\epsilon\tri\epsilon\tri p,\epsilon\tri p\tri\epsilon,p\tri\epsilon\tri\epsilon\}\ss\poly(p\tripow{3},p)
\]
So given a dynamical system $S\yon^S\to p\tripow{k}$, which outputs as its position a whole $k$-fold strategy at one time and which takes as input sequences of $k$-many inputs, we can feed it one input and $k-1$ pauses. This is what you get when you compose $S\yon^S\to p\tripow{k}\to p$.

Given a dynamical system $f\colon S\yon^S\to p$, where $p$ is copointed and $f$ preserves the copoint, we could speed it up as before to get $S\yon^S\to p\tripow{k}$ and then slow it down to get $S\yon^S\to p$, and we get back $f$. So slowing down is a retract of speeding up in this sense.
\end{example}

\begin{exercise}
\begin{enumerate}
	\item Show that there is a monoidal structure $(\yon,\otimes)$ on $\Cat{Cpt}(\poly)$ such that the forgetful functor $U\colon\Cat{Cpt}(\poly)\to\poly$ is strong monoidal.
	\item Show that this monoidal structure is closed, i.e.\ that there is an internal hom $[-,-]$ on $\Cat{Cpt}(\poly)$. Hint: you should have $U([p\yon,q\yon]_{\Cat{Cpt}})\cong[p\yon,q]_{\poly}\yon$.
\qedhere
\end{enumerate}
\end{exercise}


\paragraph{Constructing the cofree comonoid.}

It remains to show that we can functorially take any copointed polynomial $(q,\epsilon)$ and return a comonoid, and that this construction is right adjoint to the forgetful functor. From the description in \cref{subsec.cofree_tree}, we know the cofree comonoid is supposed to have something to do with infinite trees. And we know that the set of height-$n$ $p$-trees is given by $p\tripow{n}$. So we might think we can somehow take a limit of these height-$n$ trees for various $n$. 

The problem is there's no obvious maps between $p\tripow{n}$ and $p\tripow{n+1}$. Luckily, the copointing fixes that problem. Given $\epsilon\colon q\to\yon$, we have two maps $q\tri q\tto q$, namely $q\tri\epsilon$ and $\epsilon\tri q$.

\begin{example}
Suppose $q=\{A\}\yon^{\{i_A,f\}}+\{B\}\yon^{i_B}$ with copointing $\epsilon$ selecting $i_A$ and $i_B$:
\[
\begin{tikzpicture}[rounded corners]
	\node (p1) [draw, "$q\coloneqq$" left] {
	\begin{tikzpicture}[trees, sibling distance=5mm]
    \node["\tiny $A$" below, red] (1) {$\bullet$} 
      child  {coordinate (iA) \idchild}
      child {coordinate (f)};
    \node[right=.8 of 1,"\tiny $B$" below, blue] (2) {$\bullet$} 
      child  {coordinate (iB) \idchild};
    \node[below left=0 of iA, font=\tiny] {$i_A$};
    \node[below left=0 of iB, font=\tiny] {$i_B$};
    \node[below right=0 of f, font=\tiny] {$f$};
  \end{tikzpicture}
  };
\end{tikzpicture}
\]
Then $q\tri q$ looks as follows
\[
\begin{tikzpicture}[rounded corners]
	\node (p1) [draw, "$q\tri q=$" left] {
	\begin{tikzpicture}[trees,
	  level 1/.style={sibling distance=5mm},
  	level 2/.style={sibling distance=2.5mm}]
    \node[red] (1) {$\bullet$} 
      child  {
        node [red] {$\bullet$} 
 		    child  {\idchild}
      	child {}
			\idchild
			}
      child  {
        node [red] {$\bullet$} 
 		    child  {\idchild}
      	child {}
			};
    \node[right=1 of 1, red] (2) {$\bullet$} 
      child  {
        node [red]{$\bullet$} 
 		    child  {\idchild}
      	child {}
			\idchild
			}
      child {node [blue] {$\bullet$} 
      	child  {\idchild}
			};
    \node[right=1 of 2, red] (3) {$\bullet$} 
      child {node [blue] {$\bullet$} 
      	child  {\idchild}
				\idchild
			}
      child  {
        node [red] {$\bullet$} 
 		    child {\idchild}
      	child {}
			};
    \node[right=1 of 3, red] (4) {$\bullet$} 
      child {node [blue] {$\bullet$} 
      	child  {\idchild}
			\idchild
			}
      child {node [blue] {$\bullet$} 
      	child  {\idchild}
			};
    \node[right=.8 of 4, blue] (5) {$\bullet$} 
      child  {
        node [red] {$\bullet$} 
 		    child  {\idchild}
      	child {}
			\idchild
			};
    \node[right=.6 of 5, blue] (6) {$\bullet$} 
      child {node [blue] {$\bullet$} 
      	child  {\idchild}
			\idchild
			};
  \end{tikzpicture}
  };
\end{tikzpicture}
\]
How can we picture the maps $(q\tri\epsilon),(\epsilon\tri q)\colon q\tri q\to q$?

The map $q\tri\epsilon$ takes each position of $q\tri q$ to whatever is on the bottom layer: it takes the first four to $A$ and the last two to $B$. It passes back directions using the defaults ($i_A$ and $i_B$) on the top layer.

The map $\epsilon\tri q$ uses the defaults on the bottom layer instead. Every position in $q\tri q$ has a default direction, and the corolla sitting there in the top layer is where $\epsilon\tri q$ sends it, with identity on directions. 
\end{example}

Indeed, for every $n$, there are $(n+1)$-many morphisms $q\tripow{n+1}\to q\tripow{n}$, so we have a diagram
\begin{equation}\label{eq.simplicial_diag}
\begin{tikzcd}
	\yon&
	q\ar[l, "\epsilon"']&
	q\tri q\ar[l, shift left, "q\tri\epsilon"]\ar[l, shift right, "\epsilon\tri q"']&[10pt]
	q\tripow{3}\ar[l, shift left=7pt, "q\tri q\tri\epsilon"]\ar[l, shift right=7pt, "\epsilon\tri q\tri q"']\ar[l, "q\tri\epsilon\tri q" description]&
	\cdots\ar[l, shift left=6pt]\ar[l, shift left=2pt]\ar[l, shift right=6pt]\ar[l, shift right=2pt]
\end{tikzcd}
\end{equation}
The cofree comonoid is given by the limit of this diagram.

Let's denote the shape of this diagram by $\Delta_+$: its objects are finite ordered sets---including the empty set---and its morphisms are order-preserving injections. For any copointed polynomial $q\To{\epsilon}\yon$, we get a diagram $Q\colon\Delta_+\to\poly$ as above, and this is functorial in $q$.

\begin{theorem}\label{thm.cofree}
For any copointed polynomial $q\To{\epsilon}\yon$, let $\bar{q}$ denote the limit of $Q\colon\Delta_+\to\poly$. It naturally has the structure of a comonoid $(\bar{q},\epsilon,\delta)$, and this construction is right adjoint to the forgetful functor
\[
\adj{\Cat{Comon}(\poly)}{U}{\bar{q}}{\Cat{Cpt}(\poly)}.
\]
\end{theorem}
\begin{proof}[Proof sketch]
We first give $\bar{q}$ the structure of a comonoid. Since $\bar{q}$ is the limit of \eqref{eq.simplicial_diag}, the inclusion the inclusion $\{0\}\to\Delta_+$ induces a projection map $\bar{q}\to\yon$, which we again call $\epsilon$. Since $\tri$ commutes with connected limits in both variables and $\Delta_+$ is connected, we have that $\bar{q}\tri\bar{q}$ is the limit of the following $\Delta_+\times\Delta_+$-shaped diagram:
\[
\bar{q}\tri\bar{q}\cong\lim\left(
\begin{tikzcd}
  q\tripow{(0+0)}&
  q\tripow{(0+1)}\ar[l]&
  q\tripow{(0+2)}\ar[l, shift left=2pt]\ar[l, shift right=2pt]&
  q\tripow{(0+3)}\ar[l]\ar[l, shift left=4pt]\ar[l, shift right=4pt]&
  \cdots\ar[l, shift left=6pt]\ar[l, shift left=2pt]\ar[l, shift right=2pt]\ar[l, shift right=6pt]\\
  q\tripow{(1+0)}\ar[u]&
  q\tripow{(1+1)}\ar[u]\ar[l]&
  q\tripow{(1+2)}\ar[u]\ar[l, shift left=2pt]\ar[l, shift right=2pt]&
  q\tripow{(1+3)}\ar[u]\ar[l]\ar[l, shift left=4pt]\ar[l, shift right=4pt]&
  \cdots\ar[l, shift left=6pt]\ar[l, shift left=2pt]\ar[l, shift right=2pt]\ar[l, shift right=6pt]\\
  q\tripow{(2+0)}\ar[u, shift left=2pt]\ar[u, shift right=2pt]&
  q\tripow{(2+1)}\ar[u, shift left=2pt]\ar[u, shift right=2pt]\ar[l]&
  q\tripow{(2+2)}\ar[u, shift left=2pt]\ar[u, shift right=2pt]\ar[l, shift left=2pt]\ar[l, shift right=2pt]&
  q\tripow{(2+3)}\ar[u, shift left=2pt]\ar[u, shift right=2pt]\ar[l]\ar[l, shift left=4pt]\ar[l, shift right=4pt]&
  \cdots\ar[l, shift left=6pt]\ar[l, shift left=2pt]\ar[l, shift right=2pt]\ar[l, shift right=6pt]\\
  q\tripow{(3+0)}\ar[u]\ar[u, shift left=4pt]\ar[u, shift right=4pt]&
  q\tripow{(3+1)}\ar[u]\ar[u, shift left=4pt]\ar[u, shift right=4pt]\ar[l]&
  q\tripow{(3+2)}\ar[u]\ar[u, shift left=4pt]\ar[u, shift right=4pt]\ar[l, shift left=2pt]\ar[l, shift right=2pt]&
  q\tripow{(3+3)}\ar[u]\ar[u, shift left=4pt]\ar[u, shift right=4pt]\ar[l]\ar[l, shift left=4pt]\ar[l, shift right=4pt]&
  \cdots\ar[l, shift left=6pt]\ar[l, shift left=2pt]\ar[l, shift right=2pt]\ar[l, shift right=6pt]\\
	\vdots\ar[u, shift left=6pt]\ar[u, shift left=2pt]\ar[u, shift right=2pt]\ar[u, shift right=6pt]&
	\vdots\ar[u, shift left=6pt]\ar[u, shift left=2pt]\ar[u, shift right=2pt]\ar[u, shift right=6pt]&
	\vdots\ar[u, shift left=6pt]\ar[u, shift left=2pt]\ar[u, shift right=2pt]\ar[u, shift right=6pt]&
	\vdots\ar[u, shift left=6pt]\ar[u, shift left=2pt]\ar[u, shift right=2pt]\ar[u, shift right=6pt]&
	\ddots
\end{tikzcd}
\right)
\]
There is a commutative diagram in $\smcat$
\begin{equation}\label{eqn.simplicial_poly_misc384}
\begin{tikzcd}[column sep=small]
	\Delta_+\times\Delta_+\ar[rr, "+"]\ar[dr, bend right, near start, "{(m_1,m_2)\mapsto q\tripow{(m_1+m_2)}}"']&&
	\Delta_+\ar[dl, bend left, near start, "n\mapsto q\tripow{n}"]\\&
	\poly
\end{tikzcd}
\end{equation}
which induces a map (in the opposite direction) between their limits $\delta\colon\bar{q}\to\bar{q}\tri\bar{q}$, which we take to be the comultiplication. Appending \eqref{eqn.simplicial_poly_misc384} with the inclusion $\{0\}\times\Delta_+\to\Delta_+\times\Delta_+$, etc., it is easy to see that $(\bar{q},\epsilon,\delta)$ satisfies the axioms of a comonoid.

We sketch the proof that this construction is right adjoint to the forgetful functor. For any copointed polynomial $(q,\epsilon)$, there is a counit map $\bar{q}\to q$, given by the obvious projection of the limit \eqref{eq.simplicial_diag}. Given a comonoid $(\ema{c},\epsilon,\delta)$, there is a morphism $\ema{c}\to\bar{\ema{c}}$ induced by the maps $\delta^{n-1}\colon\ema{c}\to\ema{c}\tripow{n}$ from \cref{ex.delta_n_notation}. It is easy to check that these commute with the $\epsilon$'s in the diagram. To see that $\ema{c}\to\bar{\ema{c}}$ extends to a morphism of comonoids amounts to checking that the diagram
\[
\begin{tikzcd}[column sep=50pt]
	\ema{c}\ar[r, "\delta^{m+n-1}"]\ar[d, "\delta"']&
	\ema{c}\tripow{(m+n)}\ar[d, equal]\\
	\ema{c}\tri\ema{c}\ar[r, "\delta^{m-1}\tri\delta^{n-1}"']&
	\ema{c}\tripow{m}\tri\ema{c}\tripow{n}
\end{tikzcd}
\]
commutes for any $m,n\in\nn$. Both triangle equations are straightforward.
\end{proof}

\begin{remark}
The construction of the cofree comonoid from a copointed endofunctor in the proof of \cref{thm.cofree} is fairly standard; see \cite{lack2010note}. Nelson Niu has also constructed the cofree comonoid on a polynomial using a different limit diagram
\[
\begin{tikzcd}
	\yon\ar[d]&
	p\ar[d]&
	p\tri p\ar[d]&[10pt]
	p\tri p\tri p\ar[d]&
	\cdots\\
	\1&
	p\tri \1\ar[l, "!"]&
	p\tri p\tri \1\ar[l, "p\tri\,!"]&
	p\tri p\tri p\tri \1\ar[l, "p\tri p\tri\,!"]&
	\cdots\ar[l]
\end{tikzcd}
\]
in terms of the original polynomial $p$, rather than from its copointing $p\yon$; that is, this construction is right adjoint to $\Cat{Comon}(\poly)\to\poly$. One could also construct this right adjoint using the following limit, again applied to the original polynomial $p$:
\[
\begin{tikzcd}[sep=small]
	\yon\ar[dr]&&
	p\ar[dl]\ar[dr]&&
	p\tri p\ar[dl]\ar[dr]&&
	p\tri p\tri p\ar[dl]\ar[dr]&
	\cdots\\&
	\1&&
	p\tri\1&&
	p\tri p\tri \1&&
	\cdots
\end{tikzcd}
\]
\end{remark}

We record the following proposition here; it will be useful in \cref{cor.cartesian_cof_extra_adjoint}.

\begin{proposition}
If $f\colon p\to q$ is a Cartesian map of polynomials, then $\tr_f\colon\tr_p\to\tr_q$ is a Cartesian cofunctor. That is, for each tree $t\in\tr_p(\1)$ the function $\tr_f^\sharp\colon\tr_p[t]\To{\cong}\tr_q[\tr_f(t)]$ is a bijection.
\end{proposition}
\begin{proof}
**
\end{proof}

\begin{proposition}
The cofree comonoid functor is lax monoidal; in particular, we have maps
\[
\yon\to\cofree{\yon}
\qqand
\cofree{p}\otimes\cofree{q}\to\cofree{p\otimes q}
\]
for any $p,q\in\poly$.
\end{proposition}


%---- Subsection ----%
\subsection{Consequences of adjointness}

%\[
%\begin{tikzpicture}[polybox, tos]
%	\node[poly, dom, "$q$" left] (q) {};
%	\node[poly, cod, below right=1.6 and 4 of q.south, "$p$" right] (p1) {};
%	\node[poly, cod, above=of p1, "$p$" right] (p2) {};
%	\node[poly, cod, above=of p2, "$p$" right] (p3) {};
%	\node[poly, cod, above=of p3, "$p$" right] (p4) {};
%	\node[poly, cod, above=of p4, "$p$" right] (p5) {};
%	\node[poly, draw=none, above=of p5] (ph) {};
%%
%	\draw (q_pos) to[first] (p1_pos);
%	\draw (p1_dir) to[climb] node[circle, inner sep=0, fill=white] (or2) {or}(p2_pos);
%	\draw (p2_dir) to[climb] node[circle, inner sep=0, fill=white] (or3) {or} (p3_pos);
%	\draw (p3_dir) to[climb] node[circle, inner sep=0, fill=white] (or4) {or} (p4_pos);
%	\draw (p4_dir) to[climb] node[circle, inner sep=0, fill=white] (or5) {or} (p5_pos);
%	\draw (p5_dir) to[climb] node[circle, inner sep=0, fill=white] (or6) {or} (ph_pos);
%	\draw[shorten <=4pt] (or2.center) to[last] (q_dir);
%	\draw[shorten <=4pt] (or3.center) to[last] (q_dir);
%	\draw[shorten <=4pt] (or4.center) to[last] (q_dir);
%	\draw[shorten <=4pt] (or5.center) to[last] (q_dir);
%	\draw[shorten <=4pt] (or6.center) to[last] (q_dir);
%\end{tikzpicture}
%\]

Recall from \cref{def.gen_moore} that a dependent system (or generalized Moore machine) is a map of polynomials $f\colon S\yon^S\to p$. Here $S$ is called the set of states and $p$ is the interface. 

But now we know that $S\yon^S$ is secretly the underlying polynomial of a comonoid. This means that $f$ has a mate, i.e.\ a corresponding cofunctor $S\yon^S\cof\cofree{p}$ to the category of $p$-trees. How does that work?

\begin{example}\label{ex.cofree_dyn_sys}
Let $S\coloneqq\{\bul[dgreen],\bul[dyellow],\bul[red]\}$ and $p\coloneqq\yon^\2+\yon$, and consider the dynamical system $f\colon S\yon^S\to p$ from \cref{exc.det_fsa_misc_398}, depicted here again for your convenience:
\[
\begin{tikzcd}[column sep=small]
	\bul[dgreen]\ar[rr, bend left, orange]\ar[loop left, dgreen]&&
	\bul[dyellow]\ar[dl, bend left, orange]\ar[ll, dgreen, bend left]\\&
	\bul[red]
\end{tikzcd}
\]
The polynomial map $f$ is supposed to induce a cofunctor $F\colon S\yon^S\cof\cofree{p}$ from the state category on $S$ to the category of $p$-trees. Thus to each state $s\in S$, we need to associate a tree; which should it be? 
\end{example}

\begin{exercise}
Consider the walking arrow category $\cat{W}=\fbox{$\bullet\to\bullet$}$. Draw the cofunctor $\cat{W}\to\cofree{\yon^\2+\yon}$.
\end{exercise}

\paragraph{Dynamical systems and graph fibrations.}

In \cref{ex.cofree_dyn_sys}, there's a certain relationship we can see between the graph we associate to the dynamical system $S\yon^S\to p$, namely 
\[
\begin{tikzcd}[column sep=small]
	\bul[dgreen]\ar[rr, bend left, orange]\ar[loop left, dgreen]&&
	\bul[dyellow]\ar[dl, bend left, orange]\ar[ll, dgreen, bend left]\\&
	\bul[red]
\end{tikzcd}
\]
and the trees (which are also graphs) that its mate $S\yon^S\to\cofree{p}$ associates to each element of $S$, e.g.\ for the green dot:
\[
\treepic
\]
Indeed, there is a map of graphs from the latter to the former, which sends all the green dots in the tree to the green dot in the dynamical system, etc. This map of graphs is a kind of \emph{fibration}, or maybe we should say op-fibration, in the sense that the set of arrows emanating from every dot in the tree is in bijection with the set of arrows emanating from its image in the dynamical system graph.

\begin{exercise}
\begin{enumerate}
	\item Draw the other two trees associated to the dynamical system in \cref{ex.cofree_dyn_sys}.
	\item Do they also have an op-fibration down to the dynamical system graph?
	\item Are these op-fibrations special in any way? That is, are they unique, or have any universal property?
\qedhere
\end{enumerate}
\end{exercise}

\paragraph{Replacing $S\yon^S$ by another comonoid.}

For any interface $p$, we defined a dependent dynamical system---also called a generalized Moore machine---to be a set $S$ and a polynomial map $S\yon^S\to p$. But now it seems that what really makes this work is that $S\yon^S$ underlies a comonoid. This suggests that we could instead have defined a dependent dynamical system to be a comonoid $\cat{C}=(\ema{c},\epsilon,\delta)$ together with a map $\ema{c}\to p$. What are the similarities and differences?

Here are some similarities. We still get a cofunctor $F\colon\cat{C}\to\cofree{p}$, so we associate a $p$-tree to each object in $\cat{C}$ and pass back paths out of its root to morphisms in $\cat{C}$. In terms of dynamics, we would think of objects in $\cat{C}$ as internal states. We still have the situation from \eqref{eqn.comon_delta_k}, meaning that for every state $c\in\cat{C}$, we get a position $i\coloneqq F_1(c)$ in $p(\1)$, and for every direction $d\in p[i]$ there we get a new state $\cod(F^\sharp_c(d))\in\cat{C}$. 

But in fact we get a little more from $F$, and this is where the differences come in. Namely, given a direction $d\in p[i]$, we get the morphism $F^\sharp_c(d)$ itself. In the state category $S\yon^S$, there is a unique morphism between every two objects, so this passed-back morphism carries no data beyond what its codomain is. But for a more general comonoid $\cat{C}$, the morphisms \emph{do} carry data. 

Thus we can think of a map $\ema{c}\to p$ as a dynamical system that ``records its history''. That is, given a path $\cofree{p}$, a sequence of inputs to our dynamical system, we get a morphism in $\cat{C}$. If, unlike in a state category $S\yon^S$, there are multiple morphisms between objects, we will know which one was actually taken by the system.

This seems like a nice generalization of dynamical systems---history-recording dynamical systems---and may have some use. However, we will see in \cref{chapter.6} that there are strpmg theoretical reason to emphasize the ahistorical state categories $S\yon^S$. For one thing, the category of all such $S\yon^S$-style dynamical systems on $p$ forms a topos for any $p\in\poly$.


%---- Subsection ----%
\subsection{Some math about cofree comonoids}

\begin{proposition}\label{prop.cofree_free_on_graph}
For every polynomial $p$, the cofree category $\cofree{p}$ is free on a graph. That is, there is a graph $G_p$ whose associated free category in the usual sense (the category of vertices and paths in $G_p$) is isomorphic to $\cofree{p}$.
\end{proposition}
\begin{proof}
For vertices, we let $V_p$ denote the set of $p$-trees,
\[V_p\coloneqq\tr_p(\1).\]
For arrows we use the map $\pi\colon\tr_p\to p$ from \cref{**} to define
\[
A_p\coloneqq\sum_{t\in\tr_p(\1)}p[\pi_1(t)]
\]
In other words $A_p$ is the set $\{d\in p[\pi_1(t)]\,\mid\,t\in\tr_p\}$ of directions in $p$ that emanate from the root corolla of each $p$-tree. The source of $(t,d)$ is $t$ and the target is $\cod(\pi^\sharp_t(d))$. It is clear that every morphism in $\cofree{t}$ is the composite of a finite sequence of such morphisms, completing the proof.
\end{proof}


\begin{corollary}
Let $p$ be a polynomial and $\cofree{p}$ the cofree comonoid. Every morphism in $\cat{C}_p$ is both monic and epic.
\end{corollary}
\begin{proof}
The free category on a graph always has this property, so the result follows from \cref{prop.cofree_free_on_graph}.
\end{proof}

\begin{proposition}\label{prop.cofree_lax_monoidal}
The cofree functor $p\mapsto\cofree{p}=(\tr_p,\rt,\fs)$ is lax monoidal; in particular there is a map of polynomials $\yon\to\tr_\yon$, and for any $p,q\in\poly$ there is a natural map
\[
	\tr_p\otimes\tr_q\to\tr_{p\otimes q}.
\]
satisfying the usual conditions.
\end{proposition}
\begin{proof}
By \cref{prop.dirichlet_on_catsharp}, the left adjoint $U\colon\smcat^\sharp\to\poly$ is strong monoidal. A consequence of Kelly's doctrinal adjunction theorem \cite{kelly1974doctrinal} says that the right adjoint of an op-lax monoidal functor is lax monoidal.
\end{proof}

\begin{exercise}
\begin{enumerate}
	\item What polynomial is $\tr_\yon$?
	\item What is the map $\yon\to\tr_\yon$ from \cref{prop.cofree_lax_monoidal}?
	\item Explain in words how to think about the map $\tr_p\otimes\tr_q\to\tr_{p\otimes q}$ from \cref{prop.cofree_lax_monoidal}, for arbitrary $p,q\in\poly$.
\qedhere
\end{enumerate}
\end{exercise}

\begin{proposition}\label{prop.ynn_monoid}
The additive monoid $\yon^\nn$ of natural numbers has a $\times$-monoid structure in $\smcat^\sharp$.
\end{proposition}
\begin{proof}
The right adjoint $p\mapsto\cofree{p}$ preserves products, so $\yon^{\List(\ord{n})}\cong\cofree{\yon^{\ord{n}}}$ is the $n$-fold product of $\yon^\nn$ in $\smcat^\sharp$. We thus want to find cofunctors $e\colon \yon\to\yon^\nn$ and $m\colon\yon^{\List(\2)}\to\yon^\nn$ that satisfy the axioms of a monoid. 

The unique polynomial map $\yon\to\yon^\nn$ is a cofunctor (it is the mate of the identity $\yon\to\yon$). We take $m$ to be the mate of the polynomial map $\yon^{\List(\2)}\to\yon$ given by the list $[1,2]$. One can check by hand that these definitions make $(\yon^\nn,e,m)$ a monoid in $(\smcat^\sharp,\yon,\times)$.
\end{proof}

\begin{proposition}\label{prop.catsharp_to_mon}
The functor
\[\smcat^\sharp(-,\yon^\nn)\colon\smcat^\sharp\to\Cat{Mon}\op\]
represented by $\yon^\nn$ is right adjoint to the inclusion $\Cat{Mon}\op\to\smcat^\sharp$ from \cref{prop.monoids_ff}.
\end{proposition}
\begin{proof}
We saw that $\yon^\nn$ is a monoid object in \cref{prop.ynn_monoid}. A cofunctor $\cat{C}\cof\yon^\nn$ is a policy in $\cat{C}$: it assigns an outgoing morphism to each object of $\cat{C}$. Any two such trajectories can be multiplied: we simply do one and then the other; this is the monoid operation. The policy assigning the identity to each object is the unit of the monoid. Let's denote this functor by $T\coloneqq\smcat^\sharp(-,\yon^\nn)$.

Let $\cat{C}$ be a category and $(M,e,*)$ a monoid. A cofunctor $F\colon\cat{C}\cof\yon^M$ has no data on objects; it is just a way to assign to each $c\in \cat{C}$ and $m\in M$ a morphism $F^\sharp_c(m)\colon c\to c'$ for some $c'\coloneqq\cod(F^\sharp_c(m))$. This assignment must send identities to identities and composites to composites: given $m'\in M$ we have $F^\sharp_c(m\then m')=F^\sharp_c(m)\then F^\sharp_{c'}(m')$. This is exactly the data of a monoid morphism $M\to T(\cat{C})$: it assigns to each $m\in M$ a policy in $\cat{C}$, preserving unit and multiplication.
\end{proof}

\begin{proposition}\label{prop.traj_mon_poly}
There is a commutative square of left adjoints
\[
\begin{tikzcd}
	\Cat{Mon}\op\ar[r, "U"]\ar[d, "\yon^-"']&
	\smset\op\ar[d, "\yon^-"]\\
	\smcat^\sharp\ar[r, "U"']&
	\poly
\end{tikzcd}
\]
where the functors denoted $U$ are forgetful functors.
\end{proposition}
\begin{proof}
Using the fully faithful functor $\yon^-\colon\Cat{Mon}\op\fromto\smcat^\sharp$ from \cref{prop.monoids_ff}, it is easy to check that the above diagram commutes. 

The free-forgetful adjunction $\smset\fromto\Cat{Mon}$ gives an opposite adjunction $\smset\op\fromto\Cat{Mon}\op$, where $U$ is now left adjoint. We saw that $\yon^-\colon\smset\op\to\poly$ is a left adjoint in \cref{prop.yoneda_left_adjoint}, that $U\colon\smcat^\sharp\to\poly$ is a left adjoint in \cref{thm.cofree}, and that $\yon^-\colon\Cat{Mon}\to\smcat^\sharp$ is a left adjoint in \cref{prop.catsharp_to_mon}.
\end{proof}









\end{document}